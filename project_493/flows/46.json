[
  {
    "id": "bee1119e.c0aa7",
    "type": "tab",
    "label": "Main Flow1"
  },
  {
    "id": "9f396a53.0d3728",
    "type": "tab",
    "label": "Pull & Manipulate Data"
  },
  {
    "id": "b8aa44e1.6124b",
    "type": "tab",
    "label": "PLC Main"
  },
  {
    "id": "c95acbde.d1f77",
    "type": "tab",
    "label": "HMI Main"
  },
  {
    "id": "f41b39ff.87e2e",
    "type": "tab",
    "label": "Scratchpad"
  },
  {
    "id": "5292cd20.742e94",
    "type": "ui_tab",
    "z": "bee1119e.c0aa7",
    "name": "Home",
    "icon": "dashboard",
    "order": "1"
  },
  {
    "id": "d1e701f.f5a198",
    "type": "ui_tab",
    "z": "f41b39ff.87e2e",
    "name": "Home",
    "icon": "dashboard",
    "order": "1"
  },
  {
    "id": "5d8da11d.33533",
    "type": "ui_group",
    "z": "",
    "name": "Default",
    "tab": "5292cd20.742e94",
    "disp": true,
    "width": "6"
  },
  {
    "id": "5279e3fe.e81a4c",
    "type": "inject",
    "z": "bee1119e.c0aa7",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 199,
    "y": 89,
    "wires": [
      [
        "f5a10015.3b70f8",
        "78cc4446.027fdc"
      ]
    ]
  },
  {
    "id": "20dcf8bb.be8088",
    "type": "comment",
    "z": "bee1119e.c0aa7",
    "name": "Initiate Flow",
    "info": "",
    "x": 211,
    "y": 44,
    "wires": []
  },
  {
    "id": "f5a10015.3b70f8",
    "type": "function",
    "z": "bee1119e.c0aa7",
    "name": "Create UiOptions Dataset",
    "func": "\nmsg.options = \n[\n {       \"Controller Filter\": \"ControllerFilter\"},\n {       \"Task Filter\": \"TaskFilter\"},\n {       \"Program Filter\": \"ProgramFilter\"},\n {       \"Routine Filter\": \"RoutineFilter\"},\n {       \"Class Name Filter\": \"ClassNameFilter\"},\n  {      \"Module TagName Filter\": \"ModuleTagNameFilter\"}\n];\n\nmsg.paylod = \"RoutineFilter\";\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 444,
    "y": 89,
    "wires": [
      [
        "74f55f3f.11711"
      ]
    ]
  },
  {
    "id": "81ad2130.b49fe",
    "type": "comment",
    "z": "bee1119e.c0aa7",
    "name": "Placeholder for UI Options Creation",
    "info": "",
    "x": 445,
    "y": 42,
    "wires": []
  },
  {
    "id": "6fdf68a3.2d475",
    "type": "comment",
    "z": "bee1119e.c0aa7",
    "name": "Pull & Filter Datasets",
    "info": "",
    "x": 729,
    "y": 43,
    "wires": []
  },
  {
    "id": "78cc4446.027fdc",
    "type": "link out",
    "z": "bee1119e.c0aa7",
    "name": "PLC CMs & EMs Flow Input",
    "links": [
      "df975030.07cc3"
    ],
    "x": 349,
    "y": 145,
    "wires": []
  },
  {
    "id": "b5a2b8b9.b0222",
    "type": "debug",
    "z": "f41b39ff.87e2e",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "validationErrors",
    "x": 1738,
    "y": 170.11666870117188,
    "wires": []
  },
  {
    "id": "50709eb9.41e498",
    "type": "debug",
    "z": "f41b39ff.87e2e",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "false",
    "x": 1703,
    "y": 268.1166687011719,
    "wires": []
  },
  {
    "id": "e6051ed8.121868",
    "type": "debug",
    "z": "f41b39ff.87e2e",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "log",
    "x": 1696,
    "y": 211.11666870117188,
    "wires": []
  },
  {
    "id": "f0e07cdd.bd3928",
    "type": "ui_text",
    "z": "f41b39ff.87e2e",
    "group": "FRED",
    "order": 0,
    "name": "Output",
    "format": "{{msg.payload}}",
    "x": 1685,
    "y": 315.1166687011719,
    "wires": []
  },
  {
    "id": "e6f91a52.58c098",
    "type": "load_dataset",
    "z": "9f396a53.0d3728",
    "docid": "Program Structure (BBraun)",
    "docname": "",
    "version": "",
    "name": "Program Structure",
    "sheets": [
      {
        "sheetname": "Tasks",
        "columns": [
          "Controller",
          "Task",
          "Period",
          "Priority",
          "Watchdog"
        ]
      },
      {
        "sheetname": "Programs",
        "columns": [
          "Controller",
          "Program",
          "MainRoutine",
          "FaultRoutine",
          "ExecutionOrder"
        ]
      },
      {
        "sheetname": "Routines",
        "columns": [
          "Controller",
          "Routine",
          "ExecutionOrder"
        ]
      }
    ],
    "x": 406,
    "y": 560,
    "wires": [
      [
        "d64dd7e7.22dfa8"
      ]
    ]
  },
  {
    "id": "91dd8809.08c438",
    "type": "load_dataset",
    "z": "9f396a53.0d3728",
    "docid": "Class Definitions (PlantPax)",
    "docname": "",
    "version": "",
    "name": "Class Defs",
    "sheets": [
      {
        "sheetname": "CDef_UsageScenarios",
        "columns": [
          "ClassName",
          "UsageScenario",
          "ParameterName",
          "DataType",
          "ParameterMappingAction",
          "ValidateAgainstIOList",
          "CreateTag",
          "TagName",
          "TagDescription"
        ]
      },
      {
        "sheetname": "CDef_CodeSnippets",
        "columns": [
          "ClassName",
          "UsageScenario",
          "SnippetName",
          "Code",
          "Comment"
        ]
      },
      {
        "sheetname": "CDef_Parameters",
        "columns": [
          "ClassName",
          "ParameterName",
          "Usage",
          "DataType",
          "Description",
          "IsConfig",
          "IsBasicConfig",
          "IsOperatorEditable",
          "DefaultValue"
        ]
      }
    ],
    "x": 392,
    "y": 76,
    "wires": [
      [
        "3e700e4e.eb1502",
        "8d6f253c.816528",
        "ad7fec38.3daba8"
      ]
    ]
  },
  {
    "id": "6519ad06.1fb39c",
    "type": "load_dataset",
    "z": "9f396a53.0d3728",
    "docid": "Modules List (BBraun)",
    "docname": "book 3",
    "version": "",
    "name": "Modules List",
    "sheets": [
      {
        "sheetname": "Modules",
        "columns": [
          "Controller",
          "ModuleType",
          "ModuleTagName",
          "Task",
          "Program",
          "Routine",
          "ExecutionOrder"
        ]
      }
    ],
    "x": 385,
    "y": 640,
    "wires": [
      [
        "d64dd7e7.22dfa8"
      ]
    ]
  },
  {
    "id": "a15c5eb.76160a",
    "type": "load_dataset",
    "z": "9f396a53.0d3728",
    "docid": "Modules Data (BBraun)",
    "docname": "",
    "version": "",
    "name": "Module Data",
    "sheets": [
      {
        "sheetname": "P_AIn",
        "columns": [
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_FwdText",
          "Cfg_RevText",
          "Cfg_SpeedRefEU",
          "Cfg_SpeedRefRawMin",
          "Cfg_SpeedRefRawMax",
          "Cfg_SpeedRefEUMin",
          "Cfg_SpeedRefEUMax",
          "Cfg_SpeedFdbkEU",
          "Cfg_SpeedFdbkRawMin",
          "Cfg_SpeedFdbkRawMax",
          "Cfg_SpeedFdbkEUMin",
          "Cfg_SpeedFdbkEUMax",
          "Cfg_HasReverse",
          "Cfg_HasJog",
          "Cfg_AllowLocal",
          "Cfg_MinSpdRef",
          "Cfg_MaxSpdRef",
          "Cfg_MaxJogT",
          "Cfg_ResetPulseT",
          "Cfg_HasRunFdbk",
          "Cfg_UseRunFdbk",
          "Cfg_FailToStartT",
          "Cfg_FailToStopT",
          "Cfg_ShedOnFailToStart",
          "Cfg_ShedOnIOFault",
          "Cfg_InpDatalinkEU",
          "Cfg_InpDatalinkLabel",
          "Cfg_HasInpDatalink",
          "Cfg_InpDatalinkRawMin",
          "Cfg_InpDatalinkRawMax",
          "Cfg_InpDatalinkEUMin",
          "Cfg_InpDatalinkEUMax",
          "Cfg_OutDatalinkEU",
          "Cfg_OutDatalinkLabel",
          "Cfg_HasOutDatalink",
          "Cfg_OutDatalinkRawMin",
          "Cfg_OutDatalinkRawMax",
          "Cfg_OutDatalinkEUMin",
          "Cfg_OutDatalinkEUMax",
          "Cfg_OutDatalinkMin",
          "Cfg_OutDatalinkMax",
          "Cfg_SimRampT",
          "Cfg_SimScaleEU",
          "Cfg_SimScaleRaw",
          "Cfg_HasFwdPermObj",
          "Cfg_HasRevPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasResInhObj",
          "Cfg_HasRunTimeObj",
          "FailToStart.Cfg_Cond",
          "FailToStart.Cfg_Tag",
          "FailToStart.Cfg_Exists",
          "FailToStart.Cfg_ResetReqd",
          "FailToStart.Cfg_AckReqd",
          "FailToStart.Cfg_Severity",
          "FailToStart.Cfg_AllowShelve",
          "FailToStart.Cfg_AllowDisable",
          "FailToStart.Cfg_AlmMinOnT",
          "FailToStart.Cfg_MaxShelfT",
          "FailToStop.Cfg_Cond",
          "FailToStop.Cfg_Tag",
          "FailToStop.Cfg_Exists",
          "FailToStop.Cfg_ResetReqd",
          "FailToStop.Cfg_AckReqd",
          "FailToStop.Cfg_Severity",
          "FailToStop.Cfg_AllowShelve",
          "FailToStop.Cfg_AllowDisable",
          "FailToStop.Cfg_AlmMinOnT",
          "FailToStop.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "DriveFault.Cfg_Cond",
          "DriveFault.Cfg_Tag",
          "DriveFault.Cfg_Exists",
          "DriveFault.Cfg_ResetReqd",
          "DriveFault.Cfg_AckReqd",
          "DriveFault.Cfg_Severity",
          "DriveFault.Cfg_AllowShelve",
          "DriveFault.Cfg_AllowDisable",
          "DriveFault.Cfg_AlmMinOnT",
          "DriveFault.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_SetTrackOvrdHand",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperStopPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Cfg_SetTrack",
          "Cfg_OperKeep",
          "Cfg_ProgKeep",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_AInHART",
        "columns": [
          "ModuleTagName",
          "Ref_ChanDataTagName",
          "Ref_DiagTableTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_EU",
          "Cfg_InpRawMin",
          "Cfg_InpRawMax",
          "Cfg_PVEUMin",
          "Cfg_PVEUMax",
          "Cfg_HasHART",
          "Cfg_HasPV",
          "Cfg_PVLabel",
          "Cfg_PVEU",
          "Cfg_HasSV",
          "Cfg_SVLabel",
          "Cfg_SVEU",
          "Cfg_HasTV",
          "Cfg_TVLabel",
          "Cfg_TVEU",
          "Cfg_HasFV",
          "Cfg_FVLabel",
          "Cfg_FVEU",
          "Cfg_FiltTC",
          "Cfg_HiHiDB",
          "Cfg_HiDB",
          "Cfg_LoDB",
          "Cfg_LoLoDB",
          "Cfg_FailHiLim",
          "Cfg_FailLoLim",
          "Cfg_FailDB",
          "Cfg_NoSubstPV",
          "Cfg_HasHiHiAlm",
          "Cfg_HiHiResetReqd",
          "Cfg_HiHiAckReqd",
          "Cfg_HiHiSeverity",
          "Cfg_HiHiOnDly",
          "Cfg_HiHiOffDly",
          "Cfg_HiHiGateDly",
          "HiHiGate.Cfg_InpCond",
          "HiHiGate.Cfg_GateCond",
          "HiHi.Cfg_AllowShelve",
          "HiHi.Cfg_AllowDisable",
          "HiHi.Cfg_AlmMinOnT",
          "HiHi.Cfg_MaxShelfT",
          "HiHi.Cfg_Cond",
          "HiHi.Cfg_Tag",
          "Cfg_HasHiAlm",
          "Cfg_HiResetReqd",
          "Cfg_HiAckReqd",
          "Cfg_HiSeverity",
          "Cfg_HiOnDly",
          "Cfg_HiOffDly",
          "Cfg_HiGateDly",
          "HiGate.Cfg_InpCond",
          "HiGate.Cfg_GateCond",
          "Hi.Cfg_AllowShelve",
          "Hi.Cfg_AllowDisable",
          "Hi.Cfg_AlmMinOnT",
          "Hi.Cfg_MaxShelfT",
          "Hi.Cfg_Cond",
          "Hi.Cfg_Tag",
          "Cfg_HasLoAlm",
          "Cfg_LoResetReqd",
          "Cfg_LoAckReqd",
          "Cfg_LoSeverity",
          "Cfg_LoOnDly",
          "Cfg_LoOffDly",
          "Cfg_LoGateDly",
          "LoGate.Cfg_InpCond",
          "LoGate.Cfg_GateCond",
          "Lo.Cfg_AllowShelve",
          "Lo.Cfg_AllowDisable",
          "Lo.Cfg_AlmMinOnT",
          "Lo.Cfg_MaxShelfT",
          "Lo.Cfg_Cond",
          "Lo.Cfg_Tag",
          "Cfg_HasLoLoAlm",
          "Cfg_LoLoResetReqd",
          "Cfg_LoLoAckReqd",
          "Cfg_LoLoSeverity",
          "Cfg_LoLoOnDly",
          "Cfg_LoLoOffDly",
          "Cfg_LoLoGateDly",
          "LoLoGate.Cfg_InpCond",
          "LoLoGate.Cfg_GateCond",
          "LoLo.Cfg_AllowShelve",
          "LoLo.Cfg_AllowDisable",
          "LoLo.Cfg_AlmMinOnT",
          "LoLo.Cfg_MaxShelfT",
          "LoLo.Cfg_Cond",
          "LoLo.Cfg_Tag",
          "Cfg_HasFailAlm",
          "Cfg_FailResetReqd",
          "Cfg_FailAckReqd",
          "Cfg_FailSeverity",
          "Cfg_FailOnDly",
          "Cfg_FailOffDly",
          "Cfg_FailGateDly",
          "FailGate.Cfg_InpCond",
          "FailGate.Cfg_GateCond",
          "Fail.Cfg_AllowShelve",
          "Fail.Cfg_AllowDisable",
          "Fail.Cfg_AlmMinOnT",
          "Fail.Cfg_MaxShelfT",
          "Fail.Cfg_Cond",
          "Fail.Cfg_Tag",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack"
        ]
      },
      {
        "sheetname": "P_AOut",
        "columns": [
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_EU",
          "Cfg_CVEUMin",
          "Cfg_CVEUMax",
          "Cfg_CVRawMin",
          "Cfg_CVRawMax",
          "Cfg_MinCV",
          "Cfg_MaxCV",
          "Cfg_MaxCVRoCInc",
          "Cfg_MaxCVRoCDec",
          "Cfg_SkipRoCLim",
          "Cfg_MaxInactiveCV",
          "Cfg_ShedHold",
          "Cfg_ShedOnIOFault",
          "Cfg_IntlkCV",
          "Cfg_HasIntlkObj",
          "Cfg_HasCVNav",
          "Cfg_CVNavTag",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack",
          "Cfg_SetTrackOvrdHand",
          "Cfg_OvrdIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_AOutHART",
        "columns": [
          "ModuleTagName",
          "Ref_ChanDataTagName",
          "Ref_DiagTableTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_EU",
          "Cfg_CVEUMin",
          "Cfg_CVEUMax",
          "Cfg_CVRawMin",
          "Cfg_CVRawMax",
          "Cfg_MinCV",
          "Cfg_MaxCV",
          "Cfg_HasHART",
          "Cfg_HasPV",
          "Cfg_PVLabel",
          "Cfg_PVEU",
          "Cfg_HasSV",
          "Cfg_SVLabel",
          "Cfg_SVEU",
          "Cfg_HasTV",
          "Cfg_TVLabel",
          "Cfg_TVEU",
          "Cfg_HasFV",
          "Cfg_FVLabel",
          "Cfg_FVEU",
          "Cfg_MaxCVRoCInc",
          "Cfg_MaxCVRoCDec",
          "Cfg_SkipRoCLim",
          "Cfg_MaxInactiveCV",
          "Cfg_ShedHold",
          "Cfg_ShedOnIOFault",
          "Cfg_IntlkCV",
          "Cfg_HasIntlkObj",
          "Cfg_HasCVNav",
          "Cfg_CVNavTag",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack",
          "Cfg_SetTrackOvrdHand",
          "Cfg_OvrdIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_DIn",
        "columns": [
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_0StText",
          "Cfg_1StText",
          "Cfg_NoSubstPV",
          "Cfg_Debounce",
          "Cfg_NormTextVis",
          "Inp_Target",
          "TgtDisagreeGate.Cfg_InpCond",
          "TgtDisagreeGate.Cfg_GateCond",
          "TgtDisagreeGate.Cfg_GateDly",
          "TgtDisagreeGate.Cfg_OnDly",
          "TgtDisagreeGate.Cfg_OffDly",
          "TgtDisagree.Cfg_Cond",
          "TgtDisagree.Cfg_Tag",
          "TgtDisagree.Cfg_Exists",
          "TgtDisagree.Cfg_ResetReqd",
          "TgtDisagree.Cfg_AckReqd",
          "TgtDisagree.Cfg_Severity",
          "TgtDisagree.Cfg_AllowShelve",
          "TgtDisagree.Cfg_AllowDisable",
          "TgtDisagree.Cfg_AlmMinOnT",
          "TgtDisagree.Cfg_MaxShelfT",
          "Cfg_PCmdClear"
        ]
      },
      {
        "sheetname": "P_DOut",
        "columns": [
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_0StText",
          "Cfg_1StText",
          "Cfg_OnDelayT",
          "Cfg_OffDelayT",
          "Cfg_OnPulseT",
          "Cfg_OffPulseT",
          "Cfg_CompletePulse",
          "Cfg_OperOffPrio",
          "Cfg_HasOnFdbk",
          "Cfg_HasOffFdbk",
          "Cfg_UseOnFdbk",
          "Cfg_UseOffFdbk",
          "Cfg_FdbkFail",
          "Cfg_ShedOnFail",
          "Cfg_ShedOnIOFault",
          "Cfg_SimFdbkT",
          "Cfg_HasPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_OnFailT",
          "OnFail.Cfg_Cond",
          "OnFail.Cfg_Tag",
          "OnFail.Cfg_Exists",
          "OnFail.Cfg_ResetReqd",
          "OnFail.Cfg_AckReqd",
          "OnFail.Cfg_Severity",
          "OnFail.Cfg_AllowShelve",
          "OnFail.Cfg_AllowDisable",
          "OnFail.Cfg_AlmMinOnT",
          "OnFail.Cfg_MaxShelfT",
          "Cfg_OffFailT",
          "OffFail.Cfg_Cond",
          "OffFail.Cfg_Tag",
          "OffFail.Cfg_Exists",
          "OffFail.Cfg_ResetReqd",
          "OffFail.Cfg_AckReqd",
          "OffFail.Cfg_Severity",
          "OffFail.Cfg_AllowShelve",
          "OffFail.Cfg_AllowDisable",
          "OffFail.Cfg_AlmMinOnT",
          "OffFail.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperOffPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_PIDE",
        "columns": [
          "ModuleTagName",
          "InputValueTagName",
          "OutputValueTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_PVEU",
          "Cfg_PVEUMin",
          "Cfg_PVEUMax",
          "Cfg_CVEU",
          "Cfg_CVEUMin",
          "Cfg_CVEUMax",
          "Cfg_HasRatio",
          "Cfg_HasCasc",
          "Cfg_PVTrack",
          "Cfg_CtrlAction",
          "Cfg_Depend",
          "Cfg_DerivSmooth",
          "Cfg_ZCOff",
          "Cfg_LimitManCV",
          "Cfg_InitToMan",
          "Cfg_PropSPAct",
          "Cfg_DerivSPAct",
          "Cfg_PGain",
          "Cfg_IGain",
          "Cfg_DGain",
          "Cfg_ZCDB",
          "Cfg_MinRatio",
          "Cfg_MaxRatio",
          "Cfg_MinSP",
          "Cfg_MaxSP",
          "Cfg_MinCV",
          "Cfg_MaxCV",
          "Cfg_MaxInactiveCV",
          "Cfg_CVRoCLim",
          "Cfg_PwrupLM",
          "Cfg_PwrupSP",
          "Cfg_PwrupCV",
          "Cfg_DevDB",
          "Cfg_IntlkCV",
          "Cfg_HasIntlkObj",
          "Cfg_HasCascSPNav",
          "Cfg_CascSPNavTag",
          "Cfg_HasPVNav",
          "Cfg_PVNavTag",
          "Cfg_HasCVNav",
          "Cfg_CVNavTag",
          "HiHiDevGate.Cfg_InpCond",
          "HiHiDevGate.Cfg_GateCond",
          "HiHiDevGate.Cfg_GateDly",
          "HiHiDevGate.Cfg_OnDly",
          "HiHiDevGate.Cfg_OffDly",
          "HiHiDev.Cfg_Cond",
          "HiHiDev.Cfg_Tag",
          "HiHiDev.Cfg_Exists",
          "HiHiDev.Cfg_ResetReqd",
          "HiHiDev.Cfg_AckReqd",
          "HiHiDev.Cfg_Severity",
          "HiHiDev.Cfg_AllowShelve",
          "HiHiDev.Cfg_AllowDisable",
          "HiHiDev.Cfg_AlmMinOnT",
          "HiHiDev.Cfg_MaxShelfT",
          "HiDevGate.Cfg_InpCond",
          "HiDevGate.Cfg_GateCond",
          "HiDevGate.Cfg_GateDly",
          "HiDevGate.Cfg_OnDly",
          "HiDevGate.Cfg_OffDly",
          "HiDev.Cfg_Cond",
          "HiDev.Cfg_Tag",
          "HiDev.Cfg_Exists",
          "HiDev.Cfg_ResetReqd",
          "HiDev.Cfg_AckReqd",
          "HiDev.Cfg_Severity",
          "HiDev.Cfg_AllowShelve",
          "HiDev.Cfg_AllowDisable",
          "HiDev.Cfg_AlmMinOnT",
          "HiDev.Cfg_MaxShelfT",
          "LoDevGate.Cfg_InpCond",
          "LoDevGate.Cfg_GateCond",
          "LoDevGate.Cfg_GateDly",
          "LoDevGate.Cfg_OnDly",
          "LoDevGate.Cfg_OffDly",
          "LoDev.Cfg_Cond",
          "LoDev.Cfg_Tag",
          "LoDev.Cfg_Exists",
          "LoDev.Cfg_ResetReqd",
          "LoDev.Cfg_AckReqd",
          "LoDev.Cfg_Severity",
          "LoDev.Cfg_AllowShelve",
          "LoDev.Cfg_AllowDisable",
          "LoDev.Cfg_AlmMinOnT",
          "LoDev.Cfg_MaxShelfT",
          "LoLoDevGate.Cfg_InpCond",
          "LoLoDevGate.Cfg_GateCond",
          "LoLoDevGate.Cfg_GateDly",
          "LoLoDevGate.Cfg_OnDly",
          "LoLoDevGate.Cfg_OffDly",
          "LoLoDev.Cfg_Cond",
          "LoLoDev.Cfg_Tag",
          "LoLoDev.Cfg_Exists",
          "LoLoDev.Cfg_ResetReqd",
          "LoLoDev.Cfg_AckReqd",
          "LoLoDev.Cfg_Severity",
          "LoLoDev.Cfg_AllowShelve",
          "LoLoDev.Cfg_AllowDisable",
          "LoLoDev.Cfg_AlmMinOnT",
          "LoLoDev.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "Fail.Cfg_Cond",
          "Fail.Cfg_Tag",
          "Fail.Cfg_Exists",
          "Fail.Cfg_ResetReqd",
          "Fail.Cfg_AckReqd",
          "Fail.Cfg_Severity",
          "Fail.Cfg_AllowShelve",
          "Fail.Cfg_AllowDisable",
          "Fail.Cfg_AlmMinOnT",
          "Fail.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack",
          "Cfg_SetTrackOvrdHand",
          "Cfg_OvrdIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_ValveSO",
        "columns": [
          "ModuleTagName",
          "OutputTagName",
          "ZSCFeedbackTagName",
          "ZSOFeedbackTagName",
          "ResetInputTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_FailOpen",
          "Cfg_HasOpenLS",
          "Cfg_HasClosedLS",
          "Cfg_UseOpenLS",
          "Cfg_UseClosedLS",
          "Cfg_LSFail",
          "Cfg_FullStallT",
          "Cfg_TransitStallT",
          "Cfg_ShedOnFullStall",
          "Cfg_ShedOnTransitStall",
          "Cfg_ShedOnIOFault",
          "Cfg_SimFdbkT",
          "Cfg_HasPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasStatsObj",
          "FullStall.Cfg_Cond",
          "FullStall.Cfg_Tag",
          "FullStall.Cfg_Exists",
          "FullStall.Cfg_ResetReqd",
          "FullStall.Cfg_AckReqd",
          "FullStall.Cfg_Severity",
          "FullStall.Cfg_AllowShelve",
          "FullStall.Cfg_AllowDisable",
          "FullStall.Cfg_AlmMinOnT",
          "FullStall.Cfg_MaxShelfT",
          "TransitStall.Cfg_Cond",
          "TransitStall.Cfg_Tag",
          "TransitStall.Cfg_Exists",
          "TransitStall.Cfg_ResetReqd",
          "TransitStall.Cfg_AckReqd",
          "TransitStall.Cfg_Severity",
          "TransitStall.Cfg_AllowShelve",
          "TransitStall.Cfg_AllowDisable",
          "TransitStall.Cfg_AlmMinOnT",
          "TransitStall.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_VSD",
        "columns": [
          "ModuleTagName",
          "RunCommandTagName",
          "SpeedCommandTagName",
          "RunningFeedbackTagName",
          "SpeedFeedbackTagName",
          "FaultedFeedbackTagName",
          "HandInputTagName",
          "ResetInputTagName",
          "RuntimeStatsTagName",
          "CodeOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_FwdText",
          "Cfg_RevText",
          "Cfg_SpeedRefEU",
          "Cfg_SpeedRefRawMin",
          "Cfg_SpeedRefRawMax",
          "Cfg_SpeedRefEUMin",
          "Cfg_SpeedRefEUMax",
          "Cfg_SpeedFdbkEU",
          "Cfg_SpeedFdbkRawMin",
          "Cfg_SpeedFdbkRawMax",
          "Cfg_SpeedFdbkEUMin",
          "Cfg_SpeedFdbkEUMax",
          "Cfg_HasReverse",
          "Cfg_HasJog",
          "Cfg_AllowLocal",
          "Cfg_MinSpdRef",
          "Cfg_MaxSpdRef",
          "Cfg_MaxJogT",
          "Cfg_ResetPulseT",
          "Cfg_HasRunFdbk",
          "Cfg_UseRunFdbk",
          "Cfg_FailToStartT",
          "Cfg_FailToStopT",
          "Cfg_ShedOnFailToStart",
          "Cfg_ShedOnIOFault",
          "Cfg_InpDatalinkEU",
          "Cfg_InpDatalinkLabel",
          "Cfg_HasInpDatalink",
          "Cfg_InpDatalinkRawMin",
          "Cfg_InpDatalinkRawMax",
          "Cfg_InpDatalinkEUMin",
          "Cfg_InpDatalinkEUMax",
          "Cfg_OutDatalinkEU",
          "Cfg_OutDatalinkLabel",
          "Cfg_HasOutDatalink",
          "Cfg_OutDatalinkRawMin",
          "Cfg_OutDatalinkRawMax",
          "Cfg_OutDatalinkEUMin",
          "Cfg_OutDatalinkEUMax",
          "Cfg_OutDatalinkMin",
          "Cfg_OutDatalinkMax",
          "Cfg_SimRampT",
          "Cfg_SimScaleEU",
          "Cfg_SimScaleRaw",
          "Cfg_HasFwdPermObj",
          "Cfg_HasRevPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasResInhObj",
          "Cfg_HasRunTimeObj",
          "FailToStart.Cfg_Cond",
          "FailToStart.Cfg_Tag",
          "FailToStart.Cfg_Exists",
          "FailToStart.Cfg_ResetReqd",
          "FailToStart.Cfg_AckReqd",
          "FailToStart.Cfg_Severity",
          "FailToStart.Cfg_AllowShelve",
          "FailToStart.Cfg_AllowDisable",
          "FailToStart.Cfg_AlmMinOnT",
          "FailToStart.Cfg_MaxShelfT",
          "FailToStop.Cfg_Cond",
          "FailToStop.Cfg_Tag",
          "FailToStop.Cfg_Exists",
          "FailToStop.Cfg_ResetReqd",
          "FailToStop.Cfg_AckReqd",
          "FailToStop.Cfg_Severity",
          "FailToStop.Cfg_AllowShelve",
          "FailToStop.Cfg_AllowDisable",
          "FailToStop.Cfg_AlmMinOnT",
          "FailToStop.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "DriveFault.Cfg_Cond",
          "DriveFault.Cfg_Tag",
          "DriveFault.Cfg_Exists",
          "DriveFault.Cfg_ResetReqd",
          "DriveFault.Cfg_AckReqd",
          "DriveFault.Cfg_Severity",
          "DriveFault.Cfg_AllowShelve",
          "DriveFault.Cfg_AllowDisable",
          "DriveFault.Cfg_AlmMinOnT",
          "DriveFault.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_SetTrackOvrdHand",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperStopPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Cfg_SetTrack",
          "Cfg_OperKeep",
          "Cfg_ProgKeep",
          "Mode.Cfg_OvrdOverLock"
        ]
      }
    ],
    "x": 384,
    "y": 716,
    "wires": [
      [
        "d64dd7e7.22dfa8"
      ]
    ]
  },
  {
    "id": "1043ee61.e6a33a",
    "type": "load_dataset",
    "z": "9f396a53.0d3728",
    "docid": "Interlocks & Permissives Data (BBraun)",
    "docname": "",
    "version": "",
    "name": "ILocks & Perms Data",
    "sheets": [
      {
        "sheetname": "Interlocks",
        "columns": [
          "ModuleTagName",
          "ItemNumber",
          "Code",
          "Description",
          "AssociatedTag",
          "OkayState",
          "IsBypassable",
          "CanNavigate"
        ]
      },
      {
        "sheetname": "Permissives",
        "columns": [
          "ModuleTagName",
          "ItemNumber",
          "Code",
          "Description",
          "AssociatedTag",
          "OkayState",
          "IsBypassable",
          "CanNavigate"
        ]
      }
    ],
    "x": 408,
    "y": 792,
    "wires": [
      [
        "7b2705a0.cda85c"
      ]
    ]
  },
  {
    "id": "eb390c0.64feff8",
    "type": "load_dataset",
    "z": "9f396a53.0d3728",
    "docid": "IO List (BBraun)",
    "docname": "",
    "version": "",
    "name": "IO List",
    "sheets": [
      {
        "sheetname": "IOList",
        "columns": [
          "Panel",
          "Controller",
          "Rack",
          "Slot",
          "Channel",
          "IOType",
          "ElectricalType",
          "IODescription",
          "InstrumentID",
          "InstrumentModelNumber",
          "FailState",
          "OffMessage",
          "OnMessage",
          "EUMin",
          "EUMax",
          "EU",
          "ControllerIODataType",
          "ControllerIOTagName",
          "P&ID",
          "Notes",
          "WiringBlock",
          "TerminalSet",
          "Terminal#"
        ]
      }
    ],
    "x": 366,
    "y": 488,
    "wires": [
      [
        "d64dd7e7.22dfa8"
      ]
    ]
  },
  {
    "id": "df975030.07cc3",
    "type": "link in",
    "z": "9f396a53.0d3728",
    "name": "Pull & Manipulate Data",
    "links": [
      "78cc4446.027fdc"
    ],
    "x": 146,
    "y": 77,
    "wires": [
      [
        "91dd8809.08c438",
        "e6f91a52.58c098",
        "6519ad06.1fb39c",
        "a15c5eb.76160a",
        "1043ee61.e6a33a",
        "eb390c0.64feff8",
        "17176ad4.bfe28d"
      ]
    ]
  },
  {
    "id": "17176ad4.bfe28d",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "ILock & Perm Options",
    "func": "msg.payload = {\n    \"InterlockOptions\":{\n        \"MinimumIndex\":0,     \t\t\t// The starting index to use\n        \"MaximumIndex\":15,    \t\t\t// The ending index to use\n        \"InsertPlaceHolders\":false,     // Enables inserting placeholder branches for indexes that aren't specified\n        \"MinimumIntegerDigits\": 2       // The minimum string length when printing out the current index\n    },\n    \"PermissiveOptions\":{\n        \"MinimumIndex\":0,     \t\t\t// The starting index to use\n        \"MaximumIndex\":15,   \t\t\t// The ending index to use\n        \"InsertPlaceHolders\":false,     // Enables inserting placeholder branches for indexes that aren't specified\n        \"MinimumIntegerDigits\": 2       // The minimum string length when printing out the current index\n    },\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 407,
    "y": 834.25,
    "wires": [
      [
        "7b2705a0.cda85c"
      ]
    ]
  },
  {
    "id": "7b2705a0.cda85c",
    "type": "join",
    "z": "9f396a53.0d3728",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 989,
    "y": 792.25,
    "wires": [
      [
        "a55c232d.38cc08",
        "50752f1b.eb4f58"
      ]
    ]
  },
  {
    "id": "50752f1b.eb4f58",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Pivot Permissives",
    "func": "// Debug Messages\nmsg.log = \"Starting Pivot Permissives...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Declare variables\n/*{\n    \"Permissives_Pivoted\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Permissives\":[{\n            \"Index\":index_i,\n            \"ConditionCode\":conditionCode_i,\n            \"Description\":description_i,\n            \"IsDebounced\":isDebounced_i,\n            \"DebounceTime\":debounceTime_i,\n            \"OkayState\":okayState_i,\n            \"IsBypassable\":isBypassable_i,\n            \"CanNavigate\":canNavigate_i,\n            \"AssociatedTag\":associatedTag_i\n        }],\n    }]\n}*/\nvar returnDataSet = [];\n\n// Pull all of the permissive options to use\nvar minimumIndex = Number(msg.payload.PermissiveOptions.MinimumIndex);\nvar maximumIndex = Number(msg.payload.PermissiveOptions.MaximumIndex);\nvar insertPlaceHolders = parseBoolean(msg.payload.PermissiveOptions.InsertPlaceHolders);\n\n\n\n\n//TODO: Pre-sort msg.payload.Permissives by Controller, then ModuleTagName, then Index\n\n\n\n\n//Iterate the rows in the Permissives data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.Permissives.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.Permissives[i];\n    \n    // Pull the current row's data\n    var controller_i = row.Controller;\n    var moduleTagName_i = row.ModuleTagName;\n    var index_i = row.Index;\n    var conditionCode_i = row.ConditionCode;\n    var description_i = row.Description;\n    var isDebounced_i = parseBoolean(row.IsDebounced);\n    var debounceTime_i = Number(row.DebounceTime);\n    var okayState_i = parseBoolean(row.OkayState);\n    var isBypassable_i = parseBoolean(row.IsBypassable);\n    var canNavigate_i = parseBoolean(row.CanNavigate);\n    var associatedTag_i = row.AssociatedTag;\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Row = \" + controller_i + \"-\" + moduleTagName_i + \".\";\n    \n    // Test if the index is a number or not\n    if (isNaN(index_i)) {\n        // Index is not a number\n        msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": cannot add permissive because index (\" +\n                index_i + \") is not a number.\";\n    }\n    else {\n        // Index is a number\n        // Force to be an integer\n        index_i = Math.trunc(index_i)\n        \n        // Get a list of all elements matching the current Controller & Module Tag Name\n        var tempModulesArray = returnDataSet.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controller_i) &&\n                        (element.ModuleTagName === moduleTagName_i));\n                }\n            });\n        \n        // Debug Messages\n        //msg.log = msg.log + \"\\n\" + \"Number of Elements = \" + tempModulesArray.length;\n        \n        // Test if the module exists yet or not.\n        if (tempModulesArray.length <= 0) {\n            // Cannot find this ClassName in the returnDataSet\n            var tempObj = {\n                    \"Controller\":controller_i,\n                    \"ModuleTagName\":moduleTagName_i,\n                    \"Permissives\":[]\n                }\n            \n            // Insert all placeholders if configured to do so\n            if (insertPlaceHolders) {\n                for (var j = minimumIndex; j <= maximumIndex; j++) {\n                    // Add a new object to the return set\n                    tempObj.Permissives.push({\n                            \"Index\":j,\n                            \"ConditionCode\":null,\n                            \"Description\":\"\",\n                            \"IsDebounced\":false,\n                            \"DebounceTime\":0,\n                            \"OkayState\":0,\n                            \"IsBypassable\":false,\n                            \"CanNavigate\":false,\n                            \"AssociatedTag\":\"\"\n                        });\n                }\n            }\n            \n            // Add a new object to the return set\n            returnDataSet.push(tempObj);\n        }\n        \n        // Re-pull list of all elements matching the current Controller & Module Tag Name\n        tempModulesArray = returnDataSet.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controller_i) &&\n                        (element.ModuleTagName === moduleTagName_i));\n                }\n            });\n        \n        // Test if the module exists yet or not.\n        if (tempModulesArray.length > 0) {\n            // Already found this module in the returnDataSet\n            // Cache a reference to the first element for the current moduloe\n            var tempModule = tempModulesArray[0];\n            \n            //Test if index is valid\n            if ((index_i < minimumIndex) || (index_i > maximumIndex)) {\n                // Index is outside of acceptable range\n                // Log a validation error\n                msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": permissive index (\" + index_i + \n                    \") is outside of the acceptable range of \" + minimumIndex + \" to \" + maximumIndex;\n            }\n            else {\n                // Index is within acceptable range\n                // Get a list of all elements matching the current index\n                var tempPermissivesArray = tempModule.Permissives.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return (element.Index === index_i);\n                        }\n                    });\n                \n                // Test if the index exists yet or not.\n                if (tempPermissivesArray.length > 0) {\n                    // Already found this index in the returnDataSet\n                    // Cache a reference to the first element \n                    var tempPermissive = tempPermissivesArray[0];\n                    \n                    // Test if the condition code was created as part of the placeholder insertion, but has NOT already been set\n                    if (insertPlaceHolders && (tempPermissive.ConditionCode === null)) {\n                        // Update the existing permissive\n                        tempPermissive.Index = index_i;\n                        tempPermissive.ConditionCode = conditionCode_i;\n                        tempPermissive.Description = description_i;\n                        tempPermissive.IsDebounced = isDebounced_i;\n                        tempPermissive.DebounceTime = debounceTime_i;\n                        tempPermissive.OkayState = okayState_i;\n                        tempPermissive.IsBypassable = isBypassable_i;\n                        tempPermissive.CanNavigate = canNavigate_i;\n                        tempPermissive.AssociatedTag = associatedTag_i;\n                    }\n                    else {\n                        msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": cannot add permissive \" +\n                            index_i + \" to the list because it already exists.\";\n                    }\n                }\n                else {\n                    // Cannot find this UsageScenario in the returnDataSet\n                    // Add a new object to the return set\n                    tempModule.Permissives.push({\n                            \"Index\":index_i,\n                            \"ConditionCode\":conditionCode_i,\n                            \"Description\":description_i,\n                            \"IsDebounced\":isDebounced_i,\n                            \"DebounceTime\":debounceTime_i,\n                            \"OkayState\":okayState_i,\n                            \"IsBypassable\":isBypassable_i,\n                            \"CanNavigate\":canNavigate_i,\n                            \"AssociatedTag\":associatedTag_i\n                        });\n                }\n            }\n        }\n        else {\n            // Cannot find this module in the returnDataSet\n            // Log a validation error\n            msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": cannot find this module immediately after adding it.\";\n        }\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\n    \"Permissives_Pivoted\": returnDataSet,\n    \"PermissiveOptions\": msg.payload.PermissiveOptions\n};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1193.6666259765625,
    "y": 900.916748046875,
    "wires": [
      [
        "e606871f.81c458",
        "de5e242a.c6a5f8",
        "4284640e.7d9a1c"
      ]
    ]
  },
  {
    "id": "a55c232d.38cc08",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Pivot Interlocks",
    "func": "// Debug Messages\nmsg.log = \"Starting Pivot Interlocks...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Declare variables\n/*{\n    \"Interlocks_Pivoted\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Interlocks\":[{\n            \"Index\":index_i,\n            \"ConditionCode\":conditionCode_i,\n            \"Description\":description_i,\n            \"IsDebounced\":isDebounced_i,\n            \"DebounceTime\":debounceTime_i,\n            \"OkayState\":okayState_i,\n            \"IsBypassable\":isBypassable_i,\n            \"CanNavigate\":canNavigate_i,\n            \"AssociatedTag\":associatedTag_i\n        }],\n    }]\n}*/\nvar returnDataSet = [];\n\n// Pull all of the interlock options to use\nvar minimumIndex = Number(msg.payload.InterlockOptions.MinimumIndex);\nvar maximumIndex = Number(msg.payload.InterlockOptions.MaximumIndex);\nvar insertPlaceHolders = parseBoolean(msg.payload.InterlockOptions.InsertPlaceHolders);\n\n\n\n\n//TODO: Pre-sort msg.payload.Interlocks by Controller, then ModuleTagName, then Index\n\n\n\n\n//Iterate the rows in the Interlocks data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.Interlocks.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.Interlocks[i];\n    \n    // Pull the current row's data\n    var controller_i = row.Controller;\n    var moduleTagName_i = row.ModuleTagName;\n    var index_i = row.Index;\n    var conditionCode_i = row.ConditionCode;\n    var description_i = row.Description;\n    var isDebounced_i = parseBoolean(row.IsDebounced);\n    var debounceTime_i = Number(row.DebounceTime);\n    var okayState_i = parseBoolean(row.OkayState);\n    var isBypassable_i = parseBoolean(row.IsBypassable);\n    var canNavigate_i = parseBoolean(row.CanNavigate);\n    var associatedTag_i = row.AssociatedTag;\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Row = \" + controller_i + \"-\" + moduleTagName_i + \".\";\n    \n    // Test if the index is a number or not\n    if (isNaN(index_i)) {\n        // Index is not a number\n        msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": cannot add interlock because index (\" +\n                index_i + \") is not a number.\";\n    }\n    else {\n        // Index is a number\n        // Force to be an integer\n        index_i = Math.trunc(index_i)\n        \n        // Get a list of all elements matching the current Controller & Module Tag Name\n        var tempModulesArray = returnDataSet.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controller_i) &&\n                        (element.ModuleTagName === moduleTagName_i));\n                }\n            });\n        \n        // Debug Messages\n        //msg.log = msg.log + \"\\n\" + \"Number of Elements = \" + tempModulesArray.length;\n        \n        // Test if the module exists yet or not.\n        if (tempModulesArray.length <= 0) {\n            // Cannot find this ClassName in the returnDataSet\n            var tempObj = {\n                    \"Controller\":controller_i,\n                    \"ModuleTagName\":moduleTagName_i,\n                    \"Interlocks\":[]\n                }\n            \n            // Insert all placeholders if configured to do so\n            if (insertPlaceHolders) {\n                for (var j = minimumIndex; j <= maximumIndex; j++) {\n                    // Add a new object to the return set\n                    tempObj.Interlocks.push({\n                            \"Index\":j,\n                            \"ConditionCode\":null,\n                            \"Description\":\"\",\n                            \"IsDebounced\":false,\n                            \"DebounceTime\":0,\n                            \"OkayState\":0,\n                            \"IsBypassable\":false,\n                            \"CanNavigate\":false,\n                            \"AssociatedTag\":\"\"\n                        });\n                }\n            }\n            \n            // Add a new object to the return set\n            returnDataSet.push(tempObj);\n        }\n        \n        // Re-pull list of all elements matching the current Controller & Module Tag Name\n        tempModulesArray = returnDataSet.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controller_i) &&\n                        (element.ModuleTagName === moduleTagName_i));\n                }\n            });\n        \n        // Test if the module exists yet or not.\n        if (tempModulesArray.length > 0) {\n            // Already found this module in the returnDataSet\n            // Cache a reference to the first element for the current moduloe\n            var tempModule = tempModulesArray[0];\n            \n            //Test if index is valid\n            if ((index_i < minimumIndex) || (index_i > maximumIndex)) {\n                // Index is outside of acceptable range\n                // Log a validation error\n                msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": interlock index (\" + index_i + \n                    \") is outside of the acceptable range of \" + minimumIndex + \" to \" + maximumIndex;\n            }\n            else {\n                // Index is within acceptable range\n                // Get a list of all elements matching the current index\n                var tempInterlocksArray = tempModule.Interlocks.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return (element.Index === index_i);\n                        }\n                    });\n                \n                // Test if the index exists yet or not.\n                if (tempInterlocksArray.length > 0) {\n                    // Already found this index in the returnDataSet\n                    // Cache a reference to the first element \n                    var tempInterlock = tempInterlocksArray[0];\n                    \n                    // Test if the condition code was created as part of the placeholder insertion, but has NOT already been set\n                    if (insertPlaceHolders && (tempInterlock.ConditionCode === null)) {\n                        // Update the existing interlock\n                        tempInterlock.Index = index_i;\n                        tempInterlock.ConditionCode = conditionCode_i;\n                        tempInterlock.Description = description_i;\n                        tempInterlock.IsDebounced = isDebounced_i;\n                        tempInterlock.DebounceTime = debounceTime_i;\n                        tempInterlock.OkayState = okayState_i;\n                        tempInterlock.IsBypassable = isBypassable_i;\n                        tempInterlock.CanNavigate = canNavigate_i;\n                        tempInterlock.AssociatedTag = associatedTag_i;\n                    }\n                    else {\n                        msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": cannot add interlock \" +\n                            index_i + \" to the list because it already exists.\";\n                    }\n                }\n                else {\n                    // Cannot find this UsageScenario in the returnDataSet\n                    // Add a new object to the return set\n                    tempModule.Interlocks.push({\n                            \"Index\":index_i,\n                            \"ConditionCode\":conditionCode_i,\n                            \"Description\":description_i,\n                            \"IsDebounced\":isDebounced_i,\n                            \"DebounceTime\":debounceTime_i,\n                            \"OkayState\":okayState_i,\n                            \"IsBypassable\":isBypassable_i,\n                            \"CanNavigate\":canNavigate_i,\n                            \"AssociatedTag\":associatedTag_i\n                        });\n                }\n            }\n        }\n        else {\n            // Cannot find this module in the returnDataSet\n            // Log a validation error\n            msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \": cannot find this module immediately after adding it.\";\n        }\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\n    \"Interlocks_Pivoted\": returnDataSet,\n    \"InterlockOptions\": msg.payload.InterlockOptions\n};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1186.6666259765625,
    "y": 792.916748046875,
    "wires": [
      [
        "33f49250.3a1d1e",
        "dccb451a.5789c8",
        "4284640e.7d9a1c"
      ]
    ]
  },
  {
    "id": "de5e242a.c6a5f8",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1191.6666564941406,
    "y": 978.9167556762695,
    "wires": []
  },
  {
    "id": "e606871f.81c458",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1233.6666564941406,
    "y": 941.9167556762695,
    "wires": []
  },
  {
    "id": "33f49250.3a1d1e",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1196.6666259765625,
    "y": 865.9167175292969,
    "wires": []
  },
  {
    "id": "dccb451a.5789c8",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1234.6666259765625,
    "y": 829.9167175292969,
    "wires": []
  },
  {
    "id": "600e02.56dd42",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1197.765625,
    "y": 262,
    "wires": []
  },
  {
    "id": "98af7445.ba373",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1237.765625,
    "y": 225,
    "wires": []
  },
  {
    "id": "97ea6a53.e9f258",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Pivot CDef_CodeSnippets",
    "func": "// Debug Messages\nmsg.log = \"Starting Pivot Class Def Code Snippets...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Declare variables\n/*{\n    \"CDef_CodeSnippets_Pivoted\":[{\n        \"ClassName\":className_i,\n        \"UsageScenarios\":[{\n            \"UsageScenarioName\":usageScenario_i,\n            \"Snippets\":[{\n                \"SnippetName\":snippetName_i,\n                \"Code\":code_i,\n                \"Comment\":comment_i\n            }]\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n//Iterate the rows in the CDef_CodeSnippets data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_CodeSnippets.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_CodeSnippets[i];\n    \n    // Pull the current rows data\n    var className_i = row.ClassName;\n    var usageScenario_i = row.UsageScenario;\n    var snippetName_i = row.SnippetName;\n    var code_i = row.Code;\n    var comment_i = row.Comment;\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Row = \" + className_i + \"-\" + usageScenario_i + \"-\" + snippetName_i + \".\";\n    \n    // Get a list of all elements matching the current ClassName\n    var tempClassNamesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === className_i);\n            }\n        });\n    \n    // Debug Messages\n    //msg.log = msg.log + \"\\n\" + \"Number of Elements = \" + tempClassNamesArray.length;\n    \n    // Test if the ClassName exists yet or not.\n    if (tempClassNamesArray.length > 0) {\n        // Already found this ClassName in the returnDataSet\n        // Cache a reference to the first element for the current ClassName\n        var tempClassName = tempClassNamesArray[0];\n        \n        // Get a list of all elements matching the current ClassName\n        var tempUsageScenariosArray = tempClassName.UsageScenarios.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.UsageScenarioName === usageScenario_i);\n                }\n            });\n        \n         // Test if the UsageScenario exists yet or not.\n        if (tempUsageScenariosArray.length > 0) {\n            // Already found this UsageScenario in the returnDataSet\n            // Cache a reference to the first element for the current UsageScenario\n            var tempUsageScenario = tempUsageScenariosArray[0];\n            \n            // Get a list of all elements matching the current SnippetName\n            var tempSnippetsArray = tempUsageScenario.Snippets.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.SnippetName === snippetName_i);\n                    }\n                });\n            \n             // Test if the SnippetName exists yet or not.\n            if (tempSnippetsArray.length > 0) {\n                // Already found this SnippetName in the returnDataSet\n                // Debug messages\n                msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot add \" +\n                    snippetName_i + \" to the class definition because it already exists.\";\n            }\n            else {\n                // Cannot find this UsageScenario in the returnDataSet\n                // Add a new object to the return set\n                tempUsageScenario.Snippets.push({\n                        \"SnippetName\":snippetName_i,\n                        \"Code\":code_i,\n                        \"Comment\":comment_i\n                    });\n            }\n        }\n        else {\n            // Cannot find this UsageScenario in the returnDataSet\n            // Add a new object to the return set\n            tempClassName.UsageScenarios.push({\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Snippets\":[{\n                        \"SnippetName\":snippetName_i,\n                        \"Code\":code_i,\n                        \"Comment\":comment_i\n                    }]\n                });\n        }\n    }\n    else {\n        // Cannot find this ClassName in the returnDataSet\n        // Add a new object to the return set\n        returnDataSet.push({\n                \"ClassName\":className_i,\n                \"UsageScenarios\":[{\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Snippets\":[{\n                        \"SnippetName\":snippetName_i,\n                        \"Code\":code_i,\n                        \"Comment\":comment_i\n                    }]\n                }]\n            });\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload.CDef_CodeSnippets_Pivoted = returnDataSet;\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1217,
    "y": 187.25,
    "wires": [
      [
        "98af7445.ba373",
        "600e02.56dd42",
        "ccb2c0dc.cbd788"
      ]
    ]
  },
  {
    "id": "ea81c72c.ce298",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Pivot CDef_Parameters",
    "func": "// Debug Messages\nmsg.log = \"Starting Pivot Class Def Parameters...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Declare variables\n/*{\n    \"CDef_Parameters_Pivoted\":[{\n        \"ClassName\":className_i,\n        \"Parameters\":[{\n            \"ParameterName\":parameterName_i,\n            \"Usage\":usage_i,\n            \"DataType\":dataType_i,\n            \"Description\":description_i,\n            \"DefaultValue\":defaultValue_i,\n            \"IsConfig\":isConfig_i,\n            \"IsBasicConfig\":isBasicConfig_i,\n            \"IsOperatorEditable\":isOperatorEditable_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n//Iterate the rows in the CDef_Parameters data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_Parameters.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_Parameters[i];\n    \n    // Pull the current row's data\n    var className_i = row.ClassName;\n    var parameterName_i = row.ParameterName;\n    var usage_i = row.Usage;\n    var dataType_i = row.DataType;\n    var description_i = row.Description;\n    var defaultValue_i = row.DefaultValue;\n    var isConfig_i = parseBoolean(row.IsConfig);\n    var isBasicConfig_i = parseBoolean(row.IsBasicConfig);\n    var isOperatorEditable_i = parseBoolean(row.IsOperatorEditable);\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Row = \" + className_i + \"-\" + parameterName_i + \".\";\n    \n    // Get a list of all elements matching the current ClassName\n    var tempClassNamesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === className_i);\n            }\n        });\n    \n    // Debug Messages\n    //msg.log = msg.log + \"\\n\" + \"Number of Elements = \" + tempClassNamesArray.length;\n    \n    // Test if the ClassName exists yet or not.\n    if (tempClassNamesArray.length > 0) {\n        // Already found this ClassName in the returnDataSet\n        // Cache a reference to the first element for the current ClassName\n        var tempClassName = tempClassNamesArray[0];\n        \n        // Get a list of all elements matching the current ParameterName\n        var tempParametersArray = tempClassName.Parameters.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.ParameterName === parameterName_i);\n                }\n            });\n        \n        // Test if the ParameterName exists yet or not.\n        if (tempParametersArray.length > 0) {\n            // Already found this ParameterName in the returnDataSet\n            // Debug messages\n            msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot add \" +\n                parameterName_i + \" to the class definition because it already exists.\";\n        }\n        else {\n            // Cannot find this UsageScenario in the returnDataSet\n            // Add a new object to the return set\n            tempClassName.Parameters.push({\n                    \"ParameterName\":parameterName_i,\n                    \"Usage\":usage_i,\n                    \"DataType\":dataType_i,\n                    \"Description\":description_i,\n                    \"DefaultValue\":defaultValue_i,\n                    \"IsConfig\":isConfig_i,\n                    \"IsBasicConfig\":isBasicConfig_i,\n                    \"IsOperatorEditable\":isOperatorEditable_i\n                });\n        }\n    }\n    else {\n        // Cannot find this ClassName in the returnDataSet\n        // Add a new object to the return set\n        returnDataSet.push({\n                \"ClassName\":className_i,\n                \"Parameters\":[{\n                    \"ParameterName\":parameterName_i,\n                    \"Usage\":usage_i,\n                    \"DataType\":dataType_i,\n                    \"Description\":description_i,\n                    \"DefaultValue\":defaultValue_i,\n                    \"IsConfig\":isConfig_i,\n                    \"IsBasicConfig\":isBasicConfig_i,\n                    \"IsOperatorEditable\":isOperatorEditable_i\n                }]\n            });\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload.CDef_Parameters_Pivoted = returnDataSet;\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1208,
    "y": 301.25,
    "wires": [
      [
        "cc005947.5d39c8",
        "999ca32a.59058",
        "ccb2c0dc.cbd788"
      ]
    ]
  },
  {
    "id": "1f7b5c2d.38fcac",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Pivot CDef_UsageScenarios",
    "func": "// Debug Messages\nmsg.log = \"Starting Pivot Class Def Usage Scenarios...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Declare variables\n/*{\n    \"CDef_UsageScenarios_Pivoted\":[{\n        \"ClassName\":className_i,\n        \"UsageScenarios\":[{\n            \"UsageScenarioName\":usageScenario_i,\n            \"Parameters\":[{\n                \"ParameterName\":parameterName_i,\n                \"DataType\":dataType_i,\n                \"ParameterMappingAction\":parameterMappingAction_i,\n                \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                \"CreateTag\":createTag_i,\n                \"TagName\":tagName_i,\n                \"TagDescription\":tagDescription_i\n            }]\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_UsageScenarios.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_UsageScenarios[i];\n    \n    // Pull the current rows data\n    var className_i = row.ClassName;\n    var usageScenario_i = row.UsageScenario;\n    var parameterName_i = row.ParameterName;\n    var dataType_i = row.DataType;\n    var parameterMappingAction_i = row.ParameterMappingAction;\n    var validateAgainstIOList_i = parseBoolean(row.ValidateAgainstIOList);\n    var createTag_i = parseBoolean(row.CreateTag);\n    var tagName_i = row.TagName;\n    var tagDescription_i = row.TagDescription;\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Row = \" + className_i + \"-\" + usageScenario_i + \"-\" + parameterName_i + \".\";\n    \n    // Get a list of all elements matching the current ClassName\n    var tempClassNamesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === className_i);\n            }\n        });\n    \n    // Debug Messages\n    //msg.log = msg.log + \"\\n\" + \"Number of Elements = \" + tempClassNamesArray.length;\n    \n    // Test if the ClassName exists yet or not.\n    if (tempClassNamesArray.length > 0) {\n        // Already found this ClassName in the returnDataSet\n        // Cache a reference to the first element for the current ClassName\n        var tempClassName = tempClassNamesArray[0];\n        \n        // Get a list of all elements matching the current ClassName\n        var tempUsageScenariosArray = tempClassName.UsageScenarios.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.UsageScenarioName === usageScenario_i);\n                }\n            });\n        \n         // Test if the UsageScenario exists yet or not.\n        if (tempUsageScenariosArray.length > 0) {\n            // Already found this UsageScenario in the returnDataSet\n            // Cache a reference to the first element for the current UsageScenario\n            var tempUsageScenario = tempUsageScenariosArray[0];\n            \n            // Get a list of all elements matching the current ParameterName\n            var tempParametersArray = tempUsageScenario.Parameters.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.ParameterName === parameterName_i);\n                    }\n                });\n            \n             // Test if the ParameterName exists yet or not.\n            if (tempParametersArray.length > 0) {\n                // Already found this ParameterName in the returnDataSet\n                // Debug messages\n                msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot add \" +\n                    parameterName_i + \" to the class definition because it already exists.\";\n            }\n            else {\n                // Cannot find this UsageScenario in the returnDataSet\n                // Add a new object to the return set\n                tempUsageScenario.Parameters.push({\n                        \"ParameterName\":parameterName_i,\n                        \"DataType\":dataType_i,\n                        \"ParameterMappingAction\":parameterMappingAction_i,\n                        \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                        \"CreateTag\":createTag_i,\n                        \"TagName\":tagName_i,\n                        \"TagDescription\":tagDescription_i\n                    });\n            }\n        }\n        else {\n            // Cannot find this UsageScenario in the returnDataSet\n            // Add a new object to the return set\n            tempClassName.UsageScenarios.push({\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Parameters\":[{\n                        \"ParameterName\":parameterName_i,\n                        \"DataType\":dataType_i,\n                        \"ParameterMappingAction\":parameterMappingAction_i,\n                        \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                        \"CreateTag\":createTag_i,\n                        \"TagName\":tagName_i,\n                        \"TagDescription\":tagDescription_i\n                    }]\n                });\n        }\n    }\n    else {\n        // Cannot find this ClassName in the returnDataSet\n        // Add a new object to the return set\n        returnDataSet.push({\n                \"ClassName\":className_i,\n                \"UsageScenarios\":[{\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Parameters\":[{\n                        \"ParameterName\":parameterName_i,\n                        \"DataType\":dataType_i,\n                        \"ParameterMappingAction\":parameterMappingAction_i,\n                        \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                        \"CreateTag\":createTag_i,\n                        \"TagName\":tagName_i,\n                        \"TagDescription\":tagDescription_i\n                    }]\n                }]\n            });\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload.CDef_UsageScenarios_Pivoted = returnDataSet;\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1218,
    "y": 76.25,
    "wires": [
      [
        "dbbc3fdd.c55b48",
        "638d54b0.2ac52c",
        "ccb2c0dc.cbd788"
      ]
    ]
  },
  {
    "id": "dbbc3fdd.c55b48",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1187.7655944824219,
    "y": 148,
    "wires": []
  },
  {
    "id": "638d54b0.2ac52c",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1227.7655944824219,
    "y": 111,
    "wires": []
  },
  {
    "id": "999ca32a.59058",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1224.765625,
    "y": 338,
    "wires": []
  },
  {
    "id": "cc005947.5d39c8",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1184.765625,
    "y": 375,
    "wires": []
  },
  {
    "id": "8501fde4.ad51d",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Incoming Trigger",
    "info": "",
    "x": 211,
    "y": 41,
    "wires": []
  },
  {
    "id": "ccb2c0dc.cbd788",
    "type": "join",
    "z": "9f396a53.0d3728",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "3",
    "x": 1504,
    "y": 187,
    "wires": [
      [
        "6e2edf8d.11749"
      ]
    ]
  },
  {
    "id": "325006f8.546e62",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Pull the Dataset Files",
    "info": "",
    "x": 423,
    "y": 40,
    "wires": []
  },
  {
    "id": "f5e76b76.e057f8",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Pivot the Datasets",
    "info": "",
    "x": 1188,
    "y": 42,
    "wires": []
  },
  {
    "id": "3e700e4e.eb1502",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Convert Data CDef_UsageScenarios",
    "func": "// Debug Messages\nmsg.log = \"Starting Convert Data Class Def Usage Scenarios...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"None\";\n}\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_UsageScenarios.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_UsageScenarios[i];\n    \n    // Modify the current row's data.  Convert incoming raw data to native data types.\n    row.ValidateAgainstIOList = parseBoolean(row.ValidateAgainstIOList);\n    row.CreateTag = parseBoolean(row.CreateTag);\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 769,
    "y": 77,
    "wires": [
      [
        "1f7b5c2d.38fcac",
        "8e65b655.fd857",
        "df1d2368.abeea"
      ]
    ]
  },
  {
    "id": "3007f99.6ae2586",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Convert Raw Data into Native Types",
    "info": "",
    "x": 758,
    "y": 41,
    "wires": []
  },
  {
    "id": "8e65b655.fd857",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 749,
    "y": 112,
    "wires": []
  },
  {
    "id": "df1d2368.abeea",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 711,
    "y": 148,
    "wires": []
  },
  {
    "id": "1acee4d9.67308b",
    "type": "function",
    "z": "f41b39ff.87e2e",
    "name": "Filter Program Structure",
    "func": "// Debug messages\nmsg.log = \"Start of 'Filter Program Structure'\";\n\n// Declare varialbes and retrieve options\nvar controllerFilter = msg.payload.UiOptions.ControllerFilter.trim();\nvar taskFilter = msg.payload.UiOptions.TaskFilter.trim();\nvar programFilter = msg.payload.UiOptions.ProgramFilter.trim();\nvar routineFilter = msg.payload.UiOptions.RoutineFilter.trim();\n//var classNameFilter = msg.payload.UiOptions.ClassNameFilter.trim();\n//var moduleTagNameFilter = msg.payload.UiOptions.ModuleTagNameFilter.trim();\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"controllerFilter = '\" + controllerFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"taskFilter = '\" + taskFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"programFilter = '\" + programFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"routineFilter = '\" + routineFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"classNameFilter = '\" + classNameFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"moduleTagNameFilter = '\" + moduleTagNameFilter + \"'.\";\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"Tasks\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"Task = '\" + row.Task + \"'\";\n        \n        // Test if the controller filter option is enabled and the \n        if (keepRow && (controllerFilter.length > 0) && \n                (row.Controller.toLowerCase().indexOf(controllerFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of controllerFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the task filter option is enabled and the row's value doesn't match\n        if (keepRow && (taskFilter.length > 0) && \n                (row.Task.toLowerCase().indexOf(taskFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of taskFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"Programs\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"Task = '\" + row.Task + \"'\";\n        \n        // Test if the controller filter option is enabled and the \n        if (keepRow && (controllerFilter.length > 0) && \n                (row.Controller.toLowerCase().indexOf(controllerFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of controllerFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the task filter option is enabled and the row's value doesn't match\n        if (keepRow && (taskFilter.length > 0) && \n                (row.Task.toLowerCase().indexOf(taskFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of taskFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the program filter option is enabled and the row's value doesn't match\n        if (keepRow && (programFilter.length > 0) && \n                (row.Program.toLowerCase().indexOf(programFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of programFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"Routines\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"Task = '\" + row.Task + \"'\";\n        \n        // Test if the controller filter option is enabled and the \n        if (keepRow && (controllerFilter.length > 0) && \n                (row.Controller.toLowerCase().indexOf(controllerFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of controllerFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the task filter option is enabled and the row's value doesn't match\n        if (keepRow && (taskFilter.length > 0) && \n                (row.Task.toLowerCase().indexOf(taskFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of taskFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the program filter option is enabled and the row's value doesn't match\n        if (keepRow && (programFilter.length > 0) && \n                (row.Program.toLowerCase().indexOf(programFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of programFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the routine filter option is enabled and the row's value doesn't match\n        if (keepRow && (routineFilter.length > 0) && \n                (row.Routine.toLowerCase().indexOf(routineFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of routineFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Always strip off the UiOptions object\nmsg.log = msg.log + \"\\n\" + \"Deleting UiOptions from return set.\";\ndelete msg.payload[\"UiOptions\"];\n\n// Return result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\"\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 213,
    "y": 57,
    "wires": [
      []
    ]
  },
  {
    "id": "94df7d61.f00908",
    "type": "function",
    "z": "f41b39ff.87e2e",
    "name": "Filter Class Defs",
    "func": "// Debug messages\nmsg.log = \"Start of 'Filter Class Defs'\";\n\n// Declare varialbes and retrieve options\n//var controllerFilter = msg.payload.UiOptions.ControllerFilter.trim();\n//var taskFilter = msg.payload.UiOptions.TaskFilter.trim();\n//var programFilter = msg.payload.UiOptions.ProgramFilter.trim();\n//var routineFilter = msg.payload.UiOptions.RoutineFilter.trim();\nvar classNameFilter = msg.payload.UiOptions.ClassNameFilter.trim();\n//var moduleTagNameFilter = msg.payload.UiOptions.ModuleTagNameFilter.trim();\n\n// Debug messages\n//.log = msg.log + \"\\n\" + \"controllerFilter = '\" + controllerFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"taskFilter = '\" + taskFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"programFilter = '\" + programFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"routineFilter = '\" + routineFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"classNameFilter = '\" + classNameFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"moduleTagNameFilter = '\" + moduleTagNameFilter + \"'.\";\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"CDef_UsageScenarios\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"ClassName = '\" + row.ClassName + \"'\";\n        \n        // Test if the class name filter option is enabled and the row's value doesn't match\n        if (keepRow && (classNameFilter.length > 0) && \n                (row.ClassName.toLowerCase().indexOf(classNameFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of classNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"CDef_Parameters\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"ClassName = '\" + row.ClassName + \"'\";\n        \n        // Test if the class name filter option is enabled and the row's value doesn't match\n        if (keepRow && (classNameFilter.length > 0) && \n                (row.ClassName.toLowerCase().indexOf(classNameFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of classNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"CDef_CodeSnippets\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"ClassName = '\" + row.ClassName + \"'\";\n        \n        // Test if the class name filter option is enabled and the row's value doesn't match\n        // *** Special Case:  Ignore CDef_Global\n        if (keepRow && (classNameFilter.length > 0) && \n                (row.ClassName.toLowerCase().indexOf(classNameFilter.toLowerCase()) < 0) &&\n                (row.ClassName.toLowerCase() != \"cdef_global\")) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of classNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Always strip off the UiOptions object\nmsg.log = msg.log + \"\\n\" + \"Deleting UiOptions from return set.\";\ndelete msg.payload[\"UiOptions\"];\n\n// Return result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\"\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 191,
    "y": 101,
    "wires": [
      []
    ]
  },
  {
    "id": "5e8c69ae.5b8a78",
    "type": "function",
    "z": "f41b39ff.87e2e",
    "name": "Filter Module List",
    "func": "// Debug messages\nmsg.log = \"Start of 'Filter Module List'\";\n\n// Declare varialbes and retrieve options\nvar controllerFilter = msg.payload.UiOptions.ControllerFilter.trim();\nvar taskFilter = msg.payload.UiOptions.TaskFilter.trim();\nvar programFilter = msg.payload.UiOptions.ProgramFilter.trim();\nvar routineFilter = msg.payload.UiOptions.RoutineFilter.trim();\nvar classNameFilter = msg.payload.UiOptions.ClassNameFilter.trim();\nvar moduleTagNameFilter = msg.payload.UiOptions.ModuleTagNameFilter.trim();\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"controllerFilter = '\" + controllerFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"taskFilter = '\" + taskFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"programFilter = '\" + programFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"routineFilter = '\" + routineFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"classNameFilter = '\" + classNameFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"moduleTagNameFilter = '\" + moduleTagNameFilter + \"'.\";\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"Modules\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"ModuleTagName = '\" + row.ModuleTagName + \"'\";\n        \n        // Test if the controller filter option is enabled and the \n        if (keepRow && (controllerFilter.length > 0) && \n                (row.Controller.toLowerCase().indexOf(controllerFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of controllerFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the task filter option is enabled and the row's value doesn't match\n        if (keepRow && (taskFilter.length > 0) && \n                (row.Task.toLowerCase().indexOf(taskFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of taskFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the program filter option is enabled and the row's value doesn't match\n        if (keepRow && (programFilter.length > 0) && \n                (row.Program.toLowerCase().indexOf(programFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of programFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the routine filter option is enabled and the row's value doesn't match\n        if (keepRow && (routineFilter.length > 0) && \n                (row.Routine.toLowerCase().indexOf(routineFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of routineFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the class name filter option is enabled and the row's value doesn't match\n        if (keepRow && (classNameFilter.length > 0) && \n                (row.ClassName.toLowerCase().indexOf(classNameFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of classNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // Test if the tag name filter option is enabled and the row's value doesn't match\n        if (keepRow && (moduleTagNameFilter.length > 0) && \n                (row.ModuleTagName.toLowerCase().indexOf(moduleTagNameFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of moduleTagNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Always strip off the UiOptions object\nmsg.log = msg.log + \"\\n\" + \"Deleting UiOptions from return set.\";\ndelete msg.payload[\"UiOptions\"];\n\n// Return result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\"\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 190,
    "y": 144,
    "wires": [
      []
    ]
  },
  {
    "id": "979d7ccf.14dc78",
    "type": "function",
    "z": "f41b39ff.87e2e",
    "name": "Filter Module Data",
    "func": "// Debug messages\nmsg.log = \"Start of 'Filter Module Data'\";\n\n// Declare varialbes and retrieve options\n//var controllerFilter = msg.payload.UiOptions.ControllerFilter.trim();\n//var taskFilter = msg.payload.UiOptions.TaskFilter.trim();\n//var programFilter = msg.payload.UiOptions.ProgramFilter.trim();\n//var routineFilter = msg.payload.UiOptions.RoutineFilter.trim();\nvar classNameFilter = msg.payload.UiOptions.ClassNameFilter.trim();\nvar moduleTagNameFilter = msg.payload.UiOptions.ModuleTagNameFilter.trim();\n\n// Debug messages\n//msg.log = msg.log + \"\\n\" + \"controllerFilter = '\" + controllerFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"taskFilter = '\" + taskFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"programFilter = '\" + programFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"routineFilter = '\" + routineFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"classNameFilter = '\" + classNameFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"moduleTagNameFilter = '\" + moduleTagNameFilter + \"'.\";\n\n// Test if the incoming class name filter option is enabled\nif (classNameFilter.length > 0){\n    // Debug messages\n    msg.log = msg.log + \"\\n\" + \"Applying class name filter.\";\n    // Apply Class Name Filter\n    // Iterate the object/table names\n    for(var tableName in msg.payload){\n        // Test if the current table name fully or partially matches the filter (case-insensitive)\n        if(tableName.toLowerCase().indexOf(classNameFilter.toLowerCase()) < 0) {\n            // Table name doesn't contain the filter string --> Delete the table\n            msg.log = msg.log + \"\\n\" + \"*** Deleting \" + tableName + \" from return set. ***\";\n            delete msg.payload[tableName];\n        }\n        else {\n            // Table name matches filter\n            // TODO:  apply row filtering to this table (tag name).\n        }\n    }\n}\n\n// Always strip off the UiOptions object\nmsg.log = msg.log + \"\\n\" + \"Deleting UiOptions from return set.\";\ndelete msg.payload[\"UiOptions\"];\n\n// Return result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\"\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 190,
    "y": 187,
    "wires": [
      []
    ]
  },
  {
    "id": "4e248bb0.66b8c4",
    "type": "function",
    "z": "f41b39ff.87e2e",
    "name": "Filter ILocks & Perms Data",
    "func": "// Debug messages\nmsg.log = \"Start of 'Filter Interlocks & Permissives Data'\";\n\n// Declare varialbes and retrieve options\n//var controllerFilter = msg.payload.UiOptions.ControllerFilter.trim();\n//var taskFilter = msg.payload.UiOptions.TaskFilter.trim();\n//var programFilter = msg.payload.UiOptions.ProgramFilter.trim();\n//var routineFilter = msg.payload.UiOptions.RoutineFilter.trim();\n//var classNameFilter = msg.payload.UiOptions.ClassNameFilter.trim();\nvar moduleTagNameFilter = msg.payload.UiOptions.ModuleTagNameFilter.trim();\n\n// Debug messages\n//msg.log = msg.log + \"\\n\" + \"controllerFilter = '\" + controllerFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"taskFilter = '\" + taskFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"programFilter = '\" + programFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"routineFilter = '\" + routineFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"classNameFilter = '\" + classNameFilter + \"'.\";\nmsg.log = msg.log + \"\\n\" + \"moduleTagNameFilter = '\" + moduleTagNameFilter + \"'.\";\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"Interlocks\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"ModuleTagName = '\" + row.ModuleTagName + \"'\";\n        \n        // Test if the tag name filter option is enabled and the row's value doesn't match\n        if (keepRow && (moduleTagNameFilter.length > 0) && \n                (row.ModuleTagName.toLowerCase().indexOf(moduleTagNameFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of moduleTagNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"Permissives\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"ModuleTagName = '\" + row.ModuleTagName + \"'\";\n        \n        // Test if the tag name filter option is enabled and the row's value doesn't match\n        if (keepRow && (moduleTagNameFilter.length > 0) && \n                (row.ModuleTagName.toLowerCase().indexOf(moduleTagNameFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of moduleTagNameFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Always strip off the UiOptions object\nmsg.log = msg.log + \"\\n\" + \"Deleting UiOptions from return set.\";\ndelete msg.payload[\"UiOptions\"];\n\n// Return result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\"\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 215,
    "y": 231,
    "wires": [
      []
    ]
  },
  {
    "id": "6efc51ed.d65d7",
    "type": "function",
    "z": "f41b39ff.87e2e",
    "name": "Filter IO List",
    "func": "// Debug messages\nmsg.log = \"Start of 'Filter IO List'\";\n\n// Declare varialbes and retrieve options\nvar controllerFilter = msg.payload.UiOptions.ControllerFilter.trim();\n//var taskFilter = msg.payload.UiOptions.TaskFilter.trim();\n//var programFilter = msg.payload.UiOptions.ProgramFilter.trim();\n//var routineFilter = msg.payload.UiOptions.RoutineFilter.trim();\n//var classNameFilter = msg.payload.UiOptions.ClassNameFilter.trim();\n//var moduleTagNameFilter = msg.payload.UiOptions.ModuleTagNameFilter.trim();\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"controllerFilter = '\" + controllerFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"taskFilter = '\" + taskFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"programFilter = '\" + programFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"routineFilter = '\" + routineFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"classNameFilter = '\" + classNameFilter + \"'.\";\n//msg.log = msg.log + \"\\n\" + \"moduleTagNameFilter = '\" + moduleTagNameFilter + \"'.\";\n\n// Iterate the rows and only keep the ones that match all of the enabled filters.\nvar tableName = \"IOList\";\nmsg.payload[tableName] = msg.payload[tableName] \n    .reduce((result, row, i)=>{\n        // Default to mark this row as needing to be retained\n        var keepRow = true;\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"Controller = '\" + row.Controller + \"'\" + \n            \" \" + \"Rack = '\" + row.Rack + \"'\" + \n            \" \" + \"Slot = '\" + row.Slot + \"'\" + \n            \" \" + \"Channel = '\" + row.Channel + \"'\" + \n            \" \" + \"IOType = '\" + row.IOType + \"'\";\n        \n        // Test if the controller filter option is enabled and the \n        if (keepRow && (controllerFilter.length > 0) && \n                (row.Controller.toLowerCase().indexOf(controllerFilter.toLowerCase()) < 0)) {\n            // Debug messages\n            msg.log = msg.log + \"\\n\" + \"*** Deleting row because of controllerFilter. ***\";\n            keepRow = keepRow && false;\n        }\n        \n        // If the row passed all the filters, keep it.\n        if(keepRow){\n            result.push(row);\n        }\n        \n        return result;\n    }, []);\n\n// Always strip off the UiOptions object\nmsg.log = msg.log + \"\\n\" + \"Deleting UiOptions from return set.\";\ndelete msg.payload[\"UiOptions\"];\n\n// Return result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\"\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 172,
    "y": 271,
    "wires": [
      []
    ]
  },
  {
    "id": "ad7fec38.3daba8",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Convert Data CDef_CodeSnippets",
    "func": "// Debug Messages\nmsg.log = \"Starting Convert Data Class Def Code Snippets...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n//Iterate the rows in the CDef_CodeSnippets data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_CodeSnippets.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_CodeSnippets[i];\n    \n    // Modify the current row's data.  Convert incoming raw data to native data types.\n    // Nothing to do.  Placeholder for future work.\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 761,
    "y": 188,
    "wires": [
      [
        "a45726fd.99d428",
        "e3d34525.6d51f",
        "97ea6a53.e9f258"
      ]
    ]
  },
  {
    "id": "a45726fd.99d428",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 751,
    "y": 223,
    "wires": []
  },
  {
    "id": "e3d34525.6d51f",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 713,
    "y": 259,
    "wires": []
  },
  {
    "id": "8d6f253c.816528",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Convert Data CDef_Parameters",
    "func": "// Debug Messages\nmsg.log = \"Starting Convert Data Class Def Parameters...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n//Iterate the rows in the CDef_Parameters data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_Parameters.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_Parameters[i];\n    \n    // Modify the current row's data.  Convert incoming raw data to native data types.\n    row.IsConfig = parseBoolean(row.IsConfig);\n    row.IsBasicConfig = parseBoolean(row.IsBasicConfig);\n    row.IsOperatorEditable = parseBoolean(row.IsOperatorEditable);\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 752,
    "y": 301,
    "wires": [
      [
        "37832395.6fa24c",
        "8eff6367.b84428",
        "ea81c72c.ce298"
      ]
    ]
  },
  {
    "id": "37832395.6fa24c",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 752,
    "y": 336,
    "wires": []
  },
  {
    "id": "8eff6367.b84428",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 714,
    "y": 372,
    "wires": []
  },
  {
    "id": "d64dd7e7.22dfa8",
    "type": "join",
    "z": "9f396a53.0d3728",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "4",
    "x": 992,
    "y": 621,
    "wires": [
      [
        "6e2edf8d.11749"
      ]
    ]
  },
  {
    "id": "4284640e.7d9a1c",
    "type": "join",
    "z": "9f396a53.0d3728",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 1454,
    "y": 793,
    "wires": [
      [
        "6e2edf8d.11749"
      ]
    ]
  },
  {
    "id": "6e2edf8d.11749",
    "type": "join",
    "z": "9f396a53.0d3728",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "3",
    "x": 1779,
    "y": 500,
    "wires": [
      [
        "6bc6b1d0.1c272"
      ]
    ]
  },
  {
    "id": "41ea9d39.3cb6cc",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Join Groups of Return Datasets",
    "info": "",
    "x": 1576,
    "y": 44,
    "wires": []
  },
  {
    "id": "fbb8532d.02d6d8",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Join All Return Datasets",
    "info": "",
    "x": 1884,
    "y": 43,
    "wires": []
  },
  {
    "id": "15c1540d.e1abd4",
    "type": "link out",
    "z": "9f396a53.0d3728",
    "name": "Publish All Datasets",
    "links": [
      "3ded7eea.0afad2",
      "417a0260.386efc"
    ],
    "x": 2262,
    "y": 500,
    "wires": []
  },
  {
    "id": "6bc6b1d0.1c272",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Get Usage Scenarios",
    "func": "// Debug Messages\nmsg.log = \"Starting Get Usage Scenarios...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// This function's purpose is to iterate the module tag names in the modules list\n// For each tag:\n//  1) Cache data needed for later\n//      a) Module tag name\n//      b) Module's class name\n//  2) Pull the tag's module data table row\n//      a) Log a validation error if the table doesn't exist\n//      b) Log a validation error if the tag doesn't exist in the table or exists too many times\n//      c) Cache a reference to the tag's module data row.\n//  3) Pull the class definition from CDef_UsageScenarios_Pivoted\n//      a) Log a validation error class def doesn't exist\n//  4) Iterate the usage scenarios in the class definition.   Note: set UsageScenarioFound = false.\n//  5) For each usage scenario, iterate the parameter names.  Note: set AllParametersMatch = true\n//  6) For each parameter in the usage scenario,\n//      a) Cache off if the parameter was supposed to be configured or not (ParameterMappingAction).\n//      b) Pull the data from tag's module data row for column matching the parameter name.  Note: trim whitespace during the pull.\n//      c) ParameterMatches = ((TagParamConfig.length > 0) == ParameterMappingAction)\n//      d) AllParametersMatch = AllParametersMatch && ParameterMatches\n//  7) If AllParametersMatch = true, set UsageScenarioFound = true & quit iterating the usage scenarios.\n//  8) Check if a usage scenario was found or not\n//      a) If UsageScenarioFound = true, append the usage scenario to the modules list data.\n//      b)If UsageScenarioFound = false, log a validation error.\n\n/*{\n    \"ClassName\":className_i,\n    \"UsageScenarios\":[{\n        \"UsageScenarioName\":usageScenario_i,\n        \"Parameters\":[{\n            \"ParameterName\":parameterName_i,\n            \"DataType\":dataType_i,\n            \"ParameterMappingAction\":parameterMappingAction_i,\n            \"ValidateAgainstIOList\":validateAgainstIOList_i\n        }]\n    }]\n}*/\n\n// Cache a reference to the relevant data sets that need to be used\nvar cDef_UsageScenarios = msg.payload[\"CDef_UsageScenarios_Pivoted\"];\nvar modulesList = msg.payload[\"Modules\"];\n\n// Iterate the tags in the Modules list dataset\nfor (var i = 0; i < modulesList.length; i++){\n    // Cache a reference to the current module's list data\n    var module_i = modulesList[i];\n    \n    // Cache off the common paramaters from the current module\n    var controller_i = module_i.Controller;\n    var moduleTagName_i = module_i.ModuleTagName;\n    var moduleClassName_i = module_i.ClassName;\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Controller = \" + controller_i + \".\";\n    msg.log = msg.log + \"\\n\" + \"Module Tag Name = \" + moduleTagName_i + \".\";\n    msg.log = msg.log + \"\\n\" + \"Class Name = \" + moduleClassName_i + \".\";\n    \n    // Attempt to pull the data table for the class\n    var moduleDataTable = msg.payload[moduleClassName_i];\n    \n    // Test if the module's data table exists\n    // If it does, filter it for the current module tag name\n    // If it doesn't, log a validation error\n    if ((moduleDataTable === null) || (moduleDataTable === undefined)){\n        // Log a validation error\n        msg.validationErrors = msg.validationErrors + \"\\n\" + moduleTagName_i + \"'s class (\" + \n            moduleClassName_i + \") doesn't have a corresponding data table.\";\n    }\n    else {\n        // Data table exists.  Attempt to filter it down to just the current tag.\n        var tempModuleDataArray = moduleDataTable.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controller_i) &&\n                        (element.ModuleTagName === moduleTagName_i));\n                }\n            });\n        \n        // Check how many times the tag shows up in the data table\n        if (tempModuleDataArray.length == 0){\n            // Tag doesn't exist.  Log a validation error\n            msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \n                \" doesn't have a row in its class's data table.\";\n        }\n        else if(tempModuleDataArray.length > 1) {\n            // Tag exists more than once.  Log a validation error\n            msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \n                \" has more than one row in its class's data table (row count = \" + tempModuleDataArray.length + \").\";\n        }\n        else {\n            // Tag exists once and only once in the data table.\n            //  Cache a reference to the current module's data table row\n            var moduleData_i = tempModuleDataArray[0];\n            \n            // Pull the first match for this module's class from CDef_UsageScenarios_Pivoted\n            var cDef_UsageScenarios_i = cDef_UsageScenarios.find((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.ClassName === moduleClassName_i);\n                    }\n                });\n            \n            // Check if a usage scenario exists for the current class name\n            var firstMatch_UsageScenarioName = null;\n            if ((cDef_UsageScenarios_i === null) || (cDef_UsageScenarios_i === undefined)){\n                // Log a validation error\n                msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \"'s class (\" + \n                    moduleClassName_i + \") doesn't have a corresponding Class Definition Usage Scenario dataset.\";\n            }\n            else {\n                // The current tag has all of the datasets required.\n                // Default the number of usage scenario matches\n                var UsageScenarioMatchCount = 0;\n                \n                // Iterate the usage scenarios for this module's class\n                for (var j = 0; j < cDef_UsageScenarios_i.UsageScenarios.length; j++){\n                    // Cache a reference to the current usage scenario to check\n                    var usageScenario_i = cDef_UsageScenarios_i.UsageScenarios[j];\n                    \n                    msg.log = msg.log + \"\\n\" + \"Usage Scenario Name = \" + usageScenario_i.UsageScenarioName + \".\";\n                    \n                    // Default the flag for all parameters match to true;\n                    // If any parameter doesn't match, it will be reset to false.\n                    var AllParametersMatch = true\n                    \n                    // Iterate the parameters in the current usage scenario\n                    for (var k = 0; k < usageScenario_i.Parameters.length; k++){\n                        // Cache a reference to the current usage scenario to check\n                        var parameter_i = usageScenario_i.Parameters[k];\n                        \n                        // Pull the commonly used data points\n                        var parameterMappingAction_i = parameter_i.ParameterMappingAction;\n                        \n                        // Debug Messages\n                        msg.log = msg.log + \"\\n\" + \"Parameter Name = \" + parameter_i.ParameterName + \".\";\n                        msg.log = msg.log + \"\\n\" + \"Parameter Mapping Action = \" + parameterMappingAction_i + \".\";\n                        \n                        // Test if the parameter mapping action is invalid\n                        // Note:  null is okay and will be interpreted as 'Ignore' in this code\n                        if (parameterMappingAction_i === undefined) {\n                            msg.validationErrors = msg.validationErrors + \"\\n\" + moduleClassName_i + \"'s parameter (\" + \n                                parameter_i.ParameterName + \") doesn't have a parameter mapping action (\" + \n                                parameterMappingAction_i + \").\";\n                        }\n                        \n                        // Pull the configuration from the module data table for the current parameter\n                        moduleParamConfig = moduleData_i[parameter_i.ParameterName];\n                        if ((moduleParamConfig === null) || (moduleParamConfig === undefined)) {\n                            // Blank cells in the data table show up as null or undefined depending on the \n                            //  implementation of the Excel to JSON data parsing routine.\n                            // TODO: Possibly implement cross-check of a default values row or somethign else to see if this column exists?\n                            // Convert them to empty strings\n                            moduleParamConfig = \"\";\n                        } \n                        \n                        // Debug messages\n                        msg.log = msg.log + \"\\n\" + \"Parameter Value = \" + moduleParamConfig + \".\";\n                        \n                        // Test if the module's parameter exists\n                        // If it does, perform the comparison to the class definition\n                        // If it doesn't, log a validation error & mark it as a mismatch\n                        if ((moduleParamConfig === undefined) && ((parameterMappingAction_i === \"Blank\") || (parameterMappingAction_i === \"Non-Blank\"))){\n                            // The module's parameter doesn't exist and it should exist\n                            // Log a validation error\n                            msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \"'s data table (\" + \n                                moduleClassName_i + \") doesn't have a required class definition column (\" + \n                                parameter_i.ParameterName + \").\";\n                            \n                            // Mark this as a mismatch\n                            ParameterMatches = false;\n                        }\n                        else {\n                            // One of two case will exist\n                            // 1) The module's parameter does exist and should be validated\n                            // 2) The module's parameter doesn't exist, but the mapping action is set to ignore the parameter\n                            \n                            // Check the module's parameter config against the class definition\n                            switch(parameterMappingAction_i) {\n                                case \"Non-Blank\":\n                                    // Requires the module's parameter config to NOT be blank\n                                    ParameterMatches = (moduleParamConfig.length !== 0);\n                                    \n                                    // Debug Messages\n                                    msg.log = msg.log + \"\\n\" + \"Testing if Non-Blank.  Parameter Value Length = \" + moduleParamConfig.length + \".  ParameterMatches = \" + ParameterMatches + \".\";\n                                    break;\n                                    \n                                case \"Blank\":\n                                    // Requires the module's parameter config to be blank\n                                    ParameterMatches = (moduleParamConfig.length === 0);\n                                    \n                                    // Debug Messages\n                                    msg.log = msg.log + \"\\n\" + \"Testing if Blank.  Parameter Value Length = \" + moduleParamConfig.length + \".  ParameterMatches = \" + ParameterMatches + \".\";\n                                    break;\n                                    \n                                case null:\n                                case undefined:\n                                case \"Ignore\":\n                                    // Ignore this parameter\n                                    ParameterMatches = true;\n                                    break;\n                                    \n                                default:\n                                    // Requires the module's parameter config to match the parameter mapping action (value match)\n                                    ParameterMatches = (moduleParamConfig == parameterMappingAction_i);\n                                    \n                                    // Debug Messages\n                                    msg.log = msg.log + \"\\n\" + \"Testing if Value Matches '\" + parameterMappingAction_i + \"'.  Parameter Value = '\" + moduleParamConfig + \"'.  ParameterMatches = \" + ParameterMatches + \".\";\n                                    break;\n                            }\n                            \n                            \n                            //TODO: Add validation against IO List\n                        }\n                        \n                        // Combine the current match with the aggregated match for the usage scenarion\n                        AllParametersMatch = AllParametersMatch && ParameterMatches;\n                        \n                        // Quit searching this usage scenario if anything mismatches\n                        if (!AllParametersMatch){\n                            // Debug Messages\n                            msg.log = msg.log + \"\\n\" + \"Found a mismatch.  Quitting searching on this scenario.\";\n                            break;\n                        }\n                    }\n                    \n                    // Test if all parameters match.  If so, increment the match count\n                    if (AllParametersMatch) {\n                        // Capture the current usage scenario name if this is the first match\n                        if (firstMatch_UsageScenarioName === null) {\n                            // Debug Messages\n                            msg.log = msg.log + \"\\n\" + \"Found the first usage scenario match:  \" + usageScenario_i.UsageScenarioName;\n                            firstMatch_UsageScenarioName = usageScenario_i.UsageScenarioName;\n                        }\n                        else {\n                            // Debug Messages\n                            msg.log = msg.log + \"\\n\" + \"Found another usage scenario match:  \" + usageScenario_i.UsageScenarioName;;\n                        }\n                        UsageScenarioMatchCount++;\n                    }\n                }\n                \n                // Test how many usage scenario matches were found\n                if (UsageScenarioMatchCount == 0){\n                    // Log a validation error\n                    msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \" (\" + \n                        moduleClassName_i + \") doesn't have a matching Usage Scenario.\";\n                }\n                else if (UsageScenarioMatchCount > 1){\n                    // Log a validation error\n                    msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s \" + moduleTagName_i + \" (\" + \n                        moduleClassName_i + \") has more than one matching Usage Scenario (match count = \" + UsageScenarioMatchCount + \").\";\n                }\n                else {\n                    // Append the matching Usage Scenario name to the current module list row\n                    module_i.UsageScenario = firstMatch_UsageScenarioName;\n                    \n                    // Append any other useful information to the current module list row\n                    module_i.Description = moduleData_i.Description;\n                }\n            }\n        }\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1990,
    "y": 500,
    "wires": [
      [
        "15c1540d.e1abd4",
        "4b444c6a.fd6d1c",
        "4be807d8.64b8d",
        "2551f020.010c68",
        "35af061d.948552",
        "ff1bb859.dad88"
      ]
    ]
  },
  {
    "id": "4b444c6a.fd6d1c",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 2021,
    "y": 537,
    "wires": []
  },
  {
    "id": "4be807d8.64b8d",
    "type": "debug",
    "z": "9f396a53.0d3728",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1981,
    "y": 574,
    "wires": []
  },
  {
    "id": "9d5fb688.03fbb8",
    "type": "comment",
    "z": "b8aa44e1.6124b",
    "name": "Incoming Trigger",
    "info": "",
    "x": 270,
    "y": 39,
    "wires": []
  },
  {
    "id": "3ded7eea.0afad2",
    "type": "link in",
    "z": "b8aa44e1.6124b",
    "name": "PLC Main: Get All Datasets",
    "links": [
      "15c1540d.e1abd4"
    ],
    "x": 205,
    "y": 75,
    "wires": [
      [
        "3360b563.35eb8a",
        "8d6c40b7.c9c87",
        "69bc3740.e825b",
        "a288b62b.752808",
        "1436542e.e463fc"
      ]
    ]
  },
  {
    "id": "3360b563.35eb8a",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 398,
    "y": 103,
    "wires": []
  },
  {
    "id": "8d6c40b7.c9c87",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 391,
    "y": 142,
    "wires": []
  },
  {
    "id": "2551f020.010c68",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Map Log to Payload",
    "func": "msg.payload = msg.log;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2214,
    "y": 293,
    "wires": [
      [
        "b933a407.9305f8"
      ]
    ]
  },
  {
    "id": "35af061d.948552",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Map Trace Log to Payload",
    "func": "msg.payload = msg.traceLog;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2234,
    "y": 328.5,
    "wires": [
      [
        "28181fd6.74c5a8"
      ]
    ]
  },
  {
    "id": "ff1bb859.dad88",
    "type": "function",
    "z": "9f396a53.0d3728",
    "name": "Map Validation Errors to Payload",
    "func": "msg.payload = msg.validationErrors;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2253,
    "y": 364.0000305175781,
    "wires": [
      [
        "77cccfc1.476118"
      ]
    ]
  },
  {
    "id": "b933a407.9305f8",
    "type": "upload_file",
    "z": "9f396a53.0d3728",
    "filename": "aaDebugLog.txt",
    "name": "",
    "x": 2526,
    "y": 283,
    "wires": [
      []
    ]
  },
  {
    "id": "28181fd6.74c5a8",
    "type": "upload_file",
    "z": "9f396a53.0d3728",
    "filename": "aaTraceLog.txt",
    "name": "",
    "x": 2521,
    "y": 322,
    "wires": [
      []
    ]
  },
  {
    "id": "77cccfc1.476118",
    "type": "upload_file",
    "z": "9f396a53.0d3728",
    "filename": "aaValidationErrors.txt",
    "name": "",
    "x": 2546,
    "y": 360,
    "wires": [
      []
    ]
  },
  {
    "id": "7cbb58cc.5c21b",
    "type": "comment",
    "z": "c95acbde.d1f77",
    "name": "Incoming Trigger",
    "info": "",
    "x": 276,
    "y": 33,
    "wires": []
  },
  {
    "id": "417a0260.386efc",
    "type": "link in",
    "z": "c95acbde.d1f77",
    "name": "HMI Main: Get All Datasets",
    "links": [
      "15c1540d.e1abd4"
    ],
    "x": 211,
    "y": 69,
    "wires": [
      [
        "6f28d6bf.606f9",
        "cf420a3e.d5ec98"
      ]
    ]
  },
  {
    "id": "61371b9b.14720c",
    "type": "inject",
    "z": "c95acbde.d1f77",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 252,
    "y": 113,
    "wires": [
      []
    ]
  },
  {
    "id": "6f28d6bf.606f9",
    "type": "debug",
    "z": "c95acbde.d1f77",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 492,
    "y": 122,
    "wires": []
  },
  {
    "id": "cf420a3e.d5ec98",
    "type": "debug",
    "z": "c95acbde.d1f77",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 485,
    "y": 161,
    "wires": []
  },
  {
    "id": "607e9a33.0d49c4",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Publish to Other Flows",
    "info": "",
    "x": 2269,
    "y": 40,
    "wires": []
  },
  {
    "id": "69bc3740.e825b",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Build Interlocks Code Snippets & Comments",
    "func": "// Debug Messages\nmsg.log = \"Starting Build Interlocks Code Snippets & Comments...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Set up the constants to use later\nconst branchStartString = \"[\";\nconst branchEndString = \"]\";\nconst branchDelimiterString = \",\";\nconst rungEndString = \";\";\n\nconst AllDynamicRefsRegex = \"{((?:This)|(?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t        // Operand CANNOT include { or }\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t\t\t        // Operand CANNOT include { or }\nconst NonCodeDynamicRefsRegex = \"{((?:This))\\\\[([^{}]+?)\\\\]}\";\t\t                    // Operand CANNOT include { or }\nconst CommentDynamicRefsRegex = \"{((?:Comment)|(?:DerivedComment))\\\\[([^{}]+?)\\\\]}\";    // Operand CANNOT include { or }\n\nconst ThisKeyword = \"This\";\nconst CodeKeyword = \"Code\";\nconst DerivedKeyword = \"Derived\";\nconst CommentKeyword = \"Comment\";\nconst DerivedCommentKeyword = \"DerivedComment\";\n\nvar reAll = new RegExp(AllDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n\n/*{\n    \"ModuleCodeSnippets_Interlocks\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Snippets\":[{\n            \"SnippetName\":snippetName_i,\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n// Pull the global options\nvar interlockOptions = msg.payload.InterlockOptions;\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Pulling Global snippets object.\";\n\n// Attempt to pull the global definitions from the CDef_CodeSnippets_Pivoted dataset\nvar global_CodeSnippets = null;\nvar global_CodeSnippetsArray = msg.payload.CDef_CodeSnippets_Pivoted.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return (element.ClassName == \"Global\");\n    }\n});\n\n// Test if the filtered list has anything in it\nif (global_CodeSnippetsArray.length > 0) {\n    // Debug messages\n    msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n    global_CodeSnippets = global_CodeSnippetsArray[0];\n}\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Pulling Interlocks usage scenario & its snippets collection.\";\n\n// Attempt to pull the global interlocks usage scenario\nvar global_Interlocks = null;\nvar global_InterlockSnippets = null;\nif ((global_CodeSnippets !== null) && (global_CodeSnippets !== undefined)) {\n    // Exists.  Attempt to pull the interlocks usage scenario\n    global_InterlocksArray = global_CodeSnippets.UsageScenarios.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.UsageScenarioName === \"Interlocks\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_InterlocksArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_Interlocks = global_InterlocksArray[0];\n        global_InterlockSnippets = global_Interlocks.Snippets;\n    }\n}\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Pulling required snippets.\";\n\n// Attempt to pull the required snippets from the global interlock snippets collection\nvar global_InterlockSnippets_Main = null;\nvar global_InterlockSnippets_Branch = null;\nvar global_InterlockSnippets_BranchDelayed = null;\nvar global_InterlockSnippets_ConditionCodePlaceholder = null;\nif ((global_InterlockSnippets !== null) && (global_InterlockSnippets !== undefined)) {\n    // Main\n    global_InterlockSnippets_ResultsArray = global_InterlockSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"Main\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_InterlockSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_InterlockSnippets_Main = global_InterlockSnippets_ResultsArray[0];\n    }\n    \n    // Branch\n    global_InterlockSnippets_ResultsArray = global_InterlockSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"Branch\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_InterlockSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_InterlockSnippets_Branch = global_InterlockSnippets_ResultsArray[0];\n    }\n    \n    // BranchDelayed\n    global_InterlockSnippets_ResultsArray = global_InterlockSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"BranchDelayed\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_InterlockSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_InterlockSnippets_BranchDelayed = global_InterlockSnippets_ResultsArray[0];\n    }\n    \n    // ConditionCodePlaceholder\n    global_InterlockSnippets_ResultsArray = global_InterlockSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"ConditionCodePlaceholder\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_InterlockSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_InterlockSnippets_ConditionCodePlaceholder = global_InterlockSnippets_ResultsArray[0];\n    }\n}\n\n// Test if the required snippets exist\nif ((global_CodeSnippets === null) || (global_CodeSnippets === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the Global class in the code snippets definition.\";\n}\nelse if ((global_InterlockSnippets === null) || (global_InterlockSnippets === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the Interlocks usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_InterlockSnippets_Main === null) || (global_InterlockSnippets_Main === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'Main' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_InterlockSnippets_Branch === null) || (global_InterlockSnippets_Branch === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'Branch' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_InterlockSnippets_BranchDelayed === null) || (global_InterlockSnippets_BranchDelayed === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'BranchDelayed' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_InterlockSnippets_ConditionCodePlaceholder === null) || (global_InterlockSnippets_ConditionCodePlaceholder === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'ConditionCodePlaceholder' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\";\n}\nelse {\n    // All required global elements have been found\n    //Iterate the modules in the Interlocks_pivoted data set to build the code-comment pair for the interlocks\n    for (var i = 0; i < msg.payload.Interlocks_Pivoted.length; i++){\n        // Cache a reference to the current module\n        var module_i = msg.payload.Interlocks_Pivoted[i];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var moduleTagName_i = module_i.ModuleTagName;\n        \n        // Debug Messages\n        msg.log = msg.log + \"\\n\" + \"Item = \" + controller_i + \"-\" + moduleTagName_i + \".\";\n        \n        // Default the AllConditionsCode value, which will later be referenced by the {Derived[~~]} find & replace code\n        var allConditionsCode_i = \"\";\n        \n        // Iterate the interlocks in the collection\n        for (var j = 0; j < module_i.Interlocks.length; j++){\n            // Cache a reference to the current interlock\n            var interlock_i = module_i.Interlocks[j];\n            \n            // Pull the current interlock's data\n            var index_i = interlock_i.Index;\n            var conditionCode_i = interlock_i.ConditionCode;\n            var description_i = interlock_i.Description;\n            var isDebounced_i = interlock_i.IsDebounced;\n            var debounceTime_i = interlock_i.DebounceTime;\n            var okayState_i = interlock_i.OkayState;\n            var isBypassable_i = interlock_i.IsBypassable;\n            var canNavigate_i = interlock_i.CanNavigate;\n            var associatedTag = interlock_i.AssociatedTag;\n            \n            // Derive the ConditionCode value, which will later be referenced by the {Derived[~~]} find & replace code\n            // If the incoming condition code is null or undefined, use the placeholder snippet\n            if ((conditionCode_i === null) || (conditionCode_i === undefined)) {\n                // Use the placeholder snippet\n                conditionCode_i = global_InterlockSnippets_ConditionCodePlaceholder.Code;\n            }\n            \n            // Derive the Description value, which will later be referenced by the {Derived[~~]} find & replace code\n            // If the incoming descriptionse is null or undefined, use an empty string\n            if ((description_i === null) || (description_i === undefined)) {\n                description_i = \"\";\n            }\n            \n            // Derive the FormattedIndex value, which will later be referenced by the {Derived[~~]} find & replace code\n            var formattedIndex_i = Number(index_i).toLocaleString(undefined, {\"minimumIntegerDigits\": interlockOptions.MinimumIntegerDigits});\n            \n            // Pull the normal or delayed branch code based on the interlock's configuration\n            var branchCode_i = null;\n            if (isDebounced_i) {\n                // Pull the delayed branch code\n                branchCode_i = global_InterlockSnippets_BranchDelayed.Code;\n            }\n            else {\n                // Pull the normal branch code\n                branchCode_i = global_InterlockSnippets_Branch.Code;\n            }\n            \n            // Test if the returned branch code is valid or not\n            // If invalid, replace it with an empty string\n            if ((branchCode_i === null) || (branchCode_i === undefined)) {\n                branchCode_i = \"\";\n            }\n            \n            // Reduce the raw branch code snippet down as much as possible\n            // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n            var doneSearching = false;\n            var iterations = 0;\n            var maxIterations = 5000;\n            reAll.lastIndex = 0;    // Start the regex out at the beginning of the string\n            while (!doneSearching && (iterations < maxIterations)) {\n                // Pull the next match\n                match = reAll.exec(branchCode_i);\n                \n                // Test if there was a match found or not.\n                if ((match === null) || (match === undefined)) {\n                    // Nothing was found.  Quit searching.\n                    doneSearching = true;\n                }\n                else {\n                    // A match was found.\n                    // Pull the match information\n                    var operator = match[1];\n                    var operand = match[2];\n                    \n                    // Perform find & replace based on the operator type\n                    var replaceText = null;\n                    switch(operator) {\n                        case ThisKeyword:\n                            // Do a parameter lookup\n                            // ***This lookup is limited in scope to the module's tag name only.***\n                            switch(operand) {\n                                case \"ModuleTagName\":\n                                    replaceText = moduleTagName_i;\n                                    break;\n                            }\n                            break;\n                            \n                        case CodeKeyword:\n                            // Do a snippet lookup.\n                            // ***This loopup is limited in scope to the global interlocks snippet set.***\n                            // ***Exclude all required snippets from the lookup to prevent circular references.***\n                            var global_InterlockSnippets_Temp = null;\n                            global_InterlockSnippets_ResultsArray = global_InterlockSnippets.filter((element)=>{\n                                if ((element !== null) && (element !== undefined)){\n                                    return ((element.SnippetName === operand) &&\n                                        (element.SnippetName !== \"Main\") &&\n                                        (element.SnippetName !== \"Branch\") &&\n                                        (element.SnippetName !== \"BranchDelayed\") &&\n                                        (element.SnippetName !== \"ConditionCodePlaceholder\"));\n                                }\n                            });\n                            \n                            // Test if the filtered list has anything in it\n                            if (global_InterlockSnippets_ResultsArray.length > 0) {\n                                // Debug messages\n                                msg.log = msg.log + \"\\n\" + \">>>Found Operand<<<\";\n                                global_InterlockSnippets_Temp = global_InterlockSnippets_ResultsArray[0];\n                            }\n                            \n                            // Test if snippet was found\n                            if ((global_InterlockSnippets_Temp !== null) && (global_InterlockSnippets_Temp !== undefined)) {\n                                // Snippet was found.  Use snippet code\n                                replaceText = global_InterlockSnippets_Temp.Code;\n                            }\n                            break;\n                            \n                        case DerivedKeyword:\n                            // Do a lookup of the derived calculations within this routine.\n                            // Valid options:  FormattedIndex, ConditionCode, ConditionDescription\n                            switch(operand) {\n                                case \"Index\":\n                                    replaceText = index_i;\n                                    break;\n                                \n                                case \"FormattedIndex\":\n                                    replaceText = formattedIndex_i;\n                                    break;\n                                    \n                                case \"ConditionCode\":\n                                    replaceText = conditionCode_i;\n                                    break;\n                                    \n                                case \"ConditionDescription\":\n                                    replaceText = conditionCode_i;\n                                    break;\n                            }\n                            break;\n                    }\n                    \n                    // Test if there is a replacement string\n                    if ((replaceText !== null) && (replaceText !== undefined)) {\n                        // Perform the replacement\n                        branchCode_i = branchCode_i.substring(0, match.index) + replaceText + branchCode_i.substring(reAll.lastIndex)\n                        \n                        // Start the RegExp's pointer to start scanning at the beginning of the last match\n                        // This is done in case the replacement also contains matches that need replacing\n                        reAll.lastIndex = match.index;\n                    }\n                }\n                \n                // Increment the iterations count\n                iterations++;\n            }\n            \n            // Append the current branch to the combined set of all branches\n            if (allConditionsCode_i.length <= 0) {\n                // First thing to add\n                allConditionsCode_i = branchCode_i;\n            }\n            else {\n                // All subsequent additions.  Append a delimiter and the \n                allConditionsCode_i = allConditionsCode_i + branchDelimiterString + branchCode_i;\n            }\n        }\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"allConditionsCode_i = \" + allConditionsCode_i;\n        \n        // Pull the Main interlock snippet\n        var mainCode_i = global_InterlockSnippets_Main.Code;\n        var mainComment_i = global_InterlockSnippets_Main.Comment;\n        \n        // Reduce the main interlock code snippet down as much as possible\n        // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n        var doneSearching = false;\n        var iterations = 0;\n        var maxIterations = 5000;\n        reAll.lastIndex = 0;    // Start the regex out at the beginning of the string\n        while (!doneSearching && (iterations < maxIterations)) {\n            // Pull the next match\n            match = reAll.exec(mainCode_i);\n            \n            // Test if there was a match found or not.\n            if ((match === null) || (match === undefined)) {\n                // Nothing was found.  Quit searching.\n                doneSearching = true;\n            }\n            else {\n                // A match was found.\n                // Pull the match information\n                var operator = match[1];\n                var operand = match[2];\n                \n                // Perform find & replace based on the operator type\n                var replaceText = null;\n                switch(operator) {\n                    case ThisKeyword:\n                        // Do a parameter lookup\n                        // ***This lookup is limited in scope to the module's tag name only.***\n                        switch(operand) {\n                            case \"ModuleTagName\":\n                                replaceText = moduleTagName_i;\n                                break;\n                        }\n                        break;\n                        \n                    case CodeKeyword:\n                        // Do a snippet lookup.\n                        // ***This loopup is limited in scope to the global interlocks snippet set.***\n                        // ***Exclude all required snippets from the lookup to prevent circular references.***\n                        var global_InterlockSnippets_Temp = null;\n                        global_InterlockSnippets_ResultsArray = global_InterlockSnippets.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return ((element.SnippetName === operand) &&\n                                    (element.SnippetName !== \"Main\") &&\n                                    (element.SnippetName !== \"Branch\") &&\n                                    (element.SnippetName !== \"BranchDelayed\") &&\n                                    (element.SnippetName !== \"ConditionCodePlaceholder\"));\n                            }\n                        });\n                        \n                        // Test if the filtered list has anything in it\n                        if (global_InterlockSnippets_ResultsArray.length > 0) {\n                            // Debug messages\n                            msg.log = msg.log + \"\\n\" + \">>>Found Operand<<<\";\n                            global_InterlockSnippets_Temp = global_InterlockSnippets_ResultsArray[0];\n                        }\n                        \n                        // Test if snippet was found\n                        if ((global_InterlockSnippets_Temp !== null) && (global_InterlockSnippets_Temp !== undefined)) {\n                            // Snippet was found.  Use snippet code\n                            replaceText = global_InterlockSnippets_Temp.Code;\n                        }\n                        break;\n                        \n                    case DerivedKeyword:\n                        // Do a lookup of the derived calculations within this routine.\n                        // Valid options:  AllConditionsCode\n                        switch(operand) {\n                            case \"AllConditionsCode\":\n                                replaceText = allConditionsCode_i;\n                                break;\n                        }\n                        break;\n                }\n                \n                // Test if there is a replacement string\n                if ((replaceText !== null) && (replaceText !== undefined)) {\n                    // Perform the replacement\n                    mainCode_i = mainCode_i.substring(0, match.index) + replaceText + mainCode_i.substring(reAll.lastIndex)\n                    \n                    // Start the RegExp's pointer to start scanning at the beginning of the last match\n                    // This is done in case the replacement also contains matches that need replacing\n                    reAll.lastIndex = match.index;\n                }\n            }\n            \n            // Increment the iterations count\n            iterations++;\n        }\n        \n        // Push the derived code out to the return dataset\n        returnDataSet.push({\n                \"Controller\":controller_i,\n                \"ModuleTagName\":moduleTagName_i,\n                \"Snippets\":[{\n                    \"SnippetName\":\"AllInterlocksCode\",\n                    \"Code\":mainCode_i,\n                    \"Comment\":mainComment_i\n                }]\n        });\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\"ModuleCodeSnippets_Interlocks\": returnDataSet};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 560,
    "y": 308.25,
    "wires": [
      [
        "da232afd.8cdef8",
        "86d0c203.a27c9",
        "ae41fcd0.fae72"
      ]
    ]
  },
  {
    "id": "a288b62b.752808",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Build Permissives Code Snippets & Comments",
    "func": "// Debug Messages\nmsg.log = \"Starting Build Permissives Code Snippets & Comments...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Set up the constants to use later\nconst branchStartString = \"[\";\nconst branchEndString = \"]\";\nconst branchDelimiterString = \",\";\nconst rungEndString = \";\";\n\nconst AllDynamicRefsRegex = \"{((?:This)|(?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t        // Operand CANNOT include { or }\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t\t\t        // Operand CANNOT include { or }\nconst NonCodeDynamicRefsRegex = \"{((?:This))\\\\[([^{}]+?)\\\\]}\";\t\t                    // Operand CANNOT include { or }\nconst CommentDynamicRefsRegex = \"{((?:Comment)|(?:DerivedComment))\\\\[([^{}]+?)\\\\]}\";    // Operand CANNOT include { or }\n\nconst ThisKeyword = \"This\";\nconst CodeKeyword = \"Code\";\nconst DerivedKeyword = \"Derived\";\nconst CommentKeyword = \"Comment\";\nconst DerivedCommentKeyword = \"DerivedComment\";\n\nvar reAll = new RegExp(AllDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n\n/*{\n    \"ModuleCodeSnippets_Permissives\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Snippets\":[{\n            \"SnippetName\":snippetName_i,\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n// Pull the global options\nvar permissiveOptions = msg.payload.PermissiveOptions;\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Pulling Global snippets object.\";\n\n// Attempt to pull the global definitions from the CDef_CodeSnippets_Pivoted dataset\nvar global_CodeSnippets = null;\nvar global_CodeSnippetsArray = msg.payload.CDef_CodeSnippets_Pivoted.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return (element.ClassName == \"Global\");\n    }\n});\n\n// Test if the filtered list has anything in it\nif (global_CodeSnippetsArray.length > 0) {\n    // Debug messages\n    msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n    global_CodeSnippets = global_CodeSnippetsArray[0];\n}\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Pulling Permissives usage scenario & its snippets collection.\";\n\n// Attempt to pull the global permissives usage scenario\nvar global_Permissives = null;\nvar global_PermissiveSnippets = null;\nif ((global_CodeSnippets !== null) && (global_CodeSnippets !== undefined)) {\n    // Exists.  Attempt to pull the permissives usage scenario\n    global_PermissivesArray = global_CodeSnippets.UsageScenarios.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.UsageScenarioName === \"Permissives\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_PermissivesArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_Permissives = global_PermissivesArray[0];\n        global_PermissiveSnippets = global_Permissives.Snippets;\n    }\n}\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Pulling required snippets.\";\n\n// Attempt to pull the required snippets from the global permissive snippets collection\nvar global_PermissiveSnippets_Main = null;\nvar global_PermissiveSnippets_Branch = null;\nvar global_PermissiveSnippets_BranchDelayed = null;\nvar global_PermissiveSnippets_ConditionCodePlaceholder = null;\nif ((global_PermissiveSnippets !== null) && (global_PermissiveSnippets !== undefined)) {\n    // Main\n    global_PermissiveSnippets_ResultsArray = global_PermissiveSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"Main\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_PermissiveSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_PermissiveSnippets_Main = global_PermissiveSnippets_ResultsArray[0];\n    }\n    \n    // Branch\n    global_PermissiveSnippets_ResultsArray = global_PermissiveSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"Branch\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_PermissiveSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_PermissiveSnippets_Branch = global_PermissiveSnippets_ResultsArray[0];\n    }\n    \n    // BranchDelayed\n    global_PermissiveSnippets_ResultsArray = global_PermissiveSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"BranchDelayed\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_PermissiveSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_PermissiveSnippets_BranchDelayed = global_PermissiveSnippets_ResultsArray[0];\n    }\n    \n    // ConditionCodePlaceholder\n    global_PermissiveSnippets_ResultsArray = global_PermissiveSnippets.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.SnippetName === \"ConditionCodePlaceholder\");\n        }\n    });\n    \n    // Test if the filtered list has anything in it\n    if (global_PermissiveSnippets_ResultsArray.length > 0) {\n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \">>>Found<<<\";\n        global_PermissiveSnippets_ConditionCodePlaceholder = global_PermissiveSnippets_ResultsArray[0];\n    }\n}\n\n// Test if the required snippets exist\nif ((global_CodeSnippets === null) || (global_CodeSnippets === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the Global class in the code snippets definition.\";\n}\nelse if ((global_PermissiveSnippets === null) || (global_PermissiveSnippets === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the Permissives usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_PermissiveSnippets_Main === null) || (global_PermissiveSnippets_Main === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'Main' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_PermissiveSnippets_Branch === null) || (global_PermissiveSnippets_Branch === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'Branch' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_PermissiveSnippets_BranchDelayed === null) || (global_PermissiveSnippets_BranchDelayed === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'BranchDelayed' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\";\n}\nelse if ((global_PermissiveSnippets_ConditionCodePlaceholder === null) || (global_PermissiveSnippets_ConditionCodePlaceholder === undefined)) {\n    // Log a validation error\n    msg.validationErrors = msg.validationErrors + \"\\n\" + \"Cannot find the 'ConditionCodePlaceholder' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\";\n}\nelse {\n    // All required global elements have been found\n    //Iterate the modules in the Permissives_pivoted data set to build the code-comment pair for the permissives\n    for (var i = 0; i < msg.payload.Permissives_Pivoted.length; i++){\n        // Cache a reference to the current module\n        var module_i = msg.payload.Permissives_Pivoted[i];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var moduleTagName_i = module_i.ModuleTagName;\n        \n        // Debug Messages\n        msg.log = msg.log + \"\\n\" + \"Item = \" + controller_i + \"-\" + moduleTagName_i + \".\";\n        \n        // Default the AllConditionsCode value, which will later be referenced by the {Derived[~~]} find & replace code\n        var allConditionsCode_i = \"\";\n        \n        // Iterate the permissives in the collection\n        for (var j = 0; j < module_i.Permissives.length; j++){\n            // Cache a reference to the current permissive\n            var permissive_i = module_i.Permissives[j];\n            \n            // Pull the current permissive's data\n            var index_i = permissive_i.Index;\n            var conditionCode_i = permissive_i.ConditionCode;\n            var description_i = permissive_i.Description;\n            var isDebounced_i = permissive_i.IsDebounced;\n            var debounceTime_i = permissive_i.DebounceTime;\n            var okayState_i = permissive_i.OkayState;\n            var isBypassable_i = permissive_i.IsBypassable;\n            var canNavigate_i = permissive_i.CanNavigate;\n            var associatedTag = permissive_i.AssociatedTag;\n            \n            // Derive the ConditionCode value, which will later be referenced by the {Derived[~~]} find & replace code\n            // If the incoming condition code is null or undefined, use the placeholder snippet\n            if ((conditionCode_i === null) || (conditionCode_i === undefined)) {\n                // Use the placeholder snippet\n                conditionCode_i = global_PermissiveSnippets_ConditionCodePlaceholder.Code;\n            }\n            \n            // Derive the Description value, which will later be referenced by the {Derived[~~]} find & replace code\n            // If the incoming descriptionse is null or undefined, use an empty string\n            if ((description_i === null) || (description_i === undefined)) {\n                description_i = \"\";\n            }\n            \n            // Derive the FormattedIndex value, which will later be referenced by the {Derived[~~]} find & replace code\n            var formattedIndex_i = Number(index_i).toLocaleString(undefined, {\"minimumIntegerDigits\": permissiveOptions.MinimumIntegerDigits});\n            \n            // Pull the normal or delayed branch code based on the permissive's configuration\n            var branchCode_i = null;\n            if (isDebounced_i) {\n                // Pull the delayed branch code\n                branchCode_i = global_PermissiveSnippets_BranchDelayed.Code;\n            }\n            else {\n                // Pull the normal branch code\n                branchCode_i = global_PermissiveSnippets_Branch.Code;\n            }\n            \n            // Test if the returned branch code is valid or not\n            // If invalid, replace it with an empty string\n            if ((branchCode_i === null) || (branchCode_i === undefined)) {\n                branchCode_i = \"\";\n            }\n            \n            // Reduce the raw branch code snippet down as much as possible\n            // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n            var doneSearching = false;\n            var iterations = 0;\n            var maxIterations = 5000;\n            reAll.lastIndex = 0;    // Start the regex out at the beginning of the string\n            while (!doneSearching && (iterations < maxIterations)) {\n                // Pull the next match\n                match = reAll.exec(branchCode_i);\n                \n                // Test if there was a match found or not.\n                if ((match === null) || (match === undefined)) {\n                    // Nothing was found.  Quit searching.\n                    doneSearching = true;\n                }\n                else {\n                    // A match was found.\n                    // Pull the match information\n                    var operator = match[1];\n                    var operand = match[2];\n                    \n                    // Perform find & replace based on the operator type\n                    var replaceText = null;\n                    switch(operator) {\n                        case ThisKeyword:\n                            // Do a parameter lookup\n                            // ***This lookup is limited in scope to the module's tag name only.***\n                            switch(operand) {\n                                case \"ModuleTagName\":\n                                    replaceText = moduleTagName_i;\n                                    break;\n                            }\n                            break;\n                            \n                        case CodeKeyword:\n                            // Do a snippet lookup.\n                            // ***This loopup is limited in scope to the global permissives snippet set.***\n                            // ***Exclude all required snippets from the lookup to prevent circular references.***\n                            var global_PermissiveSnippets_Temp = null;\n                            global_PermissiveSnippets_ResultsArray = global_PermissiveSnippets.filter((element)=>{\n                                if ((element !== null) && (element !== undefined)){\n                                    return ((element.SnippetName === operand) &&\n                                        (element.SnippetName !== \"Main\") &&\n                                        (element.SnippetName !== \"Branch\") &&\n                                        (element.SnippetName !== \"BranchDelayed\") &&\n                                        (element.SnippetName !== \"ConditionCodePlaceholder\"));\n                                }\n                            });\n                            \n                            // Test if the filtered list has anything in it\n                            if (global_PermissiveSnippets_ResultsArray.length > 0) {\n                                // Debug messages\n                                msg.log = msg.log + \"\\n\" + \">>>Found Operand<<<\";\n                                global_PermissiveSnippets_Temp = global_PermissiveSnippets_ResultsArray[0];\n                            }\n                            \n                            // Test if snippet was found\n                            if ((global_PermissiveSnippets_Temp !== null) && (global_PermissiveSnippets_Temp !== undefined)) {\n                                // Snippet was found.  Use snippet code\n                                replaceText = global_PermissiveSnippets_Temp.Code;\n                            }\n                            break;\n                            \n                        case DerivedKeyword:\n                            // Do a lookup of the derived calculations within this routine.\n                            // Valid options:  FormattedIndex, ConditionCode, ConditionDescription\n                            switch(operand) {\n                                case \"Index\":\n                                    replaceText = index_i;\n                                    break;\n                                \n                                case \"FormattedIndex\":\n                                    replaceText = formattedIndex_i;\n                                    break;\n                                    \n                                case \"ConditionCode\":\n                                    replaceText = conditionCode_i;\n                                    break;\n                                    \n                                case \"ConditionDescription\":\n                                    replaceText = conditionCode_i;\n                                    break;\n                            }\n                            break;\n                    }\n                    \n                    // Test if there is a replacement string\n                    if ((replaceText !== null) && (replaceText !== undefined)) {\n                        // Perform the replacement\n                        branchCode_i = branchCode_i.substring(0, match.index) + replaceText + branchCode_i.substring(reAll.lastIndex)\n                        \n                        // Start the RegExp's pointer to start scanning at the beginning of the last match\n                        // This is done in case the replacement also contains matches that need replacing\n                        reAll.lastIndex = match.index;\n                    }\n                }\n                \n                // Increment the iterations count\n                iterations++;\n            }\n            \n            // Append the current branch to the combined set of all branches\n            if (allConditionsCode_i.length <= 0) {\n                // First thing to add\n                allConditionsCode_i = branchCode_i;\n            }\n            else {\n                // All subsequent additions.  Append a delimiter and the \n                allConditionsCode_i = allConditionsCode_i + branchDelimiterString + branchCode_i;\n            }\n        }\n        \n        // Debug messages\n        msg.log = msg.log + \"\\n\" + \"allConditionsCode_i = \" + allConditionsCode_i;\n        \n        // Pull the Main permissive snippet\n        var mainCode_i = global_PermissiveSnippets_Main.Code;\n        var mainComment_i = global_PermissiveSnippets_Main.Comment;\n        \n        // Reduce the main permissive code snippet down as much as possible\n        // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n        var doneSearching = false;\n        var iterations = 0;\n        var maxIterations = 5000;\n        reAll.lastIndex = 0;    // Start the regex out at the beginning of the string\n        while (!doneSearching && (iterations < maxIterations)) {\n            // Pull the next match\n            match = reAll.exec(mainCode_i);\n            \n            // Test if there was a match found or not.\n            if ((match === null) || (match === undefined)) {\n                // Nothing was found.  Quit searching.\n                doneSearching = true;\n            }\n            else {\n                // A match was found.\n                // Pull the match information\n                var operator = match[1];\n                var operand = match[2];\n                \n                // Perform find & replace based on the operator type\n                var replaceText = null;\n                switch(operator) {\n                    case ThisKeyword:\n                        // Do a parameter lookup\n                        // ***This lookup is limited in scope to the module's tag name only.***\n                        switch(operand) {\n                            case \"ModuleTagName\":\n                                replaceText = moduleTagName_i;\n                                break;\n                        }\n                        break;\n                        \n                    case CodeKeyword:\n                        // Do a snippet lookup.\n                        // ***This loopup is limited in scope to the global permissives snippet set.***\n                        // ***Exclude all required snippets from the lookup to prevent circular references.***\n                        var global_PermissiveSnippets_Temp = null;\n                        global_PermissiveSnippets_ResultsArray = global_PermissiveSnippets.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return ((element.SnippetName === operand) &&\n                                    (element.SnippetName !== \"Main\") &&\n                                    (element.SnippetName !== \"Branch\") &&\n                                    (element.SnippetName !== \"BranchDelayed\") &&\n                                    (element.SnippetName !== \"ConditionCodePlaceholder\"));\n                            }\n                        });\n                        \n                        // Test if the filtered list has anything in it\n                        if (global_PermissiveSnippets_ResultsArray.length > 0) {\n                            // Debug messages\n                            msg.log = msg.log + \"\\n\" + \">>>Found Operand<<<\";\n                            global_PermissiveSnippets_Temp = global_PermissiveSnippets_ResultsArray[0];\n                        }\n                        \n                        // Test if snippet was found\n                        if ((global_PermissiveSnippets_Temp !== null) && (global_PermissiveSnippets_Temp !== undefined)) {\n                            // Snippet was found.  Use snippet code\n                            replaceText = global_PermissiveSnippets_Temp.Code;\n                        }\n                        break;\n                        \n                    case DerivedKeyword:\n                        // Do a lookup of the derived calculations within this routine.\n                        // Valid options:  AllConditionsCode\n                        switch(operand) {\n                            case \"AllConditionsCode\":\n                                replaceText = allConditionsCode_i;\n                                break;\n                        }\n                        break;\n                }\n                \n                // Test if there is a replacement string\n                if ((replaceText !== null) && (replaceText !== undefined)) {\n                    // Perform the replacement\n                    mainCode_i = mainCode_i.substring(0, match.index) + replaceText + mainCode_i.substring(reAll.lastIndex)\n                    \n                    // Start the RegExp's pointer to start scanning at the beginning of the last match\n                    // This is done in case the replacement also contains matches that need replacing\n                    reAll.lastIndex = match.index;\n                }\n            }\n            \n            // Increment the iterations count\n            iterations++;\n        }\n        \n        // Push the derived code out to the return dataset\n        returnDataSet.push({\n                \"Controller\":controller_i,\n                \"ModuleTagName\":moduleTagName_i,\n                \"Snippets\":[{\n                    \"SnippetName\":\"AllPermissivesCode\",\n                    \"Code\":mainCode_i,\n                    \"Comment\":mainComment_i\n                }]\n        });\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\"ModuleCodeSnippets_Permissives\": returnDataSet};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 568.0000305175781,
    "y": 417.2499694824219,
    "wires": [
      [
        "da232afd.8cdef8",
        "25cb81e9.fdfd6e",
        "fd70c08e.46ec7"
      ]
    ]
  },
  {
    "id": "da232afd.8cdef8",
    "type": "join",
    "z": "b8aa44e1.6124b",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 876.765625,
    "y": 307,
    "wires": [
      [
        "e441722e.91469"
      ]
    ]
  },
  {
    "id": "e441722e.91469",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Merge Into ModuleCodeSnippets",
    "func": "// Debug Messages\nmsg.log = \"Starting Merge Module Code Snippets...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n/*{\n    \"ModuleCodeSnippets\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n            \"SnippetName\":snippetName_i,\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n// Setup the list of datasets of module snippet collections to merge\nvar payloadsToMerge = [\n    \"ModuleCodeSnippets_Interlocks\",\n    \"ModuleCodeSnippets_Permissives\"\n];\n\n// Debug messages\nmsg.log = msg.log + \"\\n\" + \"Number of datasets = \" + payloadsToMerge.length;\n\n//Iterate the list of datasets to merge\nfor (var i = 0; i < payloadsToMerge.length; i++){\n    // Cache a reference to the current dataset\n    var dataset_i = msg.payload[payloadsToMerge[i]];\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Dataset = \" + payloadsToMerge[i] + \".\";\n    \n    // Iterate the modules in the current dataset\n    for (var j = 0; j < dataset_i.length; j++){\n        // Cache a reference to the current module\n        var module_i = dataset_i[j];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var moduleTagName_i = module_i.ModuleTagName;\n        \n        // Debug Messages\n        msg.log = msg.log + \"\\n\" + \"Item = \" + controller_i + \"-\" + moduleTagName_i + \".\";\n        \n        // Attempt to pull the module from the return dataset\n        var returnModule_i = null;\n        var matchingReturnModulesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return ((element.Controller == controller_i) &&\n                    (element.ModuleTagName == moduleTagName_i));\n            }\n        });\n        \n        // Test if the array is empty or not\n        if (matchingReturnModulesArray.length > 0) {\n            // Module already exists in the return set\n            // Pull it for modification\n            returnModule_i = matchingReturnModulesArray[0];\n        }\n        \n        // Test if the current module was found or not\n        if ((returnModule_i === null) || (returnModule_i === undefined)) {\n            // Module does not exist in the return set\n            // Create it & push it in\n            returnModule_i = {\n                \"Controller\":controller_i,\n                \"ModuleTagName\":moduleTagName_i,\n                \"Snippets\":[]\n            };\n            returnDataSet.push(returnModule_i);\n        }\n        \n        // Debug Messages\n        //msg.log = msg.log + \"\\n\" + \"Incoming item's snippet count = \" + module_i.Snippets.length + \".\";\n        //msg.log = msg.log + \"\\n\" + \"Return item's snippet count = \" + returnModule_i.Snippets.length + \".\";\n        \n        // Iterate the snippets in the current nodule\n        for (var k = 0; k < module_i.Snippets.length; k++){\n            // Cache a reference to the current snippet\n            var snippet_i = module_i.Snippets[k];\n            \n            // Pull the current snippets's data\n            var snippetName_i = snippet_i.SnippetName;\n            var code_i = snippet_i.Code;\n            var comment_i = snippet_i.Comment;\n            \n            // Attempt to pull the snippet from the return dataset\n            var matchingReturnSnippetsArray = returnModule_i.Snippets.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.SnippetName == snippetName_i);\n                }\n            });\n            \n            // Test if the array is empty or not\n            if (matchingReturnSnippetsArray.length > 0) {\n                // Snippet already exists in the return set\n                // Log a validation error\n                msg.validationErrors = msg.validationErrors + \"\\n\" + controller_i + \"'s '\" + moduleTagName_i + \" cannot merge snippet \" + \n                    snippetName_i + \" because it is already in the merged dataset.\";\n            }\n            else {\n                // Snippet does not exist in the return set\n                // Create it & push it in\n                returnModule_i.Snippets.push({\n                    \"SnippetName\":snippetName_i,\n                    \"Code\":code_i,\n                    \"Comment\":comment_i\n                });\n            }\n        }\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\"ModuleCodeSnippets\": returnDataSet};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1129.765625,
    "y": 307,
    "wires": [
      [
        "e415a160.77dc2",
        "ac3945e0.6c086",
        "1436542e.e463fc"
      ]
    ]
  },
  {
    "id": "86d0c203.a27c9",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 519.765625,
    "y": 344.9999694824219,
    "wires": []
  },
  {
    "id": "ae41fcd0.fae72",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 480.765625,
    "y": 381,
    "wires": []
  },
  {
    "id": "25cb81e9.fdfd6e",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 518.765625,
    "y": 453,
    "wires": []
  },
  {
    "id": "fd70c08e.46ec7",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 479.765625,
    "y": 489,
    "wires": []
  },
  {
    "id": "e415a160.77dc2",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1079.515625,
    "y": 380,
    "wires": []
  },
  {
    "id": "ac3945e0.6c086",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1118.515625,
    "y": 343.9999694824219,
    "wires": []
  },
  {
    "id": "758ae508.8415cc",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Resolve Snippets to Commented Rungs",
    "func": "// Debug Messages\nmsg.log = \"Starting Resolve Snippets to Commented Rungs...\";\nmsg.traceLog = \"\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\n// Set up the constants to use later\nconst endOfSegmentMarker = \";\";\nconst commentDelimiter = \"\\r\\n\";\n\nconst AllDynamicRefsRegex = \"{((?:This)|(?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t        // Operand CANNOT include { or }\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t\t\t        // Operand CANNOT include { or }\nconst NonCodeDynamicRefsRegex = \"{((?:This))\\\\[([^{}]+?)\\\\]}\";\t\t                    // Operand CANNOT include { or }\nconst CommentDynamicRefsRegex = \"{((?:Comment)|(?:DerivedComment))\\\\[([^{}]+?)\\\\]}\";    // Operand CANNOT include { or }\n\nconst ThisKeyword = \"This\";\nconst CodeKeyword = \"Code\";\nconst DerivedKeyword = \"Derived\";\nconst CommentKeyword = \"Comment\";\nconst DerivedCommentKeyword = \"DerivedComment\";\n\n/*{\n    \"ResolvedCodeSegments\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"CodeSegments\":[{\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n// Cache a reference to the relevant data sets that need to be used\nvar cDef_UsageScenarios = msg.payload[\"CDef_UsageScenarios_Pivoted\"];\nvar modulesList = msg.payload[\"Modules\"];\n\n// Iterate the tags in the Modules list dataset\nfor (var i = 0; i < modulesList.length; i++){\n    // Cache a reference to the current module's list data\n    var module_i = modulesList[i];\n    \n    // Cache off the common paramaters from the current module\n    var controller_i = module_i.Controller;\n    var moduleTagName_i = module_i.ModuleTagName;\n    \n    //TODO: remove test code\n    //var resolvedCodeSegments_i = null\n    //if (module_i.ClassName == \"P_VSD\") {\n    //    resolvedCodeSegments_i = GetResolvedCodeSegments(controller_i, moduleTagName_i);\n    //}\n    \n    // Pull the resolved code segments (rungs) for thie current module\n    var resolvedCodeSegments_i = GetResolvedCodeSegments(controller_i, moduleTagName_i);\n    \n    // Test if there was anything returned\n    if ((resolvedCodeSegments_i !== null) && (resolvedCodeSegments_i !== undefined)) {\n        // Module has code to deploy\n        // Create the base object for this module\n        var returnModule_i = {\n            \"Controller\":controller_i,\n            \"ModuleTagName\":moduleTagName_i,\n            \"ClassName\":module_i.ClassName,\n            \"Task\":module_i.Task,\n            \"Program\":module_i.Program,\n            \"Routine\":module_i.Routine,\n            \"ExecutionOrder\":module_i.ExecutionOrder,\n            \"CodeSegments\":[]\n        };\n        \n        // Iterate the tags in the Modules list dataset\n        for (var j = 0; j < resolvedCodeSegments_i.length; j++){\n            // Cache a reference to the current resolved code segment\n            var resolvedCodeSegment_i = resolvedCodeSegments_i[j];\n            \n            // Push the current code segment to the current module's return set.\n            returnModule_i.CodeSegments.push({\n                \"Code\":resolvedCodeSegment_i.Code,\n                \"Comment\":resolvedCodeSegment_i.Comment\n            });\n        }\n        \n        // Push the module to the return dataset\n        returnDataSet.push(returnModule_i);\n    }\n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\"ResolvedCodeSegments\": returnDataSet};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction parseBoolean(value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n}\n\nfunction GetParameter(controllerName, moduleTagName, parameterName) {\n    // This function returns the value for the specified module (controller-tagname pair) and parameter \n    // This function searches for the parameter name in the modules list first, then in the modules data table.\n    // Default the return variable\n    var returnValue = null;\n    \n    // Attempt to pull a reference to the module list dataset\n    var moduleList = msg.payload[\"Modules\"];\n    \n    // Test if the module list exists or not\n    var module_i = null;\n    if ((moduleList !== null) && (moduleList !== undefined)) {\n        // Module List exists\n        // Attempt to pull the module's data table information\n        var tempFilterArray = moduleList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) &&\n                        (element.ModuleTagName === moduleTagName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            module_i = tempFilterArray[0];\n        }\n    }\n    \n    // Test if the module exists in the master list or not\n    if ((module_i !== null) && (module_i !== undefined)) {\n        // Module exists in the master list\n        // Pull down the common parameters\n        var className_i = module_i.ClassName;\n        \n        /****************************\n        * Try Module List           *\n        *****************************/\n        // Test if the module list dataset has the given parameter name as a property\n        if (module_i.hasOwnProperty(parameterName)) {\n            // Pull the value\n            returnValue = module_i[parameterName];\n            \n            // Test if the return value is missing or not\n            if ((returnValue === null) || (returnValue === undefined)) {\n                // Value is missing.  Provide a default value.\n                // Note: This will prevent the subsequent code from performing an unnecessary lookup in the data table.\n                returnValue = \"\";\n            }\n        }\n        \n        /****************************\n        * Try Module Data Table     *\n        *****************************/\n        // Test if the return value is missing or not\n        // If it is missing, try searching for the parameter in the module data table\n        if ((returnValue === null) || (returnValue === undefined)) {\n            // Attempt to pull the module data table for the current module\n            var moduleDataTable = msg.payload[className_i];\n            \n            // Test if the module's data table exists or not\n            var moduleData_i = null;\n            if ((moduleDataTable !== null) && (moduleDataTable !== undefined)) {\n                // Attempt to pull the module's data table information\n                tempFilterArray = moduleDataTable.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists in the data table\n                    // Cache a reference to the current module's data table row\n                    moduleData_i = tempFilterArray[0];\n                    \n                    // Test if the module data table has the given parameter name as a property\n                    if (moduleData_i.hasOwnProperty(parameterName)) {\n                        // Pull the value from the module's data table\n                        returnValue = moduleData_i[parameterName];\n                        \n                        // Test if the return value is missing or not\n                        if ((returnValue === null) || (returnValue === undefined)) {\n                            /****************************\n                            * Try Class Definition      *\n                            *****************************/\n                            // Value is missing.  Try to pull it from the class definition.\n                            // Attempt to pull a reference to the class parameters definitions dataset\n                            var cDef_Parameters = msg.payload[\"CDef_Parameters_Pivoted\"];\n                            \n                            // Attempt to pull the module's class's parameter information\n                            tempFilterArray = cDef_Parameters.filter((element)=>{\n                                    if ((element !== null) && (element !== undefined)){\n                                        return (element.ClassName === className_i);\n                                    }\n                                });\n                            \n                            // Check is anything was returned\n                            if(tempFilterArray.length > 0) {\n                                // Cache a reference to the current module's class parameters definition\n                                var cDef_Class_i = tempFilterArray[0];\n                                \n                                // Attempt to pull the given parameter in the class parameters definitions dataset\n                                tempFilterArray = cDef_Class_i.Parameters.filter((element)=>{\n                                        if ((element !== null) && (element !== undefined)){\n                                            return (element.ParameterName === parameterName);\n                                        }\n                                    });\n                                \n                                // Check is anything was returned\n                                if(tempFilterArray.length > 0) {\n                                    // Cache a reference to the class definition's parameter\n                                    var cDef_Parameter_i = tempFilterArray[0];\n                                    \n                                    // Pull the data type and the default value\n                                    var dataType_i = cDef_Parameter_i.DataType;\n                                    returnValue = cDef_Parameter_i.DefaultValue;\n                                    \n                                    // Test if the return value is missing or not\n                                    if ((returnValue === null) || (returnValue === undefined)) {\n                                        // Value is missing.  Provide a default value.\n                                        // TODO: Vary default return value by datatype?\n                                        returnValue = \"\";\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Return the result\n    return returnValue;\n}\n\nfunction GetSnippet(controllerName, moduleTagName, snippetName) {\n    // This function returns the value for the specified module (controller-tagname pair) and snippet \n    // This function searches for the snippet name in the module's class's current usage scenario first, \n    //  then in the module's class's Globaql usage scenario, then in the Global class definition's Global usage scenario.\n    // Default the return variable\n    var returnValue = null;\n    \n    // Attempt to pull a reference to the class snippet definitions dataset\n    var cDef_CodeSnippets = msg.payload[\"CDef_CodeSnippets_Pivoted\"];\n    \n    // Attempt to pull a reference to the module list dataset\n    var moduleList = msg.payload[\"Modules\"];\n    \n    // Test if the module list exists or not\n    var module_i = null;\n    if ((moduleList !== null) && (moduleList !== undefined)) {\n        // Module List exists\n        // Attempt to pull the module's data table information\n        var tempFilterArray = moduleList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) &&\n                        (element.ModuleTagName === moduleTagName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            module_i = tempFilterArray[0];\n        }\n    }\n    \n    // Test if the module exists in the master list or not\n    if ((module_i !== null) && (module_i !== undefined)) {\n        // Module exists in the master list\n        // Pull down the common parameters\n        var className_i = module_i.ClassName;\n        var usageScenario_i = module_i.UsageScenario;\n        \n        /********************************************\n        * Try Current Module's Override Code        *\n        ********************************************/\n        if (snippetName == \"Main\") {\n            // Attempt to pull the module data table for the current module\n            var moduleDataTable = msg.payload[className_i];\n            \n            // Test if the module's data table exists or not\n            var moduleData_i = null;\n            if ((moduleDataTable !== null) && (moduleDataTable !== undefined)) {\n                // Attempt to pull the module's data table information\n                tempFilterArray = moduleDataTable.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists in the data table\n                    // Cache a reference to the current module's data table row\n                    moduleData_i = tempFilterArray[0];\n                    \n                    // Pull the relevant parameters\n                    var codeOverride_i = moduleData_i[\"CodeOverride\"];\n                    var commentOverride_i = moduleData_i[\"CommentOverride\"];\n                    \n                    // Test if there is any code override to return\n                    if ((codeOverride_i !== null) && (codeOverride_i !== undefined)) {\n                        // The code column exists and it is not empty\n                        // Test if there is any comment override to return\n                        if ((commentOverride_i === null) || (commentOverride_i === undefined)) {\n                            // Comment override is missing.  \n                            commentOverride_i = \"\";\n                            //FUTURE: Look it up from the class definitions Main snippet??\n                        }\n                        \n                        // Create a new object with the code-comment override data\n                        returnValue = {\n                            \"Code\": codeOverride_i,\n                            \"Comment\": commentOverride_i,\n                        };\n                    }\n                }\n            }\n        }\n        \n        // If nothing has been found yet, start searching the class definitions data set\n        if ((returnValue === null) || (returnValue === undefined)) {\n            // Attempt to pull the module's class's snippets information\n            tempFilterArray = cDef_CodeSnippets.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.ClassName === className_i);\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Cache a reference to the current module's class snippets definition\n                var cDef_Class_i = tempFilterArray[0];\n                \n                /********************************************\n                * Try Current Class's Current Scenario      *\n                ********************************************/\n                // Attempt to pull the given usage scenario from the current module's class snippets definition\n                tempFilterArray = cDef_Class_i.UsageScenarios.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return (element.UsageScenarioName === usageScenario_i);\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Cache a reference to the class definition's current usage scenario\n                    var cDef_UsageScenario_i = tempFilterArray[0];\n                    \n                    // Attempt to pull the given usage scenario from the current module's class snippets definition\n                    tempFilterArray = cDef_UsageScenario_i.Snippets.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.SnippetName === snippetName);\n                            }\n                        });\n                    \n                    // Check is anything was returned\n                    if(tempFilterArray.length > 0) {\n                        // Snippet was found. Return it.\n                        returnValue = tempFilterArray[0];\n                    }\n                }\n                \n                /*******************************************\n                * Try Current Class's Global Scenario      *\n                ********************************************/\n                // If nothing has been found yet, pull the Global usage scenario from the current class\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Attempt to pull the Global usage scenario from the current module's class snippets definition\n                    tempFilterArray = cDef_Class_i.UsageScenarios.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.UsageScenarioName === \"Global\");\n                            }\n                        });\n                    \n                    // Check is anything was returned\n                    if(tempFilterArray.length > 0) {\n                        // Cache a reference to the class definition's Global usage scenario\n                        var cDef_UsageScenario_i = tempFilterArray[0];\n                        \n                        // Attempt to pull the given usage scenario from the current module's class snippets definition\n                        tempFilterArray = cDef_UsageScenario_i.Snippets.filter((element)=>{\n                                if ((element !== null) && (element !== undefined)){\n                                    return (element.SnippetName === snippetName);\n                                }\n                            });\n                        \n                        // Check is anything was returned\n                        if(tempFilterArray.length > 0) {\n                            // Snippet was found. Return it.\n                            returnValue = tempFilterArray[0];\n                        }\n                    }\n                }\n                \n                /*******************************************\n                * Try Global Class's Global Scenario       *\n                ********************************************/\n                // If nothing has been found yet, pull the Global usage scenario from the Global class\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Attempt to pull the module's class's snippets information\n                    var cDef_Global = null;\n                    tempFilterArray = cDef_CodeSnippets.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.ClassName === \"Global\");\n                            }\n                        });\n                    \n                    // Check is anything was returned\n                    if(tempFilterArray.length > 0) {\n                        // Cache a reference to the current module's class snippets definition\n                        cDef_Global = tempFilterArray[0];\n                    }\n                    \n                    // Test if the Global class exists\n                    if ((cDef_Global !== null) && (cDef_Global !== undefined)) {\n                        // Attempt to pull the global usage scenario from the Global class\n                        tempFilterArray = cDef_Global.UsageScenarios.filter((element)=>{\n                                if ((element !== null) && (element !== undefined)){\n                                    return (element.UsageScenarioName === \"Global\");\n                                }\n                            });\n                        \n                        // Check is anything was returned\n                        var cDef_Global_UsageScenario = null;\n                        if(tempFilterArray.length > 0) {\n                            // Cache a reference to the Global class's Global usage scenario\n                            cDef_Global_UsageScenario = tempFilterArray[0];\n                        }\n                        \n                        // Attempt to pull a reference to the global usage scenario's snippets\n                        var cDef_Global_Snippets = null;\n                        if ((cDef_Global_UsageScenario !== null) && (cDef_Global_UsageScenario !== undefined)) {\n                            var cDef_Global_Snippets = cDef_Global_UsageScenario.Snippets;\n                        }\n                        \n                        // Test if the Global class's Global usage scenario exists\n                        if ((cDef_Global_Snippets !== null) && (cDef_Global_Snippets !== undefined)) {\n                            // Attempt to pull the given usage scenario from the current module's class snippets definition\n                            tempFilterArray = cDef_Global_Snippets.filter((element)=>{\n                                    if ((element !== null) && (element !== undefined)){\n                                        return (element.SnippetName === snippetName);\n                                    }\n                                });\n                            \n                            // Check is anything was returned\n                            if(tempFilterArray.length > 0) {\n                                // Snippet was found. Return it.\n                                returnValue = tempFilterArray[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Return the result\n    return returnValue;\n}\n\nfunction GetSnippetCode(controllerName, moduleTagName, snippetName) {\n    // Returns just the code portion of the code-comment pair\n    var codeCommentPair = GetSnippet(controllerName, moduleTagName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Code : null;\n}\n\nfunction GetSnippetComment(controllerName, moduleTagName, snippetName) {\n    // Returns just the comment portion of the code-comment pair\n    var codeCommentPair = GetSnippet(controllerName, moduleTagName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Comment : null;\n}\n\nfunction GetDerivedItem(controllerName, moduleTagName, itemName) {\n    // This function returns the value for the specified module (controller-tagname pair) and item name \n    // This function is intended to vary its search method AND return data type based on the item name to search for.\n    // Currently supported searchable item names:\n    //      1) AllInterlocksCode:  Returns a snippet {\"SnippetName\":string, \"Code\":string, \"Comment\":string}\n    //      2) AllPermissivesCode:  Returns a snippet {\"SnippetName\":string, \"Code\":string, \"Comment\":string}\n    // Note:  Everything else returns null\n    //\n    // Default the return variable\n    var returnValue = null;\n    \n    // Determine what the item to search for is\n    switch(itemName) {\n        case \"AllInterlocksCode\":\n        case \"AllPermissivesCode\":\n            // This case handles all snippet lookups from the ModuleCodeSnippets dataset\n            // Attempt to pull a reference to the module snippets dataset\n            var mDef_CodeSnippets = msg.payload[\"ModuleCodeSnippets\"];\n            \n            // Test if the module list exists or not\n            var mDef_CodeSnippets_i = null;\n            if ((mDef_CodeSnippets !== null) && (mDef_CodeSnippets !== undefined)) {\n                // Module List exists\n                // Attempt to pull the module's snippet derived code snippets dataset\n                var tempFilterArray = mDef_CodeSnippets.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists\n                    // Cache a reference to the current module's custom snippets definitions\n                    mDef_CodeSnippets_i = tempFilterArray[0];\n                }\n            }\n            \n            // Test if the module exists in the master list or not\n            if ((mDef_CodeSnippets_i !== null) && (mDef_CodeSnippets_i !== undefined)) {\n                // Module exists in the module code snippets dataset\n                // Attempt to pull the module's specified derived code snippet\n                var tempFilterArray = mDef_CodeSnippets_i.Snippets.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return (element.SnippetName === itemName);\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Requested item exists.  Return it.\n                    returnValue = tempFilterArray[0];\n                }\n            }\n            break;\n    }\n    \n    // Return the result\n    return returnValue;\n}\n\nfunction GetDerivedCode(controllerName, moduleTagName, itemName) {\n    // Returns just the code portion of the code-comment pair\n    // TODO:  Test if this actually is a code-comment pair\n    var codeCommentPair = GetDerivedItem(controllerName, moduleTagName, itemName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Code : null;\n}\n\nfunction GetDerivedComment(controllerName, moduleTagName, itemName) {\n    // Returns just the comment portion of the code-comment pair\n    // TODO:  Test if this actually is a code-comment pair\n    var codeCommentPair = GetDerivedItem(controllerName, moduleTagName, itemName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Comment : null;\n}\n\nfunction ResolveNonCodeReferences(controllerName, moduleTagName, stringToResolve) {\n    // This function resolves all non-code find and replace markers into their requested values\n    // This function currently supports the following non-code markers:\n    //  1) {This[ParameterName]}\n    //\n    // FUTURE:\n    // Might want to consider adding support for:\n    //  1) {If[Condition ? ValueIfTrue : ValueIfFalse]}\n    \n    // Default the return value\n    var returnValue = stringToResolve.toString();\n    \n    // Reduce the raw branch code snippet down as much as possible\n    // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n    var reNonCode = RegExp(NonCodeDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reNonCode.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Pull the next match\n        var match = reNonCode.exec(returnValue);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Perform find & replace based on the operator type\n            var replaceText = null;\n            switch(operator) {\n                case ThisKeyword:\n                    // Do a parameter lookup.\n                    var lookupResult = GetParameter(controllerName, moduleTagName, operand);\n                    \n                    // Test if snippet was found\n                    if ((lookupResult !== null) && (lookupResult !== undefined)) {\n                        // Parameter was found.  Use the parameters value.\n                        replaceText = lookupResult;\n                    }\n                    else {\n                        // Parameter was NOT found.  Remove the curly braces & put the find and replace marker back in its place.\n                        replaceText = wholeMatch.substring(1, wholeMatch.length - 1);\n                    }\n                    break;\n            }\n            \n            // Test if there is a replacement string\n            if ((replaceText !== null) && (replaceText !== undefined)) {\n                // Perform the replacement\n                returnValue = returnValue.substring(0, match.index) + replaceText + returnValue.substring(reNonCode.lastIndex)\n                \n                // Start the RegExp's pointer to start scanning at the beginning of the last match\n                // This is done in case the replacement also contains matches that need replacing\n                reNonCode.lastIndex = match.index;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Return the result\n    return returnValue;\n}\n\nfunction ResolveCommentPlaceholders(controllerName, moduleTagName, stringToResolve) {\n    // This function resolves all comment placeholder find and replace markers into their requested values\n    // This function currently supports the following comment markers:\n    //  1) {Comment[SnippetName]}\n    //  2) {DerivedComment[SnippetName]}\n    \n    // Default the return value\n    var returnValue = \"\";\n    \n    // Reduce the raw branch code snippet down as much as possible\n    // Find and replace all {Comment[~~]} & {DerivedComment[~~]} references that will resolve correctly\n    var reComment = RegExp(CommentDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reComment.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Pull the next match\n        var match = reComment.exec(stringToResolve);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Perform find & replace based on the operator type\n            var resolvedText = null;\n            switch(operator) {\n                case CommentKeyword:\n                    // Do a standard code's comment lookup.\n                    var lookupResult = GetSnippetComment(controllerName, moduleTagName, operand);\n                    \n                    // Test if snippet was found\n                    if ((lookupResult !== null) && (lookupResult !== undefined)) {\n                        // Parameter was found.  Use the parameters value.\n                        resolvedText = lookupResult;\n                    }\n                    else {\n                        // Parameter was NOT found.  Remove the curly braces & put the find and replace marker back in its place.\n                        resolvedText = wholeMatch.substring(1, wholeMatch.length - 1);\n                    }\n                    break;\n                    \n                case DerivedCommentKeyword:\n                    // Do a derived code's comment lookup.\n                    var lookupResult = GetDerivedComment(controllerName, moduleTagName, operand);\n                    \n                    // Test if snippet was found\n                    if ((lookupResult !== null) && (lookupResult !== undefined)) {\n                        // Parameter was found.  Use the parameters value.\n                        resolvedText = lookupResult;\n                    }\n                    else {\n                        // Parameter was NOT found.  Remove the curly braces & put the find and replace marker back in its place.\n                        resolvedText = wholeMatch.substring(1, wholeMatch.length - 1);\n                    }\n                    break;\n            }\n            \n            // Test if there is a replacement string\n            if ((resolvedText !== null) && (resolvedText !== undefined)) {\n                // Add the resolved text to the return value.  Prefix with the comment delimiter if there is anything already there.\n                returnValue = returnValue + (returnValue.length > 0 ? commentDelimiter : \"\") + resolvedText;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Resolve all non-code references before returning the result\n    returnValue = ResolveNonCodeReferences(controllerName, moduleTagName, returnValue);\n    \n    // Return the result\n    return returnValue;\n}\n\nfunction GetResolvedCodeAndCommentPlaceholderPairs(controllerName, moduleTagName, snippetType, snippetName) {\n    // This function resolves all code find and replace markers for the given snippet name into the code segment-comment placeholder pairs.\n    // The resolved string is split into code segments using the End of Segment marker\n    //   i.e. End of Segment marker is a semi-colon for RSLogix 5000 rungs in neutral text syntax.\n    // The comment placeholders are used instead of the resolved comments in order to properly generate \n    //  combined comments when the code contains End of Segment markers.\n    //\n    // This function currently supports the following code markers:\n    //  1) {Code[SnippetName]}\n    //  2) {DerivedComment[SnippetName]}\n    // \n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"CommentPlaceholder\":commentPlaceholder_i\n    // }]\n    \n    // Debug Messages\n    msg.traceLog = msg.traceLog + \"\\n\\t\" + \"-->GetResolvedCodeAndCommentPlaceholderPairs(\" + controllerName + \", \" + moduleTagName + \", \" + snippetType + \", \" + snippetName + \")\";\n    \n    // Default the return value as an empty array\n    var codeAndCommentPlaceholderPairs = [];\n    \n    // Create the regex objects for pattern matching\n\tvar reCode = new RegExp(CodeDynamicRefsRegex, \"mg\");        //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n\tvar reNonCode = new RegExp(NonCodeDynamicRefsRegex, \"mg\");  //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    \n    // Pull the code & comment for this snippet\n    var thisCode = null;\n\tvar thisCommentPlaceholder = null;\n    switch(snippetType) {\n        case \"Code\":\n            thisCode = GetSnippetCode(controllerName, moduleTagName, snippetName)\n\t        thisCommentPlaceholder = \"{Comment[\" + snippetName + \"]}\";\n            break;\n            \n        case \"Derived\":\n            thisCode = GetDerivedCode(controllerName, moduleTagName, snippetName)\n\t        thisCommentPlaceholder = \"{DerivedComment[\" + snippetName + \"]}\";\n            break;\n    }\n\t\n\t// Debug Messages\n    msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"thisCode = \" + thisCode;\n    msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"thisCommentPlaceholder = \" + thisCommentPlaceholder;\n\t\n    // Test if the given snippet could be found\n    if ((thisCode !== null) && (thisCode !== undefined)) {\n        // Code exists.\n        // Default the return value to an array with the base code-comment placeholder pair\n        codeAndCommentPlaceholderPairs = [{\n            \"Code\":thisCode,\n            \"CommentPlaceholder\":thisCommentPlaceholder\n        }];\n        \n        // Default looping variables\n    \tvar loopCounter = 0;\n    \tvar ptr = 0;\n    \tvar maxLoops = 5000;\n    \t\n    \t// Iterate the list of code-comment pairs as long as the pointer is valid & the max loop counter hasn't been exceeded.\n    \twhile ((ptr < codeAndCommentPlaceholderPairs.length) && (loopCounter < maxLoops)) {\n    \t    // Pull a reference to the current code & comment placeholder\n    \t    var codeAndCommentPlaceholder_i = codeAndCommentPlaceholderPairs[ptr];\n    \t    \n    \t    // Debug Messages\n            msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Initial:  ptr = \" + ptr + \", count = \" + codeAndCommentPlaceholderPairs.length + \", loopCounter = \" + loopCounter;\n    \t    \n    \t    // Start each regex object back at the beginning on every pass through the loop\n    \t    reCode.lastIndex = 0;\n    \t    reNonCode.lastIndex = 0;\n    \t    \n    \t\t// Pull out the parameters\n    \t\tvar code_i = codeAndCommentPlaceholder_i.Code;\n    \t\tvar commentPlaceholder_i = codeAndCommentPlaceholder_i.CommentPlaceholder;\n    \t\t\n    \t\t// Debug Messages\n            msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Initial code_i = \" + code_i;\n            msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Initial commentPlaceholder_i = \" + commentPlaceholder_i;\n    \t\t\n    \t\t// Resolve any non-code references\n    \t\tif (reNonCode.test(code_i)) {\n    \t\t    // Debug Messages\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Resolving non-code references.\";\n                \n    \t\t\t// Has at least 1 non-code reference\n    \t\t\tcode_i = ResolveNonCodeReferences(controllerName, moduleTagName, code_i);\n    \t\t\t\n    \t\t\t// Push result back to the list item in case no splits or code reference resolutions occur.\n    \t\t\tcodeAndCommentPlaceholder_i.Code = code_i;\n    \t\t}\n    \t\t\n    \t\t// Test if the current item's code needs to be split into segments.  If no split is required, test if it needs a code reference replacement.\n    \t\t// The code needs to be split if there is more than 1 End Of Segment (EOS) Marker OR there is only 1 and it isn't at the end of the string.\n    \t\tvar eosCount = (code_i.length - code_i.replace(endOfSegmentMarker, \"\").length) / endOfSegmentMarker.length;\n    \t\tif ((eosCount > 1) || (eosCount == 1 && !(code_i.endsWith(endOfSegmentMarker)))) {\n    \t\t\t// The current code needs splitting.\n    \t\t\t// Debug Messages\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Current item needs splitting, eosCount = \" + eosCount;\n    \t\t\t\n    \t\t\t// Split the current code into segments by splitting on the End Of Segment (EOS) marker\n    \t\t\t// Note: string.split does NOT have a remove empty entries option like .NET.  Need to follow this with a filter statement.\n    \t\t\tvar tempCodeSegments = code_i.split(endOfSegmentMarker);\n    \t\t\t\n    \t\t\t// Delete all empty items\n    \t\t\t// Note:  Ignore empty segment!  Replicates .NET's System.String.Split(Delimiter, StringSplitOptions.RemoveEmptyEntries)\n    \t\t\ttempCodeSegments = tempCodeSegments.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            // Element is NOT null or undefined.  Return true for non-blank items to keep them and false for blank items to filter them out.\n                            return (element.length > 0);\n                        }\n                    });\n                \n                // Debug Messages\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"The current code segment split into \" + tempCodeSegments.length + \" pieces.\";\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Preparing to iterate the segment's pieces.\";\n                \n    \t\t\t// Iterate the code segments IN REVERSE ORDER to manipulate them & insert them back into the base list one at a time.\n    \t\t\tfor (var i = tempCodeSegments.length - 1; i >= 0; i--) {\n    \t\t\t    // Debug Messages\n    \t\t\t    msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"i = \" + i;\n    \t\t\t    msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"Split piece = \" + tempCodeSegments[i];\n    \t\t\t    \n    \t\t\t\t// Test if this is the LAST code segment AND that the original code did NOT end with an EOS marker\n    \t\t\t\tif ((i == tempCodeSegments.length - 1) && !(code_i.endsWith(endOfSegmentMarker))) {\n    \t\t\t\t    // Debug Messages\n    \t\t\t        msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"This is the last code segment and it did NOT end in an EOS marker.  Inserting the code segment without an EOS marker appended.\";\n    \t\t\t        \n    \t\t\t\t\t// Insert the code segment WITHOUT an EOS marker appended to it as the next item after the one currently being processed.\n    \t\t\t\t\t// Copy the current code's comment place holder to apply it to each segment being split apart.\n    \t\t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": tempCodeSegments[i], \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t\t}\n    \t\t\t\telse {\n    \t\t\t\t    // Debug Messages\n    \t\t\t        msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"This is the last code segment and it did end in an EOS marker OR it is not the last code segment.  Inserting the code segment with an EOS marker appended.\";\n    \t\t\t        \n    \t\t\t\t\t// Insert the code segment WITH an EOS marker appended to it as the next item after the one currently being processed.\n    \t\t\t\t\t// Copy the current code's comment place holder to apply it to each segment being split apart.\n    \t\t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": tempCodeSegments[i] + endOfSegmentMarker, \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\t// Debug Messages\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Done iterating the segment's pieces.\";\n    \t\t\t\n    \t\t\t// Test if there was a blank segment at the beginning of the original code that was dropped\n    \t\t\tif (code_i.startsWith(endOfSegmentMarker)) {\n    \t\t\t    // Debug Messages\n    \t\t\t    msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"The original code started with an EOS marker. Inserting a segment with the EOS marker only.\";\n    \t\t\t    \n    \t\t\t\t// Insert a blank code segment with appended EOS marker as the next item after the one currently being processed.\n    \t\t\t\t// Copy the current code's comment place holder to apply it to each segment being split apart.\n    \t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": endOfSegmentMarker, \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t}\n    \t\t\t\n    \t\t\t// Debug Messages\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Removing the original piece at ptr = \" + ptr;\n    \t\t\t\n    \t\t\t// Remove the original code from the list since it has been split apart and all of the pieces have been inserted back into the list\n    \t\t\t// Note: splice(Index, 1) is equivilent to .NET's Array.RemoveAt(Index)\n    \t\t\tcodeAndCommentPlaceholderPairs.splice(ptr, 1);\n    \t\t\t\n    \t\t\t// Do NOT increment the list pointer.  The code segements that were just added start at the current list pointer.\n    \t\t}\n    \t\telse if (reCode.test(code_i)) {\n    \t\t\t// Has at least 1 code reference\n    \t\t\t// Debug Messages\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Current item has at least 1 code reference to resolve.\";\n    \t\t\t\n    \t\t\t// The current code  needs a code reference replacement.\n    \t\t\t// Retrieve the first Match & the Captures.\n    \t\t\treCode.lastIndex = 0;\n                var match = reCode.exec(code_i);\n                \n                // A match was found.\n                // Pull the match information\n                var wholeMatch = match[0];\n                var operator = match[1];\n                var operand = match[2];\n    \t\t\tvar leftOfMatchString = code_i.substring(0, match.index);\n    \t\t\tvar rightOfMatchString = code_i.substring(reCode.lastIndex);\n    \t\t\t\n    \t\t\t// Debug Messages\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"wholeMatch = \" + wholeMatch;\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"operator = \" + operator;\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"operand = \" + operand;\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"leftOfMatchString = \" + leftOfMatchString;\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"rightOfMatchString = \" + rightOfMatchString;\n    \t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Pulling resolved c-cph pairs...\";\n    \t\t\t\n    \t\t\t// Pull the code-comment pairs for the requested code snippet\n    \t\t\tvar requestedCodeAndCommentPlaceholderPairs = GetResolvedCodeAndCommentPlaceholderPairs(controllerName, moduleTagName, operator, operand)\n    \t\t\t\n    \t\t\t// Debug Messages\n                msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Pull resulted in \" +requestedCodeAndCommentPlaceholderPairs.length + \" pairs.\";\n    \t\t\t\n    \t\t\t// Test if anything was returned.\n    \t\t\tif (requestedCodeAndCommentPlaceholderPairs.length == 0) {\n    \t\t\t    // Debug Messages\n                    msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Nothing was found.  Replace code reference with an empty string.\";\n                    \n    \t\t\t\t// Nothing was found.  Replace code reference with an empty string.\n    \t\t\t\tcodeAndCommentPlaceholderPairs[ptr].Code = leftOfMatchString + rightOfMatchString;\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\t// Prepend the text in the original code to the LEFT of the code reference to the code in the FIRST code-comment pair returned.\n    \t\t\t\t// Previous splitting code ensures that no additional split will be required.\n    \t\t\t\trequestedCodeAndCommentPlaceholderPairs[0].Code = leftOfMatchString + requestedCodeAndCommentPlaceholderPairs[0].Code;\n    \t\t\t\t\n    \t\t\t\t// Debug Messages\n                    msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Preparing to iterate the returned pieces.\";\n    \t\t\t\t\n    \t\t\t\t// Iterate the code-comment pairs IN REVERSE ORDER to manipulate them & insert them back into the base list one at a time.\n    \t\t\t\tfor (var i = requestedCodeAndCommentPlaceholderPairs.length - 1; i >= 0; i--) {\n    \t\t\t\t    // Debug Messages\n                        msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"i = \" + i;\n                        \n    \t\t\t\t\t// Test if this is the LAST element returned and whether or not a split (dual insert) or non-split (single insert) should be performed\n    \t\t\t\t\tif (i == requestedCodeAndCommentPlaceholderPairs.length - 1) {\n    \t\t\t\t\t\t// Test if the LAST code-comment pair ends with an End of Segment marker.\n    \t\t\t\t\t\tif (requestedCodeAndCommentPlaceholderPairs[i].Code.endsWith(endOfSegmentMarker)) {\n    \t\t\t\t\t\t\t// Dual insert\n    \t\t\t\t\t\t\t// The LAST code-comment pair should NOT be appended with the text in the original code to the RIGHT of the code reference.\n    \t\t\t\t\t\t\t// The text in the original code to the RIGHT of the code reference should be inserted as its own code segment IF AND ONLY IF it is NOT blank.\n    \t\t\t\t\t\t\t// Insert the code-comment pair as the next item after the one currently being processed.\n    \t\t\t\t\t\t\t// The comment should NOT retain the comment from the last requested segment.\n    \t\t\t\t\t\t\tif (rightOfMatchString.length > 0) {\n    \t\t\t\t\t\t\t    // Debug Messages\n                                    msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"Last resolved piece ended in an EOS marker.  Inserting rightOfMatchString as a new return piece.\";\n                                    msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\\t\" + \"commentPlaceholder_i = \" + commentPlaceholder_i;\n                                    \n    \t\t\t\t\t\t\t    // Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": rightOfMatchString, \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse {\n    \t\t\t\t\t\t\t// Single insert\n    \t\t\t\t\t\t\t// Debug Messages\n                                msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"Last resolved piece did NOT end in an EOS marker.  Appending rightOfMatchString to the end of it.\";\n                                \n    \t\t\t\t\t\t\t// The LAST code-comment pair should be appended with the text in the original code to the RIGHT of the code reference.\n    \t\t\t\t\t\t\t// Append the text in the original code to the RIGHT of the code reference to the code in the LAST code-comment pair returned.\n    \t\t\t\t\t\t\trequestedCodeAndCommentPlaceholderPairs[i].Code = requestedCodeAndCommentPlaceholderPairs[i].Code + rightOfMatchString;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\t// Debug Messages\n                        msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\" + \"Inserting resolved piece as a new return piece.\";\n                        msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\\t\" + \"commentPlaceholder_i = \" + commentPlaceholder_i;\n                        msg.traceLog = msg.traceLog + \"\\n\\t\\t\\t\\t\" + \"requestedCodeAndCommentPlaceholderPairs[i].CommentPlaceholder = \" + requestedCodeAndCommentPlaceholderPairs[i].CommentPlaceholder;\n                        \n    \t\t\t\t\t// Insert the code-comment pair as the next item after the one currently being processed.\n    \t\t\t\t\t// Prepend the current code's comment place holder to each code-comment pair.\n    \t\t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": requestedCodeAndCommentPlaceholderPairs[i].Code, \"CommentPlaceholder\": commentPlaceholder_i + requestedCodeAndCommentPlaceholderPairs[i].CommentPlaceholder});\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\t// Debug Messages\n                    msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Done iterating the returned pieces.\";\n    \t\t\t\tmsg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Removing the original piece at ptr = \" + ptr;\n    \t\t\t\t\n    \t\t\t\t// Remove the original code from the list since it has been split apart and all of the pieces have been inserted back into the list\n    \t\t\t\t// Note: splice(Index, 1) is equivilent to .NET's Array.RemoveAt(Index)\n    \t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr, 1);\n    \t\t\t\t\n    \t\t\t\t// Do NOT increment the list pointer.  The code segements that were just added start at the current list pointer.\n    \t\t\t}\n            }\n            else {\n            \t// No split or code reference replacement was required\n            \t// Increment the list pointer\n            \tptr++;\n            }\n            \n    \t\t// Increment the loop counter\n    \t\tloopCounter++;\n    \t\t\n    \t\t// Debug Messages\n            msg.traceLog = msg.traceLog + \"\\n\\t\\t\" + \"Final:  ptr = \" + ptr + \", count = \" + codeAndCommentPlaceholderPairs.length + \", loopCounter = \" + loopCounter;\n    \t} // End of while\n    }\n    \n    // Debug Messages\n    msg.traceLog = msg.traceLog + \"\\n\\t\" + \"<--\";\n    \n    // Return the result\n    return codeAndCommentPlaceholderPairs;\n}\n\nfunction GetResolvedCodeSegments(controllerName, moduleTagName) {\n    // This function pulls the entry point code for the given module and resolves it into the code segment-comment pairs.\n    //   i.e. A rung is a code sgement in RSLogix 5000 ladder logic.\n    //\n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"Comment\":comment_i\n    // }]\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Start of GetResolvedCodeSegments(\" + controllerName + \", \" + moduleTagName + \").\";\n    \n    // Default the return value\n    var returnValue = null;\n    \n    // Resolve the entry point code to code-comment placeholder pairs\n    var codeCommentPlaceholderPairs = GetResolvedCodeAndCommentPlaceholderPairs(controllerName, moduleTagName, \"Code\", \"Main\")\n    \n    // Test if anything was returned\n    if ((codeCommentPlaceholderPairs === null) || (codeCommentPlaceholderPairs === undefined)) {\n        // Log a validation error\n        msg.validationErrors = msg.validationErrors + \"\\n\" + controllerName + \"'s \" + moduleTagName + \" failed to return a resolved code-comment placeholders array.\";\n    }\n    else {\n        // Object exists\n        // Test if there is anything to iterate\n        if (codeCommentPlaceholderPairs.length <= 0) {\n            // Log a validation error\n            msg.validationErrors = msg.validationErrors + \"\\n\" + controllerName + \"'s \" + moduleTagName + \" failed to return any resolved code-comment placeholders.\";\n        }\n        else {\n            // Iterate the code-comment placeholder pairs to resolve the comments\n            for (var i = 0; i < codeCommentPlaceholderPairs.length; i++){\n                // Pull a reference to the current code-comment placeholder pair\n                var codeCommentPlaceholderPair_i = codeCommentPlaceholderPairs[i];\n                \n                // Pull the pieces\n                var code_i = codeCommentPlaceholderPair_i.Code;\n                var commentPlaceholder_i = codeCommentPlaceholderPair_i.CommentPlaceholder;\n                \n                // Resolve the comment placeholder\n                var comment_i = ResolveCommentPlaceholders(controllerName, moduleTagName, commentPlaceholder_i)\n                \n                if (returnValue === null) {\n                    // Create the initial object\n                    returnValue = [];\n                }\n                \n                // Add the pieces to the return dataset\n                returnValue.push({\n                    \"Code\": code_i,\n                    \"Comment\": comment_i\n                });\n            }\n        }\n    }\n    \n    // Return the result\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1695.515625,
    "y": 515,
    "wires": [
      [
        "d3034d55.a8c648",
        "681a8c32.b3e34c",
        "2a2c26ab.1f3bc2",
        "bb9d7b7c.590a9",
        "d1abfca8.1342c8",
        "b8c98992.23e7a",
        "cb64cb6b.4cc9d"
      ]
    ]
  },
  {
    "id": "bb9d7b7c.590a9",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Map Log to Payload",
    "func": "msg.payload = msg.log;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2025.765625,
    "y": 595.5,
    "wires": [
      []
    ]
  },
  {
    "id": "cb64cb6b.4cc9d",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Map Trace Log to Payload",
    "func": "msg.payload = msg.traceLog;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2045.765625,
    "y": 631,
    "wires": [
      []
    ]
  },
  {
    "id": "d1abfca8.1342c8",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Map Validation Errors to Payload",
    "func": "msg.payload = msg.validationErrors;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2068.765625,
    "y": 667.5,
    "wires": [
      []
    ]
  },
  {
    "id": "d3034d55.a8c648",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "false",
    "x": 1633,
    "y": 658.25,
    "wires": []
  },
  {
    "id": "681a8c32.b3e34c",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1623,
    "y": 621.25,
    "wires": []
  },
  {
    "id": "2a2c26ab.1f3bc2",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1663,
    "y": 587.25,
    "wires": []
  },
  {
    "id": "b8c98992.23e7a",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "traceLog",
    "x": 1642.765625,
    "y": 552,
    "wires": []
  },
  {
    "id": "da6960b1.12b25",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Get Controller Tags",
    "func": "// Debug Messages\nmsg.log = \"Starting Get Controller Tags...\";\n\n// Default the validation errors message if it doesn't have anything being passed in\nif ((msg.validationErrors === null) || (msg.validationErrors === undefined)) {\n    msg.validationErrors = \"\";\n}\n\nconst AllDynamicRefsRegex = \"{((?:This)|(?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t        // Operand CANNOT include { or }\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t\t\t        // Operand CANNOT include { or }\nconst NonCodeDynamicRefsRegex = \"{((?:This))\\\\[([^{}]+?)\\\\]}\";\t\t                    // Operand CANNOT include { or }\nconst CommentDynamicRefsRegex = \"{((?:Comment)|(?:DerivedComment))\\\\[([^{}]+?)\\\\]}\";    // Operand CANNOT include { or }\n\nconst ThisKeyword = \"This\";\nconst CodeKeyword = \"Code\";\nconst DerivedKeyword = \"Derived\";\nconst CommentKeyword = \"Comment\";\nconst DerivedCommentKeyword = \"DerivedComment\";\n\n// This function's purpose is to iterate the module tag names in the modules list\n// and generate a collection of controller tags to create.\n/*{\n    \"ControllerTags\":[\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    ]\n}*/\nvar returnDataSet = [];\n\n// Cache a reference to the relevant data sets that need to be used\nvar cDef_UsageScenarios = msg.payload[\"CDef_UsageScenarios_Pivoted\"];\nvar modulesList = msg.payload[\"Modules\"];\n\n/*\n// Attempt to pull the global class def\nvar cDef_Global = null;\nvar tempFilterArray = cDef_UsageScenarios.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.ClassName === \"Global\");\n        }\n    });\n\n// Check is anything was returned\nif(tempFilterArray.length > 0) {\n    // Module exists\n    // Cache a reference to the current module's master list row\n    cDef_Global = tempFilterArray[0];\n}\n\n// Attempt to pull the global interlocks scenario\nif ((cDef_Global) && (cDef_Global !== undefined)) {\n    var cDef_Global_InterlocksScenario = null;\n    var tempFilterArray = cDef_Global.UsageScenarios.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.UsageScenarioName === \"Interlocks\");\n            }\n        });\n    \n    // Check is anything was returned\n    if(tempFilterArray.length > 0) {\n        // Module exists\n        // Cache a reference to the current module's master list row\n        cDef_Global_InterlocksScenario = tempFilterArray[0];\n    }\n    \n    \n    //\n    //TODO:Finish\n    //\n}\n*/\n\n\n// TODO: Pull global Interlock tag def\n// TODO: Pull global Permissive tag def\n\n\n// Iterate the tags in the Modules list dataset\nfor (var i = 0; i < modulesList.length; i++){\n    // Cache a reference to the current module's list data\n    var module_i = modulesList[i];\n    \n    // Cache off the common paramaters from the current module\n    var controller_i = module_i.Controller;\n    var moduleTagName_i = module_i.ModuleTagName;\n    var moduleClassName_i = module_i.ClassName;\n    var usageScenario_i = module_i.UsageScenario;\n    var description_i = module_i.Description;           // TODO: Escape for RSLogix 5000\n    \n    // Debug Messages\n    msg.log = msg.log + \"\\n\" + \"Controller = \" + controller_i + \".\";\n    msg.log = msg.log + \"\\n\" + \"Module Tag Name = \" + moduleTagName_i + \".\";\n    msg.log = msg.log + \"\\n\" + \"Class Name = \" + moduleClassName_i + \".\";\n    msg.log = msg.log + \"\\n\" + \"Usage Scenario = \" + usageScenario_i + \".\";\n    \n    // Add this module to the return dataset\n    returnDataSet.push({\n        \"Controller\": controller_i,\n        \"Scope\": \"\",\n        \"TagName\": moduleTagName_i,\n        \"DataType\": moduleClassName_i,\n        \"Description\": description_i,\n        \"Specifier\": \"\",\n        \"Attributes\": GetAttributes(moduleClassName_i)\n    });\n    \n    // Attempt to pull the module's data table information\n    var cDef_module_i = null;\n    var tempFilterArray = cDef_UsageScenarios.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === moduleClassName_i);\n            }\n        });\n    \n    // Check is anything was returned\n    if(tempFilterArray.length > 0) {\n        // Module exists\n        // Cache a reference to the current module's master list row\n        cDef_Module_i = tempFilterArray[0];\n    }\n    \n    // Test if the class def exists or not\n    if ((cDef_Module_i !== null) && (cDef_Module_i !== undefined)){\n        // Class def exists.  Pull the current usage scenario\n        var cDef_ModuleUsageScenario_i = null;\n        var tempFilterArray = cDef_Module_i.UsageScenarios.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.UsageScenarioName === usageScenario_i);\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            cDef_ModuleUsageScenario_i = tempFilterArray[0];\n        }\n        \n        // Test if the class def usage scenario exists or not\n        if ((cDef_ModuleUsageScenario_i !== null) && (cDef_ModuleUsageScenario_i !== undefined)){\n            // Class def exists.  Iterate\n            // Iterate parameters in the current module's current class def usage scenario\n            for (var j = 0; j < cDef_ModuleUsageScenario_i.Parameters.length; j++){\n                // Cache a reference to the current parameter\n                var cDef_Parameter_i = cDef_ModuleUsageScenario_i.Parameters[j];\n                \n                // If the parameter is flagged as needing a tag to be created.\n                if (cDef_Parameter_i.CreateTag) {\n                    // Tag need to be created.\n                    \n                    // Add this module to the return dataset\n                    // Pull the tag name & tag description syntax & resolve all parameter references\n                    returnDataSet.push({\n                        \"Controller\": controller_i,\n                        \"Scope\": \"\",\n                        \"TagName\": ResolveNonCodeReferences(controller_i, moduleTagName_i, cDef_Parameter_i.TagName),\n                        \"DataType\": cDef_Parameter_i.DataType,\n                        \"Description\": ResolveNonCodeReferences(controller_i, moduleTagName_i, cDef_Parameter_i.TagDescription),\n                        \"Specifier\": \"\",\n                        \"Attributes\": GetAttributes(cDef_Parameter_i.DataType)\n                    });\n                }\n            }\n        }\n    }\n    \n    // TODO: Create Interlock tags\n    // TODO: Create Permissive tags\n    \n    \n}\n\n// Return the result\nmsg.log = msg.log + \"\\n\" + \"Returning result.\";\nmsg.payload = {\"ControllerTags\": returnDataSet};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction GetAttributes(dataType) {\n    var returnValue = null;\n    \n    // Strip off array brackets\n    var dataTypeWithoutArray = dataType.replace(/\\[(?:\\d|,)+\\]/img, \"\");\n    \n    // Return the Attributes based on the base data type\n    switch (dataTypeWithoutArray) {\n        case \"BOOL\":\n        case \"SINT\":\n        case \"INT\":\n        case \"DINT\":\n        case \"LINT\":\n            returnValue = \"(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n            \n        case \"REAL\":\n            returnValue = \"(RADIX := Float, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n        \n        case \"MESSAGE\":\n            returnValue = \"(ExternalAccess := Read/Write, MessageType := Unconfigured, RequestedLength := 1, CommTypeCode := 0, LocalIndex := 0)\";\n            break;\n        \n        default:\n            returnValue = \"(Constant := false, ExternalAccess := Read/Write)\";\n            break;\n    }\n    return returnValue;\n}\n\nfunction GetParameter(controllerName, moduleTagName, parameterName) {\n    // This function returns the value for the specified module (controller-tagname pair) and parameter \n    // This function searches for the parameter name in the modules list first, then in the modules data table.\n    // Default the return variable\n    var returnValue = null;\n    \n    // Attempt to pull a reference to the module list dataset\n    var moduleList = msg.payload[\"Modules\"];\n    \n    // Test if the module list exists or not\n    var module_i = null;\n    if ((moduleList !== null) && (moduleList !== undefined)) {\n        // Module List exists\n        // Attempt to pull the module's data table information\n        var tempFilterArray = moduleList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) &&\n                        (element.ModuleTagName === moduleTagName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            module_i = tempFilterArray[0];\n        }\n    }\n    \n    // Test if the module exists in the master list or not\n    if ((module_i !== null) && (module_i !== undefined)) {\n        // Module exists in the master list\n        // Pull down the common parameters\n        var className_i = module_i.ClassName;\n        \n        /****************************\n        * Try Module List           *\n        *****************************/\n        // Test if the module list dataset has the given parameter name as a property\n        if (module_i.hasOwnProperty(parameterName)) {\n            // Pull the value\n            returnValue = module_i[parameterName];\n            \n            // Test if the return value is missing or not\n            if ((returnValue === null) || (returnValue === undefined)) {\n                // Value is missing.  Provide a default value.\n                // Note: This will prevent the subsequent code from performing an unnecessary lookup in the data table.\n                returnValue = \"\";\n            }\n        }\n        \n        /****************************\n        * Try Module Data Table     *\n        *****************************/\n        // Test if the return value is missing or not\n        // If it is missing, try searching for the parameter in the module data table\n        if ((returnValue === null) || (returnValue === undefined)) {\n            // Attempt to pull the module data table for the current module\n            var moduleDataTable = msg.payload[className_i];\n            \n            // Test if the module's data table exists or not\n            var moduleData_i = null;\n            if ((moduleDataTable !== null) && (moduleDataTable !== undefined)) {\n                // Attempt to pull the module's data table information\n                tempFilterArray = moduleDataTable.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists in the data table\n                    // Cache a reference to the current module's data table row\n                    moduleData_i = tempFilterArray[0];\n                    \n                    // Test if the module data table has the given parameter name as a property\n                    if (moduleData_i.hasOwnProperty(parameterName)) {\n                        // Pull the value from the module's data table\n                        returnValue = moduleData_i[parameterName];\n                        \n                        // Test if the return value is missing or not\n                        if ((returnValue === null) || (returnValue === undefined)) {\n                            /****************************\n                            * Try Class Definition      *\n                            *****************************/\n                            // Value is missing.  Try to pull it from the class definition.\n                            // Attempt to pull a reference to the class parameters definitions dataset\n                            var cDef_Parameters = msg.payload[\"CDef_Parameters_Pivoted\"];\n                            \n                            // Attempt to pull the module's class's parameter information\n                            tempFilterArray = cDef_Parameters.filter((element)=>{\n                                    if ((element !== null) && (element !== undefined)){\n                                        return (element.ClassName === className_i);\n                                    }\n                                });\n                            \n                            // Check is anything was returned\n                            if(tempFilterArray.length > 0) {\n                                // Cache a reference to the current module's class parameters definition\n                                var cDef_Class_i = tempFilterArray[0];\n                                \n                                // Attempt to pull the given parameter in the class parameters definitions dataset\n                                tempFilterArray = cDef_Class_i.Parameters.filter((element)=>{\n                                        if ((element !== null) && (element !== undefined)){\n                                            return (element.ParameterName === parameterName);\n                                        }\n                                    });\n                                \n                                // Check is anything was returned\n                                if(tempFilterArray.length > 0) {\n                                    // Cache a reference to the class definition's parameter\n                                    var cDef_Parameter_i = tempFilterArray[0];\n                                    \n                                    // Pull the data type and the default value\n                                    var dataType_i = cDef_Parameter_i.DataType;\n                                    returnValue = cDef_Parameter_i.DefaultValue;\n                                    \n                                    // Test if the return value is missing or not\n                                    if ((returnValue === null) || (returnValue === undefined)) {\n                                        // Value is missing.  Provide a default value.\n                                        // TODO: Vary default return value by datatype?\n                                        returnValue = \"\";\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Return the result\n    return returnValue;\n}\n\nfunction ResolveNonCodeReferences(controllerName, moduleTagName, stringToResolve) {\n    // This function resolves all non-code find and replace markers into their requested values\n    // This function currently supports the following non-code markers:\n    //  1) {This[ParameterName]}\n    //\n    // FUTURE:\n    // Might want to consider adding support for:\n    //  1) {If[Condition ? ValueIfTrue : ValueIfFalse]}\n    \n    // Default the return value\n    var returnValue = stringToResolve.toString();\n    \n    // Reduce the raw branch code snippet down as much as possible\n    // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n    var reNonCode = RegExp(NonCodeDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reNonCode.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Pull the next match\n        var match = reNonCode.exec(returnValue);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Perform find & replace based on the operator type\n            var replaceText = null;\n            switch(operator) {\n                case ThisKeyword:\n                    // Do a parameter lookup.\n                    var lookupResult = GetParameter(controllerName, moduleTagName, operand);\n                    \n                    // Test if snippet was found\n                    if ((lookupResult !== null) && (lookupResult !== undefined)) {\n                        // Parameter was found.  Use the parameters value.\n                        replaceText = lookupResult;\n                    }\n                    else {\n                        // Parameter was NOT found.  Remove the curly braces & put the find and replace marker back in its place.\n                        replaceText = wholeMatch.substring(1, wholeMatch.length - 1);\n                    }\n                    break;\n            }\n            \n            // Test if there is a replacement string\n            if ((replaceText !== null) && (replaceText !== undefined)) {\n                // Perform the replacement\n                returnValue = returnValue.substring(0, match.index) + replaceText + returnValue.substring(reNonCode.lastIndex)\n                \n                // Start the RegExp's pointer to start scanning at the beginning of the last match\n                // This is done in case the replacement also contains matches that need replacing\n                reNonCode.lastIndex = match.index;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Return the result\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 1623.515625,
    "y": 76,
    "wires": [
      [
        "5ba6fdc9.aeb7cc",
        "e71b1719.d1df58",
        "66c136d2.c9ce28",
        "b1426512.169a18",
        "ecfbc04d.6e44c8",
        "9c4f1f7.4efb2e",
        "197ab9bb.bdc016"
      ]
    ]
  },
  {
    "id": "5ba6fdc9.aeb7cc",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Map Log to Payload",
    "func": "msg.payload = msg.log;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1849.78125,
    "y": 314.2498779296875,
    "wires": [
      []
    ]
  },
  {
    "id": "e71b1719.d1df58",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Map Trace Log to Payload",
    "func": "msg.payload = msg.traceLog;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1869.78125,
    "y": 349.7498779296875,
    "wires": [
      []
    ]
  },
  {
    "id": "66c136d2.c9ce28",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Map Validation Errors to Payload",
    "func": "msg.payload = msg.validationErrors;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1888.78125,
    "y": 385.2499084472656,
    "wires": [
      []
    ]
  },
  {
    "id": "39cdbd0.c9d72c4",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Generate RSLogix 5000 CSV Moustache Template",
    "func": "// This functions generates a moustache template for rendering the JSON structure for controller tags to an RSLogix 5000 CSV\n// \n// \n\n/*{\n    \"ControllerTags\":[\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    ]\n}*/\n\n// Default the return value\nvar returnValue = \"\";\n\n// TODO: Update with current timestamp and custom other version info\n// TODO: unescape special characters into RSLogix syntax (i.e. \\r, \\n, \\t, ', \", etc)\n\n// Build the document header\nreturnValue = returnValue + \"remark,\\\"CSV-Import-Export\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Date = Thu Nov 03 21:57:14 2016\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Version = RSLogix 5000 v20.01\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Owner = Avid\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Company = Avid Solutions\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"0.3\" + \"\\r\\n\";\nreturnValue = returnValue + \"\\\"TYPE\\\",\\\"SCOPE\\\",\\\"NAME,\\\"DESCRIPTION\\\",\\\"DATATYPE\\\",\\\"SPECIFIER\\\",\\\"ATTRIBUTES\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"{{#ControllerTags}}\";\nreturnValue = returnValue + \"\\\"{{{Controller}}}\\\",\\\"{{{Scope}}}\\\",\\\"{{{TagName}}}\\\",\\\"{{{Description}}}\\\",\\\"{{{DataType}}}\\\",\\\"{{{Specifier}}}\\\",\\\"{{{Attributes}}}\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"{{/ControllerTags}}\";\n\nmsg.template = returnValue;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2633.265625,
    "y": 802,
    "wires": [
      [
        "fb8562cb.5015d8"
      ]
    ]
  },
  {
    "id": "ecfbc04d.6e44c8",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1615.765625,
    "y": 145,
    "wires": []
  },
  {
    "id": "b1426512.169a18",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1655.765625,
    "y": 111,
    "wires": []
  },
  {
    "id": "fb8562cb.5015d8",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "template",
    "x": 2986.765625,
    "y": 805.0000305175781,
    "wires": []
  },
  {
    "id": "e5d2ad6e.6638e8",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "false",
    "x": 2820.765625,
    "y": 280.0000305175781,
    "wires": []
  },
  {
    "id": "e27fb26b.9b7cc",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Pull the next index",
    "func": "// This function pulls the next unique item from the incoming DistinctItems dataset\n//  to use to filter the incoming main dataset\n\n\n// Test if this is the first execution\nif (msg.i == 0) {\n    // First execution.  Push the incoming payload to this node's context\n    context.originalPayload = msg.payload;\n}\n\n// Cache off the length to the message for the downstream switch node\nmsg.length = context.originalPayload.DistinctItems.length;\n\n// Test if the index is still within the bounds of the array.\nif (msg.i < context.originalPayload.DistinctItems.length) {\n    // There are still items to iterate.\n    // Cache a reference to the current distinct item\n    var distinctItem_i = context.originalPayload.DistinctItems[msg.i];\n    \n    // Filter the original main dataset down to just the items matching the current distinct item.\n    var tempFilterArray = context.originalPayload.ControllerTags.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.Controller == distinctItem_i.Controller);\n            }\n        });\n    \n    // Set the return payload to an empty value\n    msg.payload = tempFilterArray;\n    \n    // Set the filename to use.\n    //TODO: remove invalid filename characters\n    msg.filename = \"ControllerTags-\" + distinctItem_i.Controller + \".csv\";\n}\nelse{\n    // There are no more items to iterate.\n    // Set the return payload to an empty value.\n    msg.payload = [];\n    \n    // Set the filename to use.\n    msg.filename = null;\n}\n\n// Return result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2651.111297607422,
    "y": 205.02777862548828,
    "wires": [
      [
        "34e9b046.ecc0e",
        "e5d2ad6e.6638e8",
        "44e3dd75.94013c"
      ]
    ]
  },
  {
    "id": "cae404a6.7eca4",
    "type": "template",
    "z": "b8aa44e1.6124b",
    "name": "i=0",
    "field": "i",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "0",
    "x": 2443.111297607422,
    "y": 205.1388931274414,
    "wires": [
      [
        "e27fb26b.9b7cc"
      ]
    ]
  },
  {
    "id": "34e9b046.ecc0e",
    "type": "switch",
    "z": "b8aa44e1.6124b",
    "name": "i<length",
    "property": "i",
    "propertyType": "msg",
    "rules": [
      {
        "t": "lt",
        "v": "length",
        "vt": "msg"
      },
      {
        "t": "else"
      }
    ],
    "checkall": "false",
    "outputs": 2,
    "x": 2864.111328125,
    "y": 215.13888549804688,
    "wires": [
      [
        "fd4d9653.1db21"
      ],
      [
        "68ba104b.126c6"
      ]
    ]
  },
  {
    "id": "bfb6fcf0.58d838",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "i++",
    "func": "msg.i++;\nmsg.payload = null;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2855.111328125,
    "y": 159.13888549804688,
    "wires": [
      [
        "e27fb26b.9b7cc"
      ]
    ]
  },
  {
    "id": "68ba104b.126c6",
    "type": "template",
    "z": "b8aa44e1.6124b",
    "name": "Loop Finished",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "Loop Finished",
    "x": 3067.349281311035,
    "y": 259.0079174041748,
    "wires": [
      []
    ]
  },
  {
    "id": "1436542e.e463fc",
    "type": "join",
    "z": "b8aa44e1.6124b",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 1408,
    "y": 77,
    "wires": [
      [
        "758ae508.8415cc",
        "da6960b1.12b25"
      ]
    ]
  },
  {
    "id": "fd4d9653.1db21",
    "type": "template",
    "z": "b8aa44e1.6124b",
    "name": "Render Tags CSV",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "remark,\"CSV-Import-Export\"\nremark,\"Date = Thu Nov 03 21:57:14 2016\"\nremark,\"Version = RSLogix 5000 v20.01\"\nremark,\"Owner = Avid\"\nremark,\"Company = Avid Solutions\"\n0.3\n\"TYPE\",\"SCOPE\",\"NAME,\"DESCRIPTION\",\"DATATYPE\",\"SPECIFIER\",\"ATTRIBUTES\"\n{{#ControllerTags}}\n\"{{{Controller}}}\",\"{{{Scope}}}\",\"{{{TagName}}}\",\"{{{Description}}}\",\"{{{DataType}}}\",\"{{{Specifier}}}\",\"{{{Attributes}}}\"\n{{/ControllerTags}}",
    "x": 3074.0001220703125,
    "y": 207.00003051757812,
    "wires": [
      [
        "df7dc494.95f368",
        "bfb6fcf0.58d838",
        "284c415.f3265be"
      ]
    ]
  },
  {
    "id": "df7dc494.95f368",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "payload",
    "x": 3336.9998779296875,
    "y": 249.00003051757812,
    "wires": []
  },
  {
    "id": "64b5e978.82ae9",
    "type": "link in",
    "z": "bee1119e.c0aa7",
    "name": "Main Flow Trigger Input",
    "links": [
      "8b30a9a4.14ce1",
      "b4eea6b.995f258",
      "e379dc19.5a873",
      "a5b03e5.4e3594"
    ],
    "x": 220,
    "y": 145,
    "wires": [
      [
        "f5a10015.3b70f8",
        "78cc4446.027fdc"
      ]
    ]
  },
  {
    "id": "8b30a9a4.14ce1",
    "type": "link out",
    "z": "9f396a53.0d3728",
    "name": "Pull Data: Main Flow Trigger",
    "links": [
      "64b5e978.82ae9"
    ],
    "x": 136,
    "y": 267,
    "wires": []
  },
  {
    "id": "210e1f8b.33818",
    "type": "inject",
    "z": "9f396a53.0d3728",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 92,
    "y": 227,
    "wires": [
      [
        "8b30a9a4.14ce1"
      ]
    ]
  },
  {
    "id": "4edb3a86.b0b414",
    "type": "comment",
    "z": "9f396a53.0d3728",
    "name": "Main Trigger",
    "info": "",
    "x": 75,
    "y": 184,
    "wires": []
  },
  {
    "id": "cec841a.ed8b44",
    "type": "comment",
    "z": "b8aa44e1.6124b",
    "name": "Main Trigger",
    "info": "",
    "x": 79,
    "y": 133,
    "wires": []
  },
  {
    "id": "2763444d.bc4ce4",
    "type": "inject",
    "z": "b8aa44e1.6124b",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 96,
    "y": 176,
    "wires": [
      [
        "b4eea6b.995f258"
      ]
    ]
  },
  {
    "id": "b4eea6b.995f258",
    "type": "link out",
    "z": "b8aa44e1.6124b",
    "name": "Pull Data: Main Flow Trigger",
    "links": [
      "64b5e978.82ae9"
    ],
    "x": 140,
    "y": 216,
    "wires": []
  },
  {
    "id": "7ef3898c.a912c8",
    "type": "inject",
    "z": "c95acbde.d1f77",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 100,
    "y": 210,
    "wires": [
      [
        "e379dc19.5a873"
      ]
    ]
  },
  {
    "id": "e379dc19.5a873",
    "type": "link out",
    "z": "c95acbde.d1f77",
    "name": "Pull Data: Main Flow Trigger",
    "links": [
      "64b5e978.82ae9"
    ],
    "x": 144,
    "y": 250,
    "wires": []
  },
  {
    "id": "9d8154ca.eb32c",
    "type": "comment",
    "z": "c95acbde.d1f77",
    "name": "Main Trigger",
    "info": "",
    "x": 83,
    "y": 167,
    "wires": []
  },
  {
    "id": "226e1906.9147ae",
    "type": "inject",
    "z": "b8aa44e1.6124b",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 2829.0001220703125,
    "y": 405,
    "wires": [
      [
        "a5b03e5.4e3594"
      ]
    ]
  },
  {
    "id": "a5b03e5.4e3594",
    "type": "link out",
    "z": "b8aa44e1.6124b",
    "name": "Pull Data: Main Flow Trigger",
    "links": [
      "64b5e978.82ae9"
    ],
    "x": 2873.0001220703125,
    "y": 445,
    "wires": []
  },
  {
    "id": "54b68985.a6f29",
    "type": "comment",
    "z": "b8aa44e1.6124b",
    "name": "Main Trigger",
    "info": "",
    "x": 2812.0001220703125,
    "y": 362,
    "wires": []
  },
  {
    "id": "9c4f1f7.4efb2e",
    "type": "sqlite-query",
    "z": "b8aa44e1.6124b",
    "name": "Distinct Controllers",
    "sheetname": "DistinctItems",
    "func": "SELECT DISTINCT [Controller]\nFROM [ControllerTags];",
    "noerr": 0,
    "sheets": [
      {
        "sheetname": "DistinctControllers"
      }
    ],
    "x": 1890.7664794921875,
    "y": 111.61666870117188,
    "wires": [
      [
        "c9ee49d7.22a23",
        "197ab9bb.bdc016"
      ]
    ]
  },
  {
    "id": "dac4c6d0.d3d6a8",
    "type": "function",
    "z": "b8aa44e1.6124b",
    "name": "Generate RSLogix 5000 CSV Moustache Template",
    "func": "// This functions generates a moustache template for rendering the JSON structure for controller tags to an RSLogix 5000 CSV\n// \n// \n\n/*{\n    \"ControllerTags\":[\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    ]\n}*/\n\n// Default the return value\nvar returnValue = \"\";\n\n// TODO: Update with current timestamp and custom other version info\n// TODO: unescape special characters into RSLogix syntax (i.e. \\r, \\n, \\t, ', \", etc)\n\n// Build the document header\nreturnValue = returnValue + \"remark,\\\"CSV-Import-Export\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Date = Thu Nov 03 21:57:14 2016\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Version = RSLogix 5000 v20.01\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Owner = Avid\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"remark,\\\"Company = Avid Solutions\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"0.3\" + \"\\r\\n\";\nreturnValue = returnValue + \"\\\"TYPE\\\",\\\"SCOPE\\\",\\\"NAME,\\\"DESCRIPTION\\\",\\\"DATATYPE\\\",\\\"SPECIFIER\\\",\\\"ATTRIBUTES\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"{{#ControllerTags}}\";\nreturnValue = returnValue + \"\\\"{{{Controller}}}\\\",\\\"{{{Scope}}}\\\",\\\"{{{TagName}}}\\\",\\\"{{{Description}}}\\\",\\\"{{{DataType}}}\\\",\\\"{{{Specifier}}}\\\",\\\"{{{Attributes}}}\\\"\" + \"\\r\\n\";\nreturnValue = returnValue + \"{{/ControllerTags}}\";\n\nmsg.template = returnValue;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1989.550048828125,
    "y": 211.88333129882812,
    "wires": [
      []
    ]
  },
  {
    "id": "c9ee49d7.22a23",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1894.5499267578125,
    "y": 147.88333129882812,
    "wires": []
  },
  {
    "id": "197ab9bb.bdc016",
    "type": "combine_dataset",
    "z": "b8aa44e1.6124b",
    "count": 2,
    "sheets": [
      {
        "sheetname": "DistinctControllers"
      }
    ],
    "x": 2149.7664794921875,
    "y": 72.38333129882812,
    "wires": [
      [
        "cae404a6.7eca4"
      ]
    ]
  },
  {
    "id": "44e3dd75.94013c",
    "type": "debug",
    "z": "b8aa44e1.6124b",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "filename",
    "x": 2829.5836181640625,
    "y": 315.8833312988281,
    "wires": []
  },
  {
    "id": "284c415.f3265be",
    "type": "upload_file",
    "z": "b8aa44e1.6124b",
    "filename": "aaControllerTags.csv",
    "name": "",
    "x": 3366.7666015625,
    "y": 199.85000610351562,
    "wires": [
      []
    ]
  },
  {
    "id": "c0f72b0e.b3a0a",
    "type": "file",
    "z": "b8aa44e1.6124b",
    "name": "",
    "filename": "",
    "appendNewline": true,
    "createDir": false,
    "overwriteFile": "false",
    "x": 3317.7666015625,
    "y": 300.4666442871094,
    "wires": []
  },
  {
    "id": "74f55f3f.11711",
    "type": "ui_dropdown",
    "z": "bee1119e.c0aa7",
    "name": "",
    "label": "",
    "group": "5d8da11d.33533",
    "order": 0,
    "width": 0,
    "height": 0,
    "passthru": true,
    "options": [
      {
        "label": "",
        "value": "",
        "type": "str"
      }
    ],
    "payload": "",
    "topic": "",
    "x": 709,
    "y": 96,
    "wires": [
      []
    ]
  },
  {
    "id": "56cff142.223ad",
    "type": "function",
    "z": "bee1119e.c0aa7",
    "name": "Create UiOptions Dataset",
    "func": "\nmsg.options = \n        \"ControllerFilter\": \"\",\n        \"TaskFilter\": \"\",\n        \"ProgramFilter\": \"\",\n        \"RoutineFilter\": \"\",\n        \"ClassNameFilter\": \"\",\n        \"ModuleTagNameFilter\": \"\"\n\n\nmsg.payload=\n{\n    \"UiOptions\": {\n        \"ControllerFilter\": \"\",\n        \"TaskFilter\": \"\",\n        \"ProgramFilter\": \"\",\n        \"RoutineFilter\": \"\",\n        \"ClassNameFilter\": \"\",\n        \"ModuleTagNameFilter\": \"\"\n    }\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 2,
    "x": 490,
    "y": 336,
    "wires": [
      []
    ]
  },
  {
    "id": "5fb4da0d.e13d24",
    "type": "ui_button",
    "z": "bee1119e.c0aa7",
    "name": "",
    "group": "5d8da11d.33533",
    "order": 0,
    "width": 0,
    "height": 0,
    "label": "Hello Andrew",
    "color": "",
    "icon": "",
    "payload": "",
    "payloadType": "str",
    "topic": "",
    "x": 135,
    "y": 219,
    "wires": [
      [
        "78cc4446.027fdc"
      ]
    ]
  }
]
