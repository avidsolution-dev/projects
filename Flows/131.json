[
  {
    "id": "cc0e7210.bd493",
    "type": "tab",
    "label": "Main Flow"
  },
  {
    "id": "98969df7.44714",
    "type": "tab",
    "label": "Pull & Manipulate Data Flow"
  },
  {
    "id": "55ffc120.e954e",
    "type": "tab",
    "label": "PLC Main Flow"
  },
  {
    "id": "f0bcf6de.677618",
    "type": "subflow",
    "name": "Get IO List",
    "info": "",
    "in": [
      {
        "x": 60,
        "y": 60,
        "wires": [
          {
            "id": "cc79c894.adc448"
          }
        ]
      }
    ],
    "out": [
      {
        "x": 740,
        "y": 60,
        "wires": [
          {
            "id": "60e3675e.b96588",
            "port": 0
          }
        ]
      }
    ]
  },
  {
    "id": "99c1c432.c1fc88",
    "type": "subflow",
    "name": "Get Program Structure",
    "info": "",
    "in": [
      {
        "x": 60,
        "y": 60,
        "wires": [
          {
            "id": "9b2da141.263f6"
          }
        ]
      }
    ],
    "out": [
      {
        "x": 740,
        "y": 60,
        "wires": [
          {
            "id": "d235730a.41a26",
            "port": 0
          }
        ]
      }
    ]
  },
  {
    "id": "cacb891a.58e9d8",
    "type": "subflow",
    "name": "Get Class Defs",
    "info": "",
    "in": [
      {
        "x": 60,
        "y": 60,
        "wires": [
          {
            "id": "670630c.6972bd"
          }
        ]
      }
    ],
    "out": [
      {
        "x": 740,
        "y": 60,
        "wires": [
          {
            "id": "4761c34e.e193dc",
            "port": 0
          }
        ]
      }
    ]
  },
  {
    "id": "1f8d1d0a.6392f3",
    "type": "subflow",
    "name": "Get Module Data",
    "info": "",
    "in": [
      {
        "x": 60,
        "y": 60,
        "wires": [
          {
            "id": "5e9cf09b.e6687"
          }
        ]
      }
    ],
    "out": [
      {
        "x": 740,
        "y": 60,
        "wires": [
          {
            "id": "a06bae25.22a8e",
            "port": 0
          }
        ]
      }
    ]
  },
  {
    "id": "3ba1c647.7c13ba",
    "type": "ui_group",
    "name": "Group 2",
    "tab": "86e0549b.d44a98",
    "order": 3,
    "disp": true,
    "width": 6
  },
  {
    "id": "f61bdb8b.aba098",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "69e45288.48602c",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "9662e297.da3ac",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "8b475aac.490a28",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "38fe5519.29784a",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "5f409259.63df9c",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "beec9730.144a38",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "5df7a663.8d7308",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "4e530167.ac4be",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "feb7fbfc.47ccd8",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "218aa90f.f73d96",
    "type": "ui_group",
    "z": "",
    "name": "Commands",
    "tab": "69e45288.48602c",
    "order": 2,
    "disp": true,
    "width": "6"
  },
  {
    "id": "7b4ab397.65781c",
    "type": "ui_group",
    "name": "Group 3",
    "tab": "86e0549b.d44a98",
    "order": 4,
    "disp": true,
    "width": 6
  },
  {
    "id": "b0c05952.146bb8",
    "type": "ui_group",
    "z": "",
    "name": "Rendering Test",
    "tab": "8b475aac.490a28",
    "order": 4,
    "disp": true,
    "width": "15"
  },
  {
    "id": "2071225e.46f75e",
    "type": "ui_group",
    "z": "",
    "name": "Examples",
    "tab": "86e0549b.d44a98",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "3208d380.4eb32c",
    "type": "ui_group",
    "z": "",
    "name": "Filtering Options",
    "tab": "69e45288.48602c",
    "order": 3,
    "disp": true,
    "width": "15"
  },
  {
    "id": "69e45288.48602c",
    "type": "ui_tab",
    "z": "",
    "name": "Home",
    "icon": "dashboard",
    "order": 1
  },
  {
    "id": "8b475aac.490a28",
    "type": "ui_tab",
    "z": "",
    "name": "PLC",
    "icon": "dashboard",
    "order": 2
  },
  {
    "id": "5f409259.63df9c",
    "type": "ui_tab",
    "z": "",
    "name": "HMI",
    "icon": "dashboard",
    "order": 3
  },
  {
    "id": "5df7a663.8d7308",
    "type": "ui_tab",
    "z": "",
    "name": "Docs",
    "icon": "dashboard",
    "order": 4
  },
  {
    "id": "feb7fbfc.47ccd8",
    "type": "ui_tab",
    "z": "",
    "name": "Drawings",
    "icon": "dashboard",
    "order": 5
  },
  {
    "id": "564573e.fe8568c",
    "type": "ui_group",
    "z": "",
    "name": "Logs",
    "tab": "69e45288.48602c",
    "disp": true,
    "width": "40"
  },
  {
    "id": "17418dd3.09b3e2",
    "type": "ui_group",
    "z": "",
    "name": "Log Live2",
    "tab": "8476abb4.8ce9a8",
    "order": 2,
    "disp": true,
    "width": "12"
  },
  {
    "id": "f8175dbb.7a3a8",
    "type": "ui_group",
    "name": "Group 2",
    "tab": "86e0549b.d44a98",
    "order": 3,
    "disp": true,
    "width": 6
  },
  {
    "id": "3705cd53.5cb002",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "7558aef.cc5a55",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "8840a694.610148",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "4846dc2b.4ae784",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "9e21134b.d2c5c",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "e1ffb48.05c0f48",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "b132b655.df8598",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "26ad7abd.8b5e76",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "c9d21ed0.81df7",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "6384241d.25d9ec",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "d1e6a24.0c6556",
    "type": "ui_group",
    "z": "",
    "name": "Commands",
    "tab": "7558aef.cc5a55",
    "order": 2,
    "disp": true,
    "width": "6"
  },
  {
    "id": "d89c5af0.f2f1a8",
    "type": "ui_group",
    "name": "Group 3",
    "tab": "86e0549b.d44a98",
    "order": 4,
    "disp": true,
    "width": 6
  },
  {
    "id": "f199ac48.2ec4f",
    "type": "ui_group",
    "z": "",
    "name": "Rendering Test",
    "tab": "4846dc2b.4ae784",
    "order": 4,
    "disp": true,
    "width": "15"
  },
  {
    "id": "213c7816.468708",
    "type": "ui_group",
    "z": "",
    "name": "Examples",
    "tab": "86e0549b.d44a98",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "a09bd324.aa7ed",
    "type": "ui_group",
    "z": "",
    "name": "Filtering Options",
    "tab": "7558aef.cc5a55",
    "order": 3,
    "disp": true,
    "width": "15"
  },
  {
    "id": "7558aef.cc5a55",
    "type": "ui_tab",
    "z": "",
    "name": "Home",
    "icon": "dashboard",
    "order": 1
  },
  {
    "id": "4846dc2b.4ae784",
    "type": "ui_tab",
    "z": "",
    "name": "PLC",
    "icon": "dashboard",
    "order": 2
  },
  {
    "id": "e1ffb48.05c0f48",
    "type": "ui_tab",
    "z": "",
    "name": "HMI",
    "icon": "dashboard",
    "order": 3
  },
  {
    "id": "26ad7abd.8b5e76",
    "type": "ui_tab",
    "z": "",
    "name": "Docs",
    "icon": "dashboard",
    "order": 4
  },
  {
    "id": "6384241d.25d9ec",
    "type": "ui_tab",
    "z": "",
    "name": "Drawings",
    "icon": "dashboard",
    "order": 5
  },
  {
    "id": "556a3fa2.912a6",
    "type": "ui_group",
    "z": "",
    "name": "Logs",
    "tab": "7558aef.cc5a55",
    "disp": true,
    "width": "40"
  },
  {
    "id": "30ab9b50.1bc924",
    "type": "ui_group",
    "z": "",
    "name": "Log Live2",
    "tab": "8476abb4.8ce9a8",
    "order": 2,
    "disp": true,
    "width": "12"
  },
  {
    "id": "39e4254b.f1e47a",
    "type": "ui_group",
    "name": "Group 2",
    "tab": "86e0549b.d44a98",
    "order": 3,
    "disp": true,
    "width": 6
  },
  {
    "id": "79b8ad16.4686e4",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "57ef72eb.810acc",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "79c4777c.118978",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "8f34a76b.a6a518",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "6ee74321.65afdc",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "ef122ed2.2bbc9",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "a9660496.939cd8",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "e5b4f2ec.73d09",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "b7679308.13b54",
    "type": "ui_group",
    "z": "",
    "name": "Navigation",
    "tab": "6b78ce9e.97df9",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "e940ae38.2f975",
    "type": "ui_group",
    "z": "",
    "name": "Commands",
    "tab": "57ef72eb.810acc",
    "order": 2,
    "disp": true,
    "width": "6"
  },
  {
    "id": "cf08fec0.56d93",
    "type": "ui_group",
    "name": "Group 3",
    "tab": "86e0549b.d44a98",
    "order": 4,
    "disp": true,
    "width": 6
  },
  {
    "id": "9e349688.8c0858",
    "type": "ui_group",
    "z": "",
    "name": "Rendering Test",
    "tab": "8f34a76b.a6a518",
    "order": 4,
    "disp": true,
    "width": "15"
  },
  {
    "id": "cead15f7.742d88",
    "type": "ui_group",
    "z": "",
    "name": "Examples",
    "tab": "86e0549b.d44a98",
    "order": 1,
    "disp": true,
    "width": "6"
  },
  {
    "id": "b788c0f2.f55b6",
    "type": "ui_group",
    "z": "",
    "name": "Filtering Options",
    "tab": "57ef72eb.810acc",
    "order": 3,
    "disp": true,
    "width": "15"
  },
  {
    "id": "57ef72eb.810acc",
    "type": "ui_tab",
    "z": "",
    "name": "Home",
    "icon": "dashboard",
    "order": 1
  },
  {
    "id": "8f34a76b.a6a518",
    "type": "ui_tab",
    "z": "",
    "name": "PLC",
    "icon": "dashboard",
    "order": 2
  },
  {
    "id": "ef122ed2.2bbc9",
    "type": "ui_tab",
    "z": "",
    "name": "HMI",
    "icon": "dashboard",
    "order": 3
  },
  {
    "id": "e5b4f2ec.73d09",
    "type": "ui_tab",
    "z": "",
    "name": "Docs",
    "icon": "dashboard",
    "order": 4
  },
  {
    "id": "6b78ce9e.97df9",
    "type": "ui_tab",
    "z": "",
    "name": "Drawings",
    "icon": "dashboard",
    "order": 5
  },
  {
    "id": "ad66aa50.9454c8",
    "type": "ui_group",
    "z": "",
    "name": "Logs",
    "tab": "57ef72eb.810acc",
    "disp": true,
    "width": "40"
  },
  {
    "id": "b0870125.ed4e3",
    "type": "ui_group",
    "z": "",
    "name": "Log Live2",
    "tab": "8476abb4.8ce9a8",
    "order": 2,
    "disp": true,
    "width": "12"
  },
  {
    "id": "75d4765d.91dd58",
    "type": "inject",
    "z": "cc0e7210.bd493",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": true,
    "x": 250,
    "y": 120,
    "wires": [
      [
        "cf71d026.33f78"
      ]
    ]
  },
  {
    "id": "2d743745.75e2b8",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Initiate Flow",
    "info": "",
    "x": 250.66665649414062,
    "y": 73.99999761581421,
    "wires": []
  },
  {
    "id": "9189d9c8.cb5b48",
    "type": "link out",
    "z": "cc0e7210.bd493",
    "name": "Main Trigger Output",
    "links": [
      "388f2059.2b812"
    ],
    "x": 735,
    "y": 280,
    "wires": []
  },
  {
    "id": "5b6ecc0c.75e654",
    "type": "link in",
    "z": "cc0e7210.bd493",
    "name": "Main Flow Trigger Input",
    "links": [
      "41a6bf9a.075e5",
      "dec566da.186c58",
      "29d9cd4.25b5f32",
      "22b75549.ffe93a"
    ],
    "x": 195,
    "y": 360,
    "wires": [
      [
        "4356c592.a66fbc"
      ]
    ]
  },
  {
    "id": "40dffbaa.b74ba4",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Triggers",
    "info": "",
    "x": 240,
    "y": 320,
    "wires": []
  },
  {
    "id": "ace35168.10b6c",
    "type": "inject",
    "z": "cc0e7210.bd493",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 240,
    "y": 500,
    "wires": [
      [
        "cfc4662e.a94a68"
      ]
    ]
  },
  {
    "id": "c4448ccd.6d439",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Initiate Get Messages",
    "info": "",
    "x": 280,
    "y": 460,
    "wires": []
  },
  {
    "id": "a5c06d25.c5362",
    "type": "debug",
    "z": "cc0e7210.bd493",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "log",
    "x": 1100,
    "y": 540,
    "wires": []
  },
  {
    "id": "6c4ffb22.67df94",
    "type": "debug",
    "z": "cc0e7210.bd493",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "validationErrors",
    "x": 1140,
    "y": 620,
    "wires": []
  },
  {
    "id": "7fda648b.a3d28c",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Pull & Filter Datasets",
    "info": "",
    "x": 820,
    "y": 240,
    "wires": []
  },
  {
    "id": "964722e6.6e518",
    "type": "link in",
    "z": "cc0e7210.bd493",
    "name": "Pull Logged Messages",
    "links": [
      "87a09bda.427bd8",
      "e287bac2.855bf8",
      "168c9f44.d9e911",
      "a9bedff7.9883b",
      "34fdff49.ac28d"
    ],
    "x": 195,
    "y": 540,
    "wires": [
      [
        "cfc4662e.a94a68"
      ]
    ]
  },
  {
    "id": "21f3cbd6.161f74",
    "type": "inject",
    "z": "cc0e7210.bd493",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 240,
    "y": 280,
    "wires": [
      [
        "4356c592.a66fbc"
      ]
    ]
  },
  {
    "id": "e7a9cbae.e21958",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Initiate Flow",
    "info": "",
    "x": 250,
    "y": 240,
    "wires": []
  },
  {
    "id": "c24d31fe.f36fc",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Get Log and Validation Error Messages",
    "info": "",
    "x": 330,
    "y": 420,
    "wires": []
  },
  {
    "id": "34644238.81160e",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Clear Logs",
    "info": "",
    "x": 460,
    "y": 240,
    "wires": []
  },
  {
    "id": "cf71d026.33f78",
    "type": "function",
    "z": "cc0e7210.bd493",
    "name": "Load Basic Functions",
    "func": "// This function node is used to create common function expressions and store them to Node-RED's \n//  global context.  Downstream function nodes can pull them down using \n//  'var SomeFunction = global.get(\"SomeFunction\");' and subsequently call them as normal.\n// \n// Note: When these functions execute, they do NOT have access the the variable scope within the\n//  function blocks they are called from.  This means that they do NOT have access to the msg.xxx\n//  variables among other things.  All data modifications must be exchanged within the context of\n//  parameters passed into the fuction or returned from the function.\n\n// Set this node's status\n// Note: This is the ONLY where it is necessary to use the native status function \n//       because this is the routine that builds the wrapper function.\nnode.status({fill:\"green\",shape:\"ring\",text:\"Starting to load basic functions.\"});\n\n// Setup constants for lookups\nconst dayOfWeekNames = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\nconst dayOfWeekNamesAbbreviated = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\nconst monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\nconst monthNamesAbbreviated = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n/*\n*   Set the logging level to use:\n*       Level 0 = Error, ValidationError, & Custom Messages\n*       Level 1 = Level 0 + Info & Warning\n*       Level 2 = Level 1 + Debug\n*       Level 3 = Level 2 + Trace\n*       Level 4 = Level 3 + Verbose\n*/\nvar logLevel = 1;\nvar mainCallStackLevelForDeepDebugging = \"\";\nvar currentCallStackLevelForDeepDebugging = \"\";\nvar eventIdx = 0;\n\n//mainCallStackLevelForDeepDebugging = \"Process for Missing Data: Test\";\n//mainCallStackLevelForDeepDebugging = \"Get Usage Scenarios\";\n//mainCallStackLevelForDeepDebugging = \"Resolve Program Structure References\";\n//mainCallStackLevelForDeepDebugging = \"Get Controller Tags\";\n//mainCallStackLevelForDeepDebugging = \"Resolve Snippets to Commented Rungs\";\n//mainCallStackLevelForDeepDebugging = \"Render Program L5X\";\n//mainCallStackLevelForDeepDebugging = \"Render Routine L5X\";\n//mainCallStackLevelForDeepDebugging = \"Render Rung L5X\";\n//mainCallStackLevelForDeepDebugging = \"Build Interlocks Code Snippets & Comments\";\n//mainCallStackLevelForDeepDebugging = \"Merge Custom Datasets\";\n//mainCallStackLevelForDeepDebugging = \"Controller Tags Next Index\";\n//currentCallStackLevelForDeepDebugging = \"\";\n\n/*********************************************************/\n/*[{\n    \"timestamp\":Date.now(),\n    \"messageType\":messageType,\n    \"messageToLog\":messageToLog,\n    \"mainCallStackLevel\":mainCallStackLevel,\n    \"thisCallStackLevel\":thisCallStackLevel,\n    \"optionalAssociatedContext\":optionalAssociatedContext\n}]*/\nvar logMessage = function (thisCallStackLevel, messageType, messageToLog, optionalAssociatedContext) {\n    // Test if there is a node or function that needs special debugging\n    var ignoreMessageType = false;\n    if (mainCallStackLevelForDeepDebugging !== \"\") {\n        if (global.get(\"mainCallStackLevel\") == mainCallStackLevelForDeepDebugging) {\n            ignoreMessageType = true;\n        }\n    }\n    if (currentCallStackLevelForDeepDebugging !== \"\") {\n        if (thisCallStackLevel == currentCallStackLevelForDeepDebugging) {\n            ignoreMessageType = true;\n        }\n    }\n    \n    // Test if we need to log anything\n    if (!ignoreMessageType) {\n        switch (messageType){\n            // Level 0\n            case \"Error\":\n            case \"ValidationError\":\n                break;\n            \n            // Level 1\n            case \"Info\":\n            case \"Warning\":\n                if (logLevel < 1) {return;}     // Don't log\n                break;\n                \n            // Level 2\n            case \"Debug\":\n                if (logLevel < 2) {return;}     // Don't log\n                break;\n            \n            // Level 3\n            case \"Trace\":\n                if (logLevel < 3) {return;}     // Don't log\n                break;\n            \n            // Level 4\n            case \"Verbose\":\n                if (logLevel < 4) {return;}     // Don't log\n                break;\n        }\n    }\n    \n    // Pull the logs from the global context\n    var messageLogs = global.get(\"messageLogs\");\n    \n    // If they don't exist, create them\n    if ((messageLogs === null) || (messageLogs === undefined)) {\n        // Push an empty array back\n        global.set(\"messageLogs\", []);\n        \n        // Re-pull the logs from the global context\n        messageLogs = global.get(\"messageLogs\");\n    }\n    \n    var timestamp = now();\n    var options = {\n        year: \"numeric\",\n        month: \"numeric\",\n        day: \"numeric\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\",\n        hour12: false\n    };\n    \n    // Add the current message to the log\n    messageLogs.push({\n        \"eventIdx\":eventIdx,\n        \"timestamp\":timestamp.toLocaleString(\"en-us\", options),\n        \"messageType\":messageType,\n        \"messageToLog\":messageToLog,\n        \"mainCallStackLevel\":global.get(\"mainCallStackLevel\"),\n        \"thisCallStackLevel\":thisCallStackLevel,\n        \"optionalAssociatedContext\":optionalAssociatedContext\n    });\n    \n    // Increment the event index\n    eventIdx++;\n    \n    // Done\n    return;\n};\n/*********************************************************/\n\n\n/*********************************************************/\nvar logInfoMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"Info\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n\nvar logDebugMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"Debug\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n\nvar logTraceMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"Trace\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n\nvar logVerboseMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"Verbose\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n\nvar logWarningMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"Warning\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n\nvar logErrorMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"Error\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n\nvar logValidationErrorMessage = function (thisCallStackLevel, messageToLog, optionalAssociatedContext) {\n    // Call the log message function\n    logMessage(thisCallStackLevel, \"ValidationError\", messageToLog, optionalAssociatedContext);\n    \n    // Done\n    return;\n};\n/*********************************************************/\n\n\n/*********************************************************/\nvar setNodeStatus = function (nodeToUpdate, color, shape, statusMessage) {\n    // Catch invalid colors\n    switch (color) {\n        case \"red\":\n        case \"green\":\n        case \"yellow\":\n        case \"blue\":\n        case \"grey\":\n            // Valid options\n            break;\n            \n        default:\n            shape = \"grey\";\n            break;\n    }\n    \n    // Catch invalid shapes\n    switch (shape) {\n        case \"ring\":\n        case \"dot\":\n            // Valid options\n            break;\n            \n        default:\n            shape = \"dot\";\n            break;\n    }\n    \n    // Catch invalid messages\n    if ((statusMessage === null) || (statusMessage === undefined)) {\n        statusMessage = \"\";\n    }\n    \n    // Set the node's status\n    nodeToUpdate.status({fill:color, shape:shape, text:statusMessage});\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar now = function () {\n    return new Date(Date.now());\n};\n\nvar formatDate = function (date, format, useUtc) {\n    // Mimics the .NET Date.ToString(format) function\n    // Supports the following reduced set of format specifiers:\n    //      \"yy\"    The year, from 00 to 99.\n    //      \"yyy\"   The year, with a minimum of three digits.\n    //      \"yyyy\"  The year as a four-digit number.\n    //      \"M\"     The month, from 1 through 12.\n    //      \"MM\"    The month, from 01 through 12.\n    //      \"MMM\"   The abbreviated name of the month.\n    //      \"MMMM\"  The full name of the month.\n    //      \"d\"     The day of the month, from 1 through 31.\n    //      \"dd\"    The day of the month, from 01 through 31.\n    //      \"ddd\"   The abbreviated name of the day of the week.\n    //      \"dddd\"  The full name of the day of the week.\n    //      \"h\"     The hour, using a 12-hour clock from 1 to 12.\n    //      \"hh\"    The hour, using a 12-hour clock from 01 to 12.\n    //      \"H\"     The hour, using a 24-hour clock from 0 to 23.\n    //      \"HH\"    The hour, using a 24-hour clock from 00 to 23.\n    //      \"m\"     The minute, from 0 through 59.\n    //      \"mm\"    The minute, from 00 through 59.\n    //      \"s\"     The second, from 0 through 59.\n    //      \"ss\"    The second, from 00 through 59.\n    //      \"f\"     The tenths of a second in a date and time value.\n    //      \"ff\"    The hundredths of a second in a date and time value.\n    //      \"fff\"   The milliseconds in a date and time value.\n    //      \"tt\"    The AM/PM designator.\n    if (typeof date != 'object') {\n        // Not a date!  Return the original object\n        // Set this node's status\n        node.status({fill:\"red\",shape:\"ring\",text:\"typeof date = \" + typeof date});\n        return date;\n    }\n    else if (!typeof date.hasOwnProperty(\"getFullYear\")) {\n        // Not a date!  Return the original object\n        // Set this node's status\n        node.status({fill:\"red\",shape:\"ring\",text:\"typeof date = \" + typeof date});\n        return date;\n    }\n    \n    // Default to use local time if useUtc is invalid\n    if (typeof useUtc != 'boolean') {\n        // Not a boolean.  Use local time\n        useUtc = false;\n    }\n    \n    // Set the default return value\n    var returnValue = \"\";\n    \n    // Setup the RegExp for parseing the format string\n    var reFormatParser = /((?:d{1,4})|(?:f{1,3})|(?:h{1,2})|(?:H{1,2})|(?:m{1,2})|(?:M{1,4})|(?:s{1,2})|(?:t{2})|(?:y{2,5}))/g;\n    \n    // Get the parts of the date\n    var year = useUtc ? date.getUTCFullYear() : date.getFullYear();                 //Returns the year\n    var monthForLookup = useUtc ? date.getUTCMonth() : date.getMonth();\t            //Returns the month (from 0-11)\n    var month = monthForLookup + 1;\t                                                //Returns the month (from 1-12)\n    var day = useUtc ? date.getUTCDate() : date.getDate();                          //Returns the day of the month (from 1-31)\n    var dayOfWeekForLookup = useUtc ? date.getUTCDay() : date.getDay();\t            //Returns the day of the week (from 0-6)\n    var hour24 = useUtc ? date.getUTCHours() : date.getHours();\t                    //Returns the hour (from 0-23)\n    var hour12;\n    if (hour24 === 0) {hour12 = 12;}\n    else if (hour24 <= 12) {hour12 = hour24;}\n    else {hour12 = hour24 - 12;}                                                    //Returns the hour (from 1-12)\n    var minute = useUtc ? date.getUTCMinutes() : date.getMinutes();\t                //Returns the minutes (from 0-59)\n    var second = useUtc ? date.getUTCSeconds() : date.getSeconds();\t                //Returns the seconds (from 0-59)\n    var millisecond = useUtc ? date.getUTCMilliseconds() : date.getMilliseconds();  //Returns the milliseconds (from 0-999)\n    \n    // Declare temp variables\n    var wholeMatch = null;\n    var leftOfMatchString = \"\";\n    var rightOfMatchString = \"\";\n    \n    // Iterate the regex matches\n    reFormatParser.lastIndex = 0;\n    textToParse = format;\n    while ((match = reFormatParser.exec(textToParse)) !== null) {\n        // A match was found.\n        // Pull the match information\n        wholeMatch = match[0];\n        leftOfMatchString = textToParse.substring(0, match.index);\n        rightOfMatchString = textToParse.substring(reFormatParser.lastIndex);\n        \n        // Append the non-matching characters to the left of the regex match to the result.\n        returnValue = returnValue + leftOfMatchString;\n        \n        // Determine which date part to append to the result based on the regex match\n        var valueToAppend = \"\";\n        switch (wholeMatch) {\n            case \"yy\":      //The year, from 00 to 99.\n                valueToAppend = year % 100;\n                break;\n            case \"yyy\":      //The year, with a minimum of three digits.\n                valueToAppend = Number(year).toLocaleString(undefined, {\"minimumIntegerDigits\": 3});\n                break;\n            case \"yyyy\":    //The year as a four-digit number.\n                valueToAppend = year;\n                break;\n            case \"M\":       //The month, from 1 through 12.\n                valueToAppend = month;\n                break;\n            case \"MM\":      //The month, from 01 through 12.\n                valueToAppend = Number(month).toLocaleString(undefined, {\"minimumIntegerDigits\": 2});\n                break;\n            case \"MMM\":     //The abbreviated name of the month.\n                if (monthForLookup >= 0 && monthForLookup < monthNamesAbbreviated.length) {\n                    valueToAppend = monthNamesAbbreviated[monthForLookup];\n                }\n                break;\n            case \"MMMM\":    //The full name of the month.\n                if (monthForLookup >= 0 && monthForLookup < monthNames.length) {\n                    valueToAppend = monthNames[monthForLookup];\n                }\n                break;\n            case \"d\":       //The day of the month, from 1 through 31.\n                valueToAppend = day;\n                break;\n            case \"dd\":      //The day of the month, from 01 through 31.\n                valueToAppend = Number(day).toLocaleString(undefined, {\"minimumIntegerDigits\": 2});\n                break;\n            case \"ddd\":     //The abbreviated name of the day of the week.\n                if (dayOfWeekForLookup >= 0 && dayOfWeekForLookup < dayOfWeekNamesAbbreviated.length) {\n                    valueToAppend = dayOfWeekNamesAbbreviated[dayOfWeekForLookup];\n                }\n                break;\n            case \"dddd\":    //The full name of the day of the week.\n                if (dayOfWeekForLookup >= 0 && dayOfWeekForLookup < dayOfWeekNames.length) {\n                    valueToAppend = dayOfWeekNames[dayOfWeekForLookup];\n                }\n                break;\n            case \"h\":       //The hour, using a 12-hour clock from 1 to 12.\n                valueToAppend = hour12;\n                break;\n            case \"hh\":      //The hour, using a 12-hour clock from 01 to 12.\n                valueToAppend = Number(hour12).toLocaleString(undefined, {\"minimumIntegerDigits\": 2});\n                break;\n            case \"H\":       //The hour, using a 24-hour clock from 0 to 23.\n                valueToAppend = hour24;\n                break;\n            case \"HH\":      //The hour, using a 24-hour clock from 00 to 23.\n                valueToAppend = Number(hour24).toLocaleString(undefined, {\"minimumIntegerDigits\": 2});\n                break;\n            case \"m\":       //The minute, from 0 through 59.\n                valueToAppend = minute;\n                break;\n            case \"mm\":      //The minute, from 00 through 59.\n                valueToAppend = Number(minute).toLocaleString(undefined, {\"minimumIntegerDigits\": 2});\n                break;\n            case \"s\":       //The second, from 0 through 59.\n                valueToAppend = second;\n                break;\n            case \"ss\":      //The second, from 00 through 59.\n                valueToAppend = Number(second).toLocaleString(undefined, {\"minimumIntegerDigits\": 2});\n                break;\n            case \"f\":       //The tenths of a second in a date and time value.\n                valueToAppend = Math.trunc(millisecond / 100);\n                break;\n            case \"ff\":      //The hundredths of a second in a date and time value.\n                valueToAppend = Math.trunc(millisecond / 10);\n                break;\n            case \"fff\":     //The milliseconds in a date and time value.\n                valueToAppend = millisecond;\n                break;\n            case \"tt\":      //The AM/PM designator.\n                if (hour24 >= 0 && hour24 < 12) {valueToAppend = \"AM\";}\n                else if (hour24 >= 12 && hour24 < 24) {valueToAppend = \"PM\";}\n                break;\n            \n        }\n        \n        // Append the fortmatted date part to the result.\n        returnValue = returnValue + valueToAppend;\n        \n        // For the next loop around, strip off the regex match and start back at the beginning\n        reFormatParser.lastIndex = 0;\n        textToParse = rightOfMatchString;\n    }\n    \n    // Append the non-matching characters to the right of the last regex match to the result.\n        returnValue = returnValue + rightOfMatchString;\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar parseBoolean = function (value) {\n    var returnValue = null;\n    switch (typeof value) {\n        case \"boolean\":\n            returnValue = value;\n            break;\n            \n        case \"number\":\n            returnValue = (value !== 0);\n            break;\n        \n        case \"string\":\n            returnValue = (value.trim().toLowerCase() === 'true');\n            break;\n    }\n    return returnValue;\n};\n/*********************************************************/\n\n\n/*********************************************************/\nvar getUniqueKeyValues = function (objectArray, uniqueKeyAttrirbuteNamesArray) {\n    return objectArray.reduce(\n        function (p, c) {\n            // Iterate the list of column names that name up the unique key for this table\n            var keyValues = [];\n            for (var i = 0; i < uniqueKeyAttrirbuteNamesArray.length; i++){\n                keyValues.push(c[uniqueKeyAttrirbuteNamesArray[i]]);\n            }\n            // Create two keys with different delimiters to eliminate the possibility of having a duplicate key from the columns containing the delimiter in just the right pattern\n            var key1 = keyValues.join('|');\n            var key2 = keyValues.join('-');\n            if ((p.temp1.indexOf(key1) === -1) && (p.temp2.indexOf(key2) === -1)) {\n                var d = {};\n                for (i = 0; i < uniqueKeyAttrirbuteNamesArray.length; i++){\n                    d[uniqueKeyAttrirbuteNamesArray[i]] = c[uniqueKeyAttrirbuteNamesArray[i]];\n                }      \n                p.out.push(d);\n                p.temp1.push(key1);\n                p.temp2.push(key2);\n            }\n            return p;\n        },\n        {temp1: [], temp2: [], out: []}\n    ).out;\n};\n/*********************************************************/\n\n/*********************************************************/\nvar replaceInvalidCharactersInFileName = function (filename, replacementString) {\n    var returnValue = filename;\n    if (replacementString === null) {\n        replacementString = \"\";\n    }\n    /*\n    These are the invalid characters in a Windows filename:\n        \\ / : * ? \" < > |\n    */\n    if (returnValue !== null) {\n        returnValue = returnValue.replace(new RegExp(\"\\\\\\\\\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\"/\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\":\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\"\\\\*\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\"\\\\?\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\"\\\\\\\"\", 'g') ,replacementString);\n        returnValue = returnValue.replace(new RegExp(\"<\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\">\", 'g'), replacementString);\n        returnValue = returnValue.replace(new RegExp(\"\\\\|\", 'g'), replacementString);\n    }\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\n// Add future functions here\n/*********************************************************/\n\n\n\n// Store all locally created functions to the global context\nglobal.set(\"logMessage\", logMessage);                                   //function (thisCallStackLevel, messageType, messageToLog, optionalAssociatedContext)\nglobal.set(\"logInfoMessage\", logInfoMessage);                           //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"logDebugMessage\", logDebugMessage);                         //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"logTraceMessage\", logTraceMessage);                         //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"logVerboseMessage\", logVerboseMessage);                     //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"logWarningMessage\", logWarningMessage);                     //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"logErrorMessage\", logErrorMessage);                         //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"logValidationErrorMessage\", logValidationErrorMessage);     //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nglobal.set(\"setNodeStatus\", setNodeStatus);                             //function (node, color, shape, statusMessage) \nglobal.set(\"now\", now);                                                 //function ()\nglobal.set(\"formatDate\", formatDate);                                   //function (date, format)\nglobal.set(\"parseBoolean\", parseBoolean);                               //function (value)\nglobal.set(\"getUniqueKeyValues\", getUniqueKeyValues);                   //function (objectArray, uniqueKeyAttrirbuteNamesArray)\nglobal.set(\"replaceInvalidCharactersInFileName\", replaceInvalidCharactersInFileName);   //function (filename, replacementString)\n\n/*********************************************************/\n// Add future functions here\n/*********************************************************/\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done loading basic functions\");\n\n// Pass incoming message on\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 500,
    "y": 120,
    "wires": [
      [
        "c325aa81.1c0c48"
      ]
    ]
  },
  {
    "id": "8b9995d8.4fe6a8",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Load Functions To Global Context",
    "info": "During initial swap to global logging functions, the logging \n level filter had the following performance speeds for executing\n the entire flow:\n    Level 0 = 2 sec\n    Level 1 = 3 sec\n    Level 2 = 16 sec\n    Level 3 = 24 sec\n    Level 4 = 24 sec",
    "x": 540,
    "y": 80,
    "wires": []
  },
  {
    "id": "cfc4662e.a94a68",
    "type": "function",
    "z": "cc0e7210.bd493",
    "name": "Extract Logged Messages",
    "func": "var setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting to pull log messages.\");\n\n// Pull the logs from the global context\nvar messageLogs = global.get(\"messageLogs\");\n\n/*[{\n    \"timestamp\":Date.now(),\n    \"messageType\":messageType,\n    \"messageToLog\":messageToLog,\n    \"mainCallStackLevel\":mainCallStackLevel,\n    \"thisCallStackLevel\":thisCallStackLevel,\n    \"optionalAssociatedContext\":optionalAssociatedContext\n}]*/\n\n// Pass special characters on for the renderer to resolve.\nmsg.tab = \"\\t\";\nmsg.carriageReturn = \"\\r\";\nmsg.lineFeed = \"\\n\";\nmsg.newLine = \"\\r\\n\";\n\n// Test if there are any messages or not\nif ((messageLogs !== null) && (messageLogs !== undefined)) {\n    // Attempt to pull the normal log messages (everything but validation errors)\n    msg.log = messageLogs.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.messageType != \"ValidationError\");\n        }\n    });\n    \n    // Attempt to pull the validation error log messages\n    msg.validationErrors = messageLogs.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return (element.messageType == \"ValidationError\");\n        }\n    });\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Pass incoming message on\nreturn msg;",
    "outputs": "1",
    "noerr": 0,
    "x": 510,
    "y": 500,
    "wires": [
      [
        "15f1be4.2eca142",
        "ed15866.4894678",
        "ef24fc23.62ad3"
      ]
    ]
  },
  {
    "id": "c09a4f0c.abeb",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Retrieve Log Messages From Global Context",
    "info": "",
    "x": 570.6666564941406,
    "y": 453.9999976158142,
    "wires": []
  },
  {
    "id": "15f1be4.2eca142",
    "type": "template",
    "z": "cc0e7210.bd493",
    "name": "Render Messages",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "Index{{{tab}}}Timestamp{{{tab}}}Type{{{tab}}}Main Call{{{tab}}}Current Call{{{tab}}}Message\n{{#log}}\n{{{eventIdx}}}{{{tab}}}{{{timestamp}}}{{{tab}}}{{{messageType}}}{{{tab}}}{{{mainCallStackLevel}}}{{{tab}}}{{{thisCallStackLevel}}}{{{tab}}}{{{messageToLog}}}\n{{/log}}",
    "x": 870,
    "y": 500,
    "wires": [
      [
        "a5c06d25.c5362",
        "f43e7d6d.c4335"
      ]
    ]
  },
  {
    "id": "ed15866.4894678",
    "type": "template",
    "z": "cc0e7210.bd493",
    "name": "Render Messages",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "Timestamp{{{tab}}}Type{{{tab}}}Main Call{{{tab}}}Current Call{{{tab}}}Message\n{{#validationErrors}}\n{{{timestamp}}}{{{tab}}}{{{messageType}}}{{{tab}}}{{{mainCallStackLevel}}}{{{tab}}}{{{thisCallStackLevel}}}{{{tab}}}{{{messageToLog}}}\n{{/validationErrors}}",
    "x": 870,
    "y": 580,
    "wires": [
      [
        "6c4ffb22.67df94",
        "da32e613.2b8698"
      ]
    ]
  },
  {
    "id": "4356c592.a66fbc",
    "type": "function",
    "z": "cc0e7210.bd493",
    "name": "Clear Logged Messages",
    "func": "// Pull down referencs to global functions\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Push an empty array to the logs in the global context\nglobal.set(\"messageLogs\", []);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Pass incoming message on\nreturn msg;",
    "outputs": "1",
    "noerr": 0,
    "x": 510,
    "y": 280,
    "wires": [
      [
        "9189d9c8.cb5b48"
      ]
    ]
  },
  {
    "id": "cb4f4532.da17e8",
    "type": "comment",
    "z": "cc0e7210.bd493",
    "name": "Load Functions To Global Context",
    "info": "",
    "x": 860,
    "y": 80,
    "wires": []
  },
  {
    "id": "c325aa81.1c0c48",
    "type": "function",
    "z": "cc0e7210.bd493",
    "name": "Load Data Resolver Functions",
    "func": "// This function node is used to create common function expressions for data lookup and manipulation\n//  and store them to Node-RED's global context.  Downstream function nodes can pull them down using \n//  'var SomeFunction = global.get(\"SomeFunction\");' and subsequently call them as normal.\n// \n// Note: When these functions execute, they do NOT have access the the variable scope within the\n//  function blocks they are called from.  This means that they do NOT have access to the msg.xxx\n//  variables among other things.  All data modifications must be exchanged within the context of\n//  parameters passed into the fuction or returned from the function.\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting to load basic functions.\");\n\n// Set up the constants to use later\nconst endOfSegmentMarker = \";\";\nconst commentDelimiter = \"\\r\\n\";\n\nconst AllDynamicRefsRegex = \"{((?:This)|(?:ThisRoutine)|(?:ThisProgram)|(?:ThisTask)|(?:Code)|(?:RoutineCode)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";    // Operand CANNOT include { or }\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:RoutineCode)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t\t\t                                                // Operand CANNOT include { or }\nconst NonCodeDynamicRefsRegex = \"{((?:This)|(?:ThisRoutine)|(?:ThisProgram)|(?:ThisTask))\\\\[([^{}]+?)\\\\]}\";\t\t                                // Operand CANNOT include { or }\nconst CommentDynamicRefsRegex = \"{((?:Comment)|(?:RoutineComment)|(?:DerivedComment))\\\\[([^{}]+?)\\\\]}\";                                         // Operand CANNOT include { or }\n\nconst ThisKeyword = \"This\";\nconst ThisRoutineKeyword = \"ThisRoutine\";\nconst ThisProgramKeyword = \"ThisProgram\";\nconst ThisTaskKeyword = \"ThisTask\";\nconst CodeKeyword = \"Code\";\nconst RoutineCodeKeyword = \"RoutineCode\";\nconst DerivedKeyword = \"Derived\";\nconst CommentKeyword = \"Comment\";\nconst RoutineCommentKeyword = \"RoutineComment\";\nconst DerivedCommentKeyword = \"DerivedComment\";\n\n/*********************************************************/\nvar getModuleParameter = function (msg, controllerName, moduleTagName, parameterName) {\n    // This function returns the value for the specified module (controllerName-tagname pair) and parameter \n    // This function searches for the parameter name in the modules list first, then in the modules data table.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleParameter\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel, \"-->getModuleParameter(\" + controllerName + \", \" + moduleTagName + \", \" + parameterName + \")\");\n    \n    // Default the return variable\n    var returnValue = undefined;\n    \n    // Attempt to pull a reference to the module list dataset\n    var moduleList = msg.payload.Modules;\n    \n    // Test if the module list exists or not\n    var module_i = null;\n    if ((moduleList !== null) && (moduleList !== undefined)) {\n        // Module List exists\n        // Attempt to pull the module's data table information\n        var tempFilterArray = moduleList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) &&\n                        (element.ModuleTagName === moduleTagName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            module_i = tempFilterArray[0];\n        }\n    }\n    \n    // Test if the module exists in the master list or not\n    if ((module_i !== null) && (module_i !== undefined)) {\n        // Module exists in the master list\n        // Pull down the common parameters\n        var className_i = module_i.ClassName;\n        \n        /****************************\n        * Try Module List           *\n        *****************************/\n        // Test if the module list dataset has the given parameter name as a property\n        if (module_i.hasOwnProperty(parameterName)) {\n            // Pull the value\n            returnValue = module_i[parameterName];\n            \n            // Test if the return value is missing or not\n            if ((returnValue === null) || (returnValue === undefined)) {\n                // Value is missing.  Provide a default value.\n                // Note: This will prevent the subsequent code from performing an unnecessary lookup in the data table.\n                returnValue = \"\";\n            }\n        }\n        \n        /****************************\n        * Try Module Data Table     *\n        *****************************/\n        // Test if the return value is missing or not\n        // If it is missing, try searching for the parameter in the module data table\n        if ((returnValue === null) || (returnValue === undefined)) {\n            // Attempt to pull the module data table for the current module\n            var moduleDataTable = msg.payload[className_i];\n            \n            // Test if the module's data table exists or not\n            var moduleData_i = null;\n            if ((moduleDataTable !== null) && (moduleDataTable !== undefined)) {\n                // Attempt to pull the module's data table information\n                tempFilterArray = moduleDataTable.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists in the data table\n                    // Cache a reference to the current module's data table row\n                    moduleData_i = tempFilterArray[0];\n                    \n                    // Test if the module data table has the given parameter name as a property\n                    if (moduleData_i.hasOwnProperty(parameterName)) {\n                        // Pull the value from the module's data table\n                        returnValue = moduleData_i[parameterName];\n                        \n                        // Test if the return value is missing or not\n                        if ((returnValue === null) || (returnValue === undefined)) {\n                            /****************************\n                            * Try Class Definition      *\n                            *****************************/\n                            // Value is missing.  Try to pull it from the class definition.\n                            // Attempt to pull a reference to the class parameters definitions dataset\n                            var cDef_Parameters = msg.payload.CDef_Parameters_Pivoted;\n                            \n                            // Attempt to pull the module's class's parameter information\n                            tempFilterArray = cDef_Parameters.filter((element)=>{\n                                    if ((element !== null) && (element !== undefined)){\n                                        return (element.ClassName === className_i);\n                                    }\n                                });\n                            \n                            // Check is anything was returned\n                            if(tempFilterArray.length > 0) {\n                                // Cache a reference to the current module's class parameters definition\n                                var cDef_Class_i = tempFilterArray[0];\n                                \n                                // Attempt to pull the given parameter in the class parameters definitions dataset\n                                tempFilterArray = cDef_Class_i.Parameters.filter((element)=>{\n                                        if ((element !== null) && (element !== undefined)){\n                                            return (element.ParameterName === parameterName);\n                                        }\n                                    });\n                                \n                                // Check is anything was returned\n                                if(tempFilterArray.length > 0) {\n                                    // Cache a reference to the class definition's parameter\n                                    var cDef_Parameter_i = tempFilterArray[0];\n                                    \n                                    // Pull the data type and the default value\n                                    var dataType_i = cDef_Parameter_i.DataType;\n                                    returnValue = cDef_Parameter_i.DefaultValue;\n                                    \n                                    // Test if the return value is missing or not\n                                    if ((returnValue === null) || (returnValue === undefined)) {\n                                        // Value is missing.  Provide a default value.\n                                        // FUTURE: Vary default return value by datatype?\n                                        returnValue = \"\";\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getCodeSnippet = function (msg, className, usageScenario, snippetName) {\n    // This function returns the value for the specified class, usage scenarion, and snippet \n    // This function searches for the snippet name in the specified class & usage scenario.\n    // It does NOT have any cascading lookup scenarios.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getCodeSnippet\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getCodeSnippet(\" + controllerName + \", \" + moduleTagName + \", \" + snippetName + \")\");\n    \n    // Default the return variable\n    var returnValue = null;\n    \n    // Attempt to pull a reference to the class snippet definitions dataset\n    var cDef_CodeSnippets = msg.payload.CDef_CodeSnippets;\n    \n    // Test if the program list exists or not\n    var codeSnippet_i = null;\n    if ((cDef_CodeSnippets !== null) && (cDef_CodeSnippets !== undefined)) {\n        // Program List exists\n        \n        /****************************\n        * Try Exact Key             *\n        *****************************/\n        // Attempt to pull the program's information\n        var tempFilterArray = programList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.ClassName === className) && \n                        (element.UsageScenario === usageScenario) && \n                        (element.SnippetName === snippetName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Program exists\n            // Debug Messages\n            logVerboseMessage(thisCallStackLevel,  \"Item found with exact key.\");\n            \n            // Cache a reference to the current program's row\n            codeSnippet_i = tempFilterArray[0];\n        }\n        \n        // Test if a snippet was found or not.\n        if ((codeSnippet_i !== null) && (codeSnippet_i !== undefined)) {\n            // Item was found.   Return it.\n            // Create a new object with the code-comment data\n            returnValue = {\n                \"Code\": codeSnippet_i.Code,\n                \"Comment\": codeSnippet_i.Comment,\n            };\n        }\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getModuleSnippet = function (msg, controllerName, moduleTagName, snippetName) {\n    // This function returns the value for the specified module (controllerName-tagname pair) and snippet \n    // This function searches for the snippet name in the module's class's current usage scenario first, \n    //  then in the module's class's Globaql usage scenario, then in the Global class definition's Global usage scenario.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleSnippet\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getModuleSnippet(\" + controllerName + \", \" + moduleTagName + \", \" + snippetName + \")\");\n    \n    // Default the return variable\n    var returnValue = null;\n    \n    // Attempt to pull a reference to the class snippet definitions dataset\n    var cDef_CodeSnippets = msg.payload.CDef_CodeSnippets_Pivoted;\n    \n    // Attempt to pull a reference to the module list dataset\n    var moduleList = msg.payload.Modules;\n    \n    // Test if the module list exists or not\n    var module_i = null;\n    if ((moduleList !== null) && (moduleList !== undefined)) {\n        // Module List exists\n        // Attempt to pull the module's data table information\n        var tempFilterArray = moduleList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) &&\n                        (element.ModuleTagName === moduleTagName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            module_i = tempFilterArray[0];\n        }\n    }\n    \n    // Test if the module exists in the master list or not\n    if ((module_i !== null) && (module_i !== undefined)) {\n        // Module exists in the master list\n        // Pull down the common parameters\n        var className_i = module_i.ClassName;\n        var usageScenario_i = module_i.UsageScenario;\n        \n        /********************************************\n        * Try Current Module's Override Code        *\n        ********************************************/\n        if (snippetName == \"Main\") {\n            // Attempt to pull the module data table for the current module\n            var moduleDataTable = msg.payload[className_i];\n            \n            // Test if the module's data table exists or not\n            var moduleData_i = null;\n            if ((moduleDataTable !== null) && (moduleDataTable !== undefined)) {\n                // Attempt to pull the module's data table information\n                tempFilterArray = moduleDataTable.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists in the data table\n                    // Cache a reference to the current module's data table row\n                    moduleData_i = tempFilterArray[0];\n                    \n                    // Pull the relevant parameters\n                    var codeOverride_i = moduleData_i.CodeOverride;\n                    var commentOverride_i = moduleData_i.CommentOverride;\n                    \n                    // Test if there is any code override to return\n                    if ((codeOverride_i !== null) && (codeOverride_i !== undefined)) {\n                        // The code column exists and it is not empty\n                        // Test if there is any comment override to return\n                        if ((commentOverride_i === null) || (commentOverride_i === undefined)) {\n                            // Comment override is missing.  \n                            commentOverride_i = \"\";\n                            //FUTURE: Look it up from the class definitions Main snippet??\n                        }\n                        \n                        // Create a new object with the code-comment override data\n                        returnValue = {\n                            \"Code\": codeOverride_i,\n                            \"Comment\": commentOverride_i,\n                        };\n                    }\n                }\n            }\n        }\n        \n        // If nothing has been found yet, start searching the class definitions data set\n        if ((returnValue === null) || (returnValue === undefined)) {\n            // Attempt to pull the module's class's snippets information\n            tempFilterArray = cDef_CodeSnippets.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.ClassName === className_i);\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Cache a reference to the current module's class snippets definition\n                var cDef_Class_i = tempFilterArray[0];\n                \n                /********************************************\n                * Try Current Class's Current Scenario      *\n                ********************************************/\n                // Attempt to pull the given usage scenario from the current module's class snippets definition\n                tempFilterArray = cDef_Class_i.UsageScenarios.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return (element.UsageScenarioName === usageScenario_i);\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Cache a reference to the class definition's current usage scenario\n                    var cDef_UsageScenario_i = tempFilterArray[0];\n                    \n                    // Attempt to pull the given usage scenario from the current module's class snippets definition\n                    tempFilterArray = cDef_UsageScenario_i.Snippets.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.SnippetName === snippetName);\n                            }\n                        });\n                    \n                    // Check is anything was returned\n                    if(tempFilterArray.length > 0) {\n                        // Snippet was found. Return it.\n                        returnValue = tempFilterArray[0];\n                    }\n                }\n                \n                /*******************************************\n                * Try Current Class's Global Scenario      *\n                ********************************************/\n                // If nothing has been found yet, pull the Global usage scenario from the current class\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Attempt to pull the Global usage scenario from the current module's class snippets definition\n                    tempFilterArray = cDef_Class_i.UsageScenarios.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.UsageScenarioName === \"Global\");\n                            }\n                        });\n                    \n                    // Check is anything was returned\n                    if(tempFilterArray.length > 0) {\n                        // Cache a reference to the class definition's Global usage scenario\n                        cDef_UsageScenario_i = tempFilterArray[0];\n                        \n                        // Attempt to pull the given usage scenario from the current module's class snippets definition\n                        tempFilterArray = cDef_UsageScenario_i.Snippets.filter((element)=>{\n                                if ((element !== null) && (element !== undefined)){\n                                    return (element.SnippetName === snippetName);\n                                }\n                            });\n                        \n                        // Check is anything was returned\n                        if(tempFilterArray.length > 0) {\n                            // Snippet was found. Return it.\n                            returnValue = tempFilterArray[0];\n                        }\n                    }\n                }\n                \n                /*******************************************\n                * Try Global Class's Global Scenario       *\n                ********************************************/\n                // If nothing has been found yet, pull the Global usage scenario from the Global class\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Attempt to pull the module's class's snippets information\n                    var cDef_Global = null;\n                    tempFilterArray = cDef_CodeSnippets.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.ClassName === \"Global\");\n                            }\n                        });\n                    \n                    // Check is anything was returned\n                    if(tempFilterArray.length > 0) {\n                        // Cache a reference to the current module's class snippets definition\n                        cDef_Global = tempFilterArray[0];\n                    }\n                    \n                    // Test if the Global class exists\n                    if ((cDef_Global !== null) && (cDef_Global !== undefined)) {\n                        // Attempt to pull the global usage scenario from the Global class\n                        tempFilterArray = cDef_Global.UsageScenarios.filter((element)=>{\n                                if ((element !== null) && (element !== undefined)){\n                                    return (element.UsageScenarioName === \"Global\");\n                                }\n                            });\n                        \n                        // Check is anything was returned\n                        var cDef_Global_UsageScenario = null;\n                        if(tempFilterArray.length > 0) {\n                            // Cache a reference to the Global class's Global usage scenario\n                            cDef_Global_UsageScenario = tempFilterArray[0];\n                        }\n                        \n                        // Attempt to pull a reference to the global usage scenario's snippets\n                        var cDef_Global_Snippets = null;\n                        if ((cDef_Global_UsageScenario !== null) && (cDef_Global_UsageScenario !== undefined)) {\n                            cDef_Global_Snippets = cDef_Global_UsageScenario.Snippets;\n                        }\n                        \n                        // Test if the Global class's Global usage scenario exists\n                        if ((cDef_Global_Snippets !== null) && (cDef_Global_Snippets !== undefined)) {\n                            // Attempt to pull the given usage scenario from the current module's class snippets definition\n                            tempFilterArray = cDef_Global_Snippets.filter((element)=>{\n                                    if ((element !== null) && (element !== undefined)){\n                                        return (element.SnippetName === snippetName);\n                                    }\n                                });\n                            \n                            // Check is anything was returned\n                            if(tempFilterArray.length > 0) {\n                                // Snippet was found. Return it.\n                                returnValue = tempFilterArray[0];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Catch comments that should be empty strings\n    if ((returnValue !== null) && (returnValue !== undefined)) {\n        // Catch the case where the Code is specified but the comment is missing (null)\n        if ((returnValue.Code !== null) && (returnValue.Code !== undefined) && (returnValue.Comment === null)) {\n            returnValue.Comment = \"\";\n        }\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getModuleSnippetCode = function (msg, controllerName, moduleTagName, snippetName) {\n    // Returns just the code portion of the code-comment pair\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleSnippetCode\";\n    \n    // Pull the item and return the code portion\n    var codeCommentPair = getModuleSnippet(msg, controllerName, moduleTagName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Code : null;\n};\n\nvar getModuleSnippetComment = function (msg, controllerName, moduleTagName, snippetName) {\n    // Returns just the comment portion of the code-comment pair\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleSnippetComment\";\n    \n    // Pull the item and return the comment portion\n    var codeCommentPair = getModuleSnippet(msg, controllerName, moduleTagName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Comment : null;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getDerivedItem = function (msg, itemName) {\n    // This function returns the value for the specified item name \n    // This function attempts to search the derivedItemsDictionary in the global context\n    // If nothing is found, null is returned\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getDerivedItem\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getDerivedItem(\" + itemName + \")\");\n    \n    // Default the return variable\n    var returnValue = undefined;\n    \n    // Search the derivedItemsDictionary in the global context\n    var derivedItemsDict = global.get(\"derivedItemsDictionary\");\n    \n    // Test if the dictionary exists or not\n    if ((derivedItemsDict !== null) && (derivedItemsDict !== undefined)) {\n        // Dictioary exists.  Test if requested property exists.\n        if (derivedItemsDict.hasOwnProperty(itemName)) {\n            // Item exists.  Pull it & return it.\n            returnValue = derivedItemsDict[itemName];\n        }\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getModuleDerivedItem = function (msg, controllerName, moduleTagName, itemName) {\n    // This function returns the value for the specified module (controllerName-tagname pair) and item name \n    // This function is intended to vary its search method AND return data type based on the item name to search for.\n    // Currently supported specially searchable item names:\n    //      1) AllInterlocksCode:  Returns a snippet {\"SnippetName\":string, \"Code\":string, \"Comment\":string}\n    //      2) AllPermissivesCode:  Returns a snippet {\"SnippetName\":string, \"Code\":string, \"Comment\":string}\n    // All others attempt to search the derivedItemsDictionary in the global context\n    // If nothing is found, null is returned\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleDerivedItem\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getModuleDerivedItem(\" + controllerName + \", \" + moduleTagName + \", \" + itemName + \")\");\n    \n    // Default the return variable\n    var returnValue = undefined;\n    \n    // Determine what the item to search for is\n    switch(itemName) {\n        case \"AllInterlocksCode\":\n        case \"AllPermissivesCode\":\n            // This case handles all snippet lookups from the ModuleCodeSnippets dataset\n            // Attempt to pull a reference to the module snippets dataset\n            var mDef_CodeSnippets = msg.payload.ModuleCodeSnippets;\n            \n            // Test if the module list exists or not\n            var mDef_CodeSnippets_i = null;\n            if ((mDef_CodeSnippets !== null) && (mDef_CodeSnippets !== undefined)) {\n                // Module List exists\n                // Attempt to pull the module's snippet derived code snippets dataset\n                var tempFilterArray = mDef_CodeSnippets.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.Controller === controllerName) &&\n                                (element.ModuleTagName === moduleTagName));\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Module exists\n                    // Cache a reference to the current module's custom snippets definitions\n                    mDef_CodeSnippets_i = tempFilterArray[0];\n                }\n            }\n            \n            // Test if the module exists in the module code snippets list or not\n            if ((mDef_CodeSnippets_i !== null) && (mDef_CodeSnippets_i !== undefined)) {\n                // Module exists in the module code snippets dataset\n                // Attempt to pull the module's specified derived code snippet\n                var tempFilterArray = mDef_CodeSnippets_i.Snippets.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return (element.SnippetName === itemName);\n                        }\n                    });\n                \n                // Check is anything was returned\n                if(tempFilterArray.length > 0) {\n                    // Requested item exists.  Return it.\n                    returnValue = tempFilterArray[0];\n                }\n            }\n            \n            // Catch comments that should be empty strings\n            if ((returnValue !== null) && (returnValue !== undefined)) {\n                // Catch the case where the Code is specified but the comment is missing (null)\n                if ((returnValue.Code !== null) && (returnValue.Code !== undefined) && (returnValue.Comment === null)) {\n                    returnValue.Comment = \"\";\n                }\n            }\n            break;\n            \n        /*\n        FUTURE:\n        default:\n            // Attempt to search the global derivedItemsDictionary as a last resort\n            returnValue = getDerivedItem(msg, itemName);\n            break;\n        */\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getModuleDerivedCode = function (msg, controllerName, moduleTagName, itemName) {\n    // Returns just the code portion of the code-comment pair\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleDerivedCode\";\n    \n    // Pull the item and return the code portion\n    var codeCommentPair = getModuleDerivedItem(msg, controllerName, moduleTagName, itemName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Code : null;\n};\n\nvar getModuleDerivedComment = function (msg, controllerName, moduleTagName, itemName) {\n    // Returns just the comment portion of the code-comment pair\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleDerivedComment\";\n    \n    // Pull the item and return the comment portion\n    var codeCommentPair = getModuleDerivedItem(msg, controllerName, moduleTagName, itemName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Comment : null;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getRoutineParameter = function (msg, controllerName, taskName, programName, routineName, parameterName) {\n    // This function returns the value for the specified routine (controllerName-taskName-programName-routineName key) and parameter \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineParameter\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getRoutineParameter(\" + controllerName + \", \" + taskName + \", \" + programName + \", \" + routineName + \", \" + parameterName + \")\");\n    \n    // Default the return variable\n    var returnValue = undefined;\n    \n    // Attempt to pull a reference to the routine list dataset\n    var routineList = msg.payload.Routines;\n    \n    // Test if the routine list exists or not\n    var routine_i = null;\n    if ((routineList !== null) && (routineList !== undefined)) {\n        // Routine List exists\n        \n        /****************************\n        * Try Exact Key             *\n        *****************************/\n        // Attempt to pull the routine's information\n        var tempFilterArray = routineList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) && \n                        (element.Task === taskName) && \n                        (element.Program === programName) && \n                        (element.Routine === routineName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Routine exists\n            // Debug Messages\n            logVerboseMessage(thisCallStackLevel,  \"Item found with exact key.\");\n            \n            // Cache a reference to the current routine's row\n            routine_i = tempFilterArray[0];\n        }\n        \n        /****************************\n        * Try Global Controller     *\n        *****************************/\n        if ((routine_i === null) || (routine_i === undefined)) {\n            // Attempt to pull the routine's information\n            tempFilterArray = routineList.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === \"Global\") && \n                            (element.Task === taskName) && \n                            (element.Program === programName) && \n                            (element.Routine === routineName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Item exists\n                // Debug Messages\n                logVerboseMessage(thisCallStackLevel,  \"Item found with Global Controller key.\");\n                \n                // Cache a reference to the current routine's row\n                routine_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Try Global Task           *\n        *****************************/\n        if ((routine_i === null) || (routine_i === undefined)) {\n            // Attempt to pull the routine's information\n            tempFilterArray = routineList.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === \"Global\") &&\n                            (element.Task === \"Global\") && \n                            (element.Program === programName) && \n                            (element.Routine === routineName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Item exists\n                // Debug Messages\n                logVerboseMessage(thisCallStackLevel,  \"Item found with Global Task key.\");\n                \n                // Cache a reference to the current routine's row\n                routine_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Try Global Program        *\n        *****************************/\n        if ((routine_i === null) || (routine_i === undefined)) {\n            // Attempt to pull the routine's information\n            tempFilterArray = routineList.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === \"Global\") && \n                            (element.Task === \"Global\") && \n                            (element.Program === \"Global\") && \n                            (element.Routine === routineName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Item exists\n                // Debug Messages\n                logVerboseMessage(thisCallStackLevel,  \"Item found with Global Program key.\");\n                \n                // Cache a reference to the current routine's row\n                routine_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Process resulting row     *\n        *****************************/\n        if ((routine_i === null) || (routine_i === undefined)) {\n            // Log a validation error\n            logValidationErrorMessage(thisCallStackLevel,  \"Cannot find controllerName (\" + controllerName + \"), taskName (\" + taskName + \n                \"), programName (\" + programName + \"), routineName (\" + routineName + \") in Routines table.\");\n        }\n        else {\n            // Test if the routine list dataset has the given parameter name as a property\n            if (routine_i.hasOwnProperty(parameterName)) {\n                // Pull the value\n                returnValue = routine_i[parameterName];\n                \n                // Test if the return value is missing or not\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Value is missing.  Provide a default value.\n                    // Note: This will prevent the subsequent code from performing an unnecessary lookup in the data table.\n                    returnValue = \"\";\n                }\n            }\n            else {\n                logValidationErrorMessage(thisCallStackLevel,  \"Cannot find parameterName (\" + parameterName + \") for controllerName (\" + \n                    controllerName + \"), taskName (\" + taskName + \"), programName (\" + programName + \"), routineName (\" + \n                    routineName + \") in Routines table.\");\n            }\n        }\n    }\n    else {\n        // Debug Messages\n        logVerboseMessage(thisCallStackLevel,  \"Quitting.  Cannot find the Routines dataset.\");\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getRoutineParameterForModule = function (msg, controllerName, moduleTagName, parameterName) {\n    // This function returns the value for the specified module's routine (controllerName-moduleTagName pair) and parameter \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineParameterForModule\";\n    \n    // Default the return value\n    var returnValue = undefined;\n    \n    // Pull the current unresolved Task, Program, and Routine values for the current module\n    var taskName = getModuleParameter(msg, controllerName, moduleTagName, \"Task\");\n    var programName = getModuleParameter(msg, controllerName, moduleTagName, \"Program\");\n    var routineName = getModuleParameter(msg, controllerName, moduleTagName, \"Routine\");\n    \n    //  Pull the resolved Task, Program, and Routine values for the current module\n    var resolvedTaskName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, taskName);\n    var resolvedProgramName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, programName);\n    var resolvedRoutineName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, routineName);\n    \n    //  Attempt to pull the value for the resolved values\n    returnValue = getRoutineParameter(msg, controllerName, resolvedTaskName, resolvedProgramName, resolvedRoutineName, parameterName);\n    \n    //  Attempt to pull the value for the unresolved values if the previous call didn't return anything\n    if ((returnValue === null) || (returnValue === undefined)) {\n        returnValue = getRoutineParameter(msg, controllerName, taskName, programName, routineName, parameterName);\n    }\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getProgramParameter = function (msg, controllerName, taskName, programName, parameterName) {\n    // This function returns the value for the specified program (controllerName-taskName-programName key) and parameter \n    // This function searches for the parameter name in the programs list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getProgramParameter\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getProgramParameter(\" + controllerName + \", \" + taskName + \", \" + programName + \", \" + parameterName + \")\");\n    \n    // Default the return variable\n    var returnValue = undefined;\n    \n    // Attempt to pull a reference to the program list dataset\n    var programList = msg.payload.Programs;\n    \n    // Test if the program list exists or not\n    var program_i = null;\n    if ((programList !== null) && (programList !== undefined)) {\n        // Program List exists\n        \n        /****************************\n        * Try Exact Key             *\n        *****************************/\n        // Attempt to pull the program's information\n        var tempFilterArray = programList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) && \n                        (element.Task === taskName) && \n                        (element.Program === programName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Program exists\n            // Debug Messages\n            logVerboseMessage(thisCallStackLevel,  \"Item found with exact key.\");\n            \n            // Cache a reference to the current program's row\n            program_i = tempFilterArray[0];\n        }\n        \n        /****************************\n        * Try Global Controller     *\n        *****************************/\n        if ((program_i === null) || (program_i === undefined)) {\n            // Attempt to pull the program's information\n            tempFilterArray = programList.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === \"Global\") && \n                            (element.Task === taskName) && \n                            (element.Program === programName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Item exists\n                // Debug Messages\n                logVerboseMessage(thisCallStackLevel,  \"Item found with Global Controller key.\");\n                \n                // Cache a reference to the current program's row\n                program_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Try Global Task           *\n        *****************************/\n        if ((program_i === null) || (program_i === undefined)) {\n            // Attempt to pull the program's information\n            tempFilterArray = programList.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === \"Global\") && \n                            (element.Task === \"Global\") && \n                            (element.Program === programName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Item exists\n                // Debug Messages\n                logVerboseMessage(thisCallStackLevel,  \"Item found with Global Task key.\");\n                \n                // Cache a reference to the current program's row\n                program_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Process resulting row     *\n        *****************************/\n        if ((program_i === null) || (program_i === undefined)) {\n            // Log a validation error\n            logValidationErrorMessage(thisCallStackLevel,  \"Cannot find controllerName (\" + controllerName + \"), taskName (\" + taskName + \n                \"), programName (\" + programName + \") in Programs table.\");\n        }\n        else {\n            // Test if the program list dataset has the given parameter name as a property\n            if (program_i.hasOwnProperty(parameterName)) {\n                // Pull the value\n                returnValue = program_i[parameterName];\n                \n                // Test if the return value is missing or not\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Value is missing.  Provide a default value.\n                    // Note: This will prevent the subsequent code from performing an unnecessary lookup in the data table.\n                    returnValue = \"\";\n                }\n            }\n            else {\n                logValidationErrorMessage(thisCallStackLevel,  \"Cannot find parameterName (\" + parameterName + \") for controllerName (\" + \n                    controllerName + \"), taskName (\" + taskName + \"), programName (\" + programName + \") in Programs table.\");\n            }\n        }\n    }\n    else {\n        // Debug Messages\n        logVerboseMessage(thisCallStackLevel,  \"Quitting.  Cannot find the Programs dataset.\");\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getProgramParameterForModule = function (msg, controllerName, moduleTagName, parameterName) {\n    // This function returns the value for the specified module's program (controllerName-moduleTagName pair) and parameter \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getProgramParameterForModule\";\n    \n    // Default the return value\n    var returnValue = undefined;\n    \n    // Pull the current unresolved Task and Program values for the current module\n    var taskName = getModuleParameter(msg, controllerName, moduleTagName, \"Task\");\n    var programName = getModuleParameter(msg, controllerName, moduleTagName, \"Program\");\n    \n    //  Pull the resolved Task and Program values for the current module\n    var resolvedTaskName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, taskName);\n    var resolvedProgramName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, programName);\n    \n    //  Attempt to pull the value for the resolved values\n    returnValue = getProgramParameter(msg, controllerName, resolvedTaskName, resolvedProgramName, parameterName);\n    \n    //  Attempt to pull the value for the unresolved values if the previous call didn't return anything\n    if ((returnValue === null) || (returnValue === undefined)) {\n        returnValue = getProgramParameter(msg, controllerName, taskName, programName, parameterName);\n    }\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getTaskParameter = function (msg, controllerName, taskName, parameterName) {\n    // This function returns the value for the specified task (controllerName-taskName key) and parameter \n    // This function searches for the parameter name in the tasks list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getTaskParameter\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getTaskParameter(\" + controllerName + \", \" + taskName + \", \" + parameterName + \")\");\n    \n    // Default the return variable\n    var returnValue = undefined;\n    \n    // Attempt to pull a reference to the task list dataset\n    var taskList = msg.payload.Tasks;\n    \n    // Test if the task list exists or not\n    var task_i = null;\n    if ((taskList !== null) && (taskList !== undefined)) {\n        // Task List exists\n        \n        /****************************\n        * Try Exact Key             *\n        *****************************/\n        // Attempt to pull the task's information\n        var tempFilterArray = taskList.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controllerName) && \n                        (element.Task === taskName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Item exists\n            // Debug Messages\n            logVerboseMessage(thisCallStackLevel,  \"Item found with exact key.\");\n            \n            // Cache a reference to the current task's row\n            task_i = tempFilterArray[0];\n        }\n        \n        /****************************\n        * Try Global Controller     *\n        *****************************/\n        if ((task_i === null) || (task_i === undefined)) {\n            // Attempt to pull the task's information\n            tempFilterArray = taskList.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === \"Global\") && \n                            (element.Task === taskName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Item exists\n                // Debug Messages\n                logVerboseMessage(thisCallStackLevel,  \"Item found with Global Controller key.\");\n                \n                // Cache a reference to the current task's row\n                task_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Process resulting row     *\n        *****************************/\n        if ((task_i === null) || (task_i === undefined)) {\n            // Log a validation error\n            logValidationErrorMessage(thisCallStackLevel,  \"Cannot find controllerName (\" + controllerName + \"), taskName (\" + taskName + \n                \") in Tasks table.\");\n        }\n        else {\n            // Test if the task list dataset has the given parameter name as a property\n            if (task_i.hasOwnProperty(parameterName)) {\n                // Pull the value\n                returnValue = task_i[parameterName];\n                \n                // Test if the return value is missing or not\n                if ((returnValue === null) || (returnValue === undefined)) {\n                    // Value is missing.  Provide a default value.\n                    // Note: This will prevent the subsequent code from performing an unnecessary lookup in the data table.\n                    returnValue = \"\";\n                }\n            }\n            else {\n                logValidationErrorMessage(thisCallStackLevel,  \"Cannot find parameterName (\" + parameterName + \") for controllerName (\" + \n                    controllerName + \"), taskName (\" + taskName + \"), in Tasks table.\");\n            }\n        }\n    }\n    else {\n        // Debug Messages\n        logVerboseMessage(thisCallStackLevel,  \"Quitting.  Cannot find the Tasks dataset.\");\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getTaskParameterForModule = function (msg, controllerName, moduleTagName, parameterName) {\n    // This function returns the value for the specified module's task (controllerName-moduleTagName pair) and parameter \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getTaskParameterForModule\";\n    \n    // Default the return value\n    var returnValue = undefined;\n    \n    // Pull the current unresolved Task value for the current module\n    var taskName = getModuleParameter(msg, controllerName, moduleTagName, \"Task\");\n    \n    //  Pull the resolved Task value for the current module\n    var resolvedTaskName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, taskName);\n    \n    //  Attempt to pull the value for the resolved values\n    returnValue = getTaskParameter(msg, controllerName, resolvedTaskName, parameterName);\n    \n    //  Attempt to pull the value for the unresolved values if the previous call didn't return anything\n    if ((returnValue === null) || (returnValue === undefined)) {\n        returnValue = getTaskParameter(msg, controllerName, taskName, parameterName);\n    }\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getRoutineSnippet = function (msg, controllerName, taskName, programName, routineName, snippetName) {\n    // This function returns the value for the specified routine (controllerName-taskName-programName-routineName key) and snippet \n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineSnippet\";\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"-->getRoutineSnippet(\" + controllerName + \", \" + taskName + \", \" + programName + \", \" + routineName + \", \" + snippetName + \")\");\n    \n    // Default the return variable\n    var returnValue = null;\n    \n    // Attempt to pull a reference to the class snippet definitions dataset\n    var pDef_CodeSnippets = msg.payload.PDef_CodeSnippets;\n    \n    // *********************************************************\n    // FUTURE:  Attempt to pull override code & comments first *\n    // *********************************************************\n    \n    // Test if the task list exists or not\n    var snippet_i = null;\n    if ((pDef_CodeSnippets !== null) && (pDef_CodeSnippets !== undefined)) {\n        // Program Structure Snippets List exists\n        \n        /****************************\n        * Try Exact Key             *\n        *****************************/\n        // Attempt to pull the task's information\n        var tempFilterArray = pDef_CodeSnippets.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Program === programName) && \n                        (element.Routine === routineName) && \n                        (element.SnippetName === snippetName));\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Task exists\n            // Cache a reference to the current task's row\n            snippet_i = tempFilterArray[0];\n        }\n        \n        /****************************\n        * Try Global Controller     *\n        *****************************/\n        if ((snippet_i === null) || (snippet_i === undefined)) {\n            // Attempt to pull the task's information\n            tempFilterArray = pDef_CodeSnippets.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Program === \"Global\") && \n                            (element.Routine === routineName) && \n                            (element.SnippetName === snippetName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Routine exists\n                // Cache a reference to the current task's row\n                snippet_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Try Global Task           *\n        *****************************/\n        if ((snippet_i === null) || (snippet_i === undefined)) {\n            // Attempt to pull the task's information\n            tempFilterArray = pDef_CodeSnippets.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Program === \"Global\") && \n                            (element.Routine === \"Global\") && \n                            (element.SnippetName === snippetName));\n                    }\n                });\n            \n            // Check is anything was returned\n            if(tempFilterArray.length > 0) {\n                // Program exists\n                // Cache a reference to the current task's row\n                snippet_i = tempFilterArray[0];\n            }\n        }\n        \n        /****************************\n        * Process resulting row     *\n        *****************************/\n        if ((snippet_i === null) || (snippet_i === undefined)) {\n            // Log a validation error\n            logValidationErrorMessage(thisCallStackLevel,  \"Cannot find programName (\" + programName + \"), routineName (\" + routineName + \n                \"), snippetName (\" + snippetName + \") in Program Structure Code Snippets table.\");\n        }\n        else {\n            // Found a valid snippet\n            // Create a new object with the code-comment pair data\n            returnValue = {\n                \"SnippetName\":snippetName,\n                \"Code\":snippet_i.Code,\n                \"Comment\": snippet_i.Comment\n            };\n        }\n    }\n    \n    // Catch comments that should be empty strings\n    if ((returnValue !== null) && (returnValue !== undefined)) {\n        // Catch the case where the Code is specified but the comment is missing (null)\n        if ((returnValue.Code !== null) && (returnValue.Code !== undefined) && (returnValue.Comment === null)) {\n            returnValue.Comment = \"\";\n        }\n    }\n    \n    // Debug Messages\n    logVerboseMessage(thisCallStackLevel,  \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getRoutineSnippetCode = function (msg, controllerName, taskName, programName, routineName, snippetName) {\n    // Returns just the code portion of the code-comment pair\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineSnippetCode\";\n    \n    // Pull the item and return the code portion\n    var codeCommentPair = getRoutineSnippet(msg, controllerName, taskName, programName, routineName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Code : null;\n};\n\nvar getRoutineSnippetComment = function (msg, controllerName, taskName, programName, routineName, snippetName) {\n    // Returns just the comment portion of the code-comment pair\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineSnippetComment\";\n    \n    // Pull the item and return the comment portion\n    var codeCommentPair = getRoutineSnippet(msg, controllerName, taskName, programName, routineName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Comment : null;\n};\n\nvar getRoutineSnippetForModule = function (msg, controllerName, moduleTagName, snippetName) {\n    // This function returns the value for the specified module's routine (controllerName-moduleTagName pair) and snippet \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineSnippetForModule\";\n    \n    // Default the return value\n    var returnValue = null;\n    \n    // Pull the current unresolved Task, Program, and Routine values for the current module\n    var taskName = getModuleParameter(msg, controllerName, moduleTagName, \"Task\");\n    var programName = getModuleParameter(msg, controllerName, moduleTagName, \"Program\");\n    var routineName = getModuleParameter(msg, controllerName, moduleTagName, \"Routine\");\n    \n    //  Pull the resolved Task, Program, and Routine values for the current module\n    var resolvedTaskName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, taskName);\n    var resolvedProgramName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, programName);\n    var resolvedRoutineName = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, routineName);\n    \n    //  Attempt to pull the value for the resolved values\n    returnValue = getRoutineSnippet(msg, controllerName, resolvedTaskName, resolvedProgramName, resolvedRoutineName, snippetName);\n    \n    //  Attempt to pull the value for the unresolved values if the previous call didn't return anything\n    if ((returnValue === null) || (returnValue === undefined)) {\n        returnValue = getRoutineSnippet(msg, controllerName, taskName, programName, routineName, snippetName);\n    }\n    \n    // Return the result\n    return returnValue;\n};\n\nvar getRoutineSnippetCodeForModule = function (msg, controllerName, moduleTagName, snippetName) {\n    // This function returns the value for the specified module's routine (controllerName-moduleTagName pair) and snippet \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineSnippetCodeForModule\";\n    \n    // Pull the item and return the code portion\n    var codeCommentPair = getRoutineSnippetForModule(msg, controllerName, moduleTagName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Code : null;\n};\n\nvar getRoutineSnippetCommentForModule = function (msg, controllerName, moduleTagName, snippetName) {\n    // This function returns the value for the specified module's routine (controllerName-moduleTagName pair) and snippet \n    // This function searches for the parameter name in the routines list.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineSnippetCommentForModule\";\n    \n    // Pull the item and return the comment portion\n    var codeCommentPair = getRoutineSnippetForModule(msg, controllerName, moduleTagName, snippetName);\n    return ((codeCommentPair !== null) && (codeCommentPair !== undefined)) ? codeCommentPair.Comment : null;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar resolveNonCodeReferences = function (msg, lookupKey, stringToResolve) {\n    // This function resolves all non-code find and replace markers into their requested values\n    // This function currently supports the following non-code markers:\n    //  1) {This[ParameterName]}\n    //\n    // FUTURE:\n    // Might want to consider adding support for:\n    //  1) {If[Condition ? ValueIfTrue : ValueIfFalse]}\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"resolveNonCodeReferences\";\n    \n    // Test if stringToResolve is valid\n    if ((stringToResolve === null) || (stringToResolve === undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel,  \"<-- returnValue = (\" + stringToResolve + \")\");\n        \n        // Return the result\n        return stringToResolve;\n    }\n    \n    // Determine what format the lookupKey is in\n    var lookupKeyType = null;\n    if ((lookupKey.controllerName !== undefined) && (lookupKey.moduleTagName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel,  \"-->resolveNonCodeReferences(\" + lookupKey.controllerName + \", \" + \n            lookupKey.moduleTagName + \", \" + stringToResolve + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Module\";\n    }\n    else if ((lookupKey.controllerName !== undefined) && (lookupKey.taskName !== undefined) && \n            (lookupKey.programName !== undefined) && (lookupKey.routineName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->resolveNonCodeReferences(\" + lookupKey.controllerName + \", \" + \n            lookupKey.taskName + \", \" + lookupKey.programName + \", \" + lookupKey.routineName + \", \" + \n            stringToResolve + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Routine\";\n    }\n    /*\n    FUTURE:\n    else if ((lookupKey.className !== undefined) && (lookupKey.usageScenario !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->resolveNonCodeReferences(\" + lookupKey.className + \", \" + \n            lookupKey.usageScenario + \", \" + snippetType + \", \" + snippetName + \")\");\n            \n        // Set the lookup key type\n        lookupKeyType = \"Raw\";\n        \n        //No context to resolve against.  Should return original value.\n        return stringToResolve.toString();\n    }\n    */\n    else {\n        // Debug Messages\n        logErrorMessage(thisCallStackLevel, \"resolveNonCodeReferences doesn't have a valid lookup key.\");\n    }\n    \n    // Default the return value\n    var returnValue = stringToResolve.toString();\n    \n    // Reduce the raw branch code snippet down as much as possible\n    // Find and replace all non-code references that will resolve correctly\n    var reNonCode = RegExp(NonCodeDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reNonCode.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Pull the next match\n        var match = reNonCode.exec(returnValue);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Perform find & replace based on the operator type\n            var replaceText = null;\n            var lookupResult = null;\n            var validKeywordFound = false;\n            switch(operator) {\n                case ThisKeyword:\n                    // Do a module parameter lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getModuleParameter(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    else {\n                        validKeywordFound = false;\n                    }\n                    break;\n                \n                case ThisRoutineKeyword:\n                    // Do a routine parameter lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getRoutineParameterForModule(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    else if (lookupKeyType == \"Routine\") {\n                        lookupResult = getRoutineParameter(msg, lookupKey.controllerName, lookupKey.taskName, lookupKey.programName, lookupKey.routineName, operand);\n                    }\n                    else {\n                        validKeywordFound = false;\n                    }\n                    break;\n                \n                case ThisProgramKeyword:\n                    // Do a program parameter lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getProgramParameterForModule(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    else if ((lookupKeyType == \"Routine\") || (lookupKeyType == \"Program\")) {\n                        lookupResult = getProgramParameter(msg, lookupKey.controllerName, lookupKey.taskName, lookupKey.programName, operand);\n                    }\n                    else {\n                        validKeywordFound = false;\n                    }\n                    break;\n                \n                case ThisTaskKeyword:\n                    // Do a task parameter lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getTaskParameterForModule(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    else if ((lookupKeyType == \"Routine\") || (lookupKeyType == \"Program\") || (lookupKeyType == \"Task\")) {\n                        lookupResult = getTaskParameter(msg, lookupKey.controllerName, lookupKey.taskName, operand);\n                    }\n                    else {\n                        validKeywordFound = false;\n                    }\n                    break;\n            }\n            \n            // Test if a valid keyword was found\n            if (validKeywordFound) {\n                // Test if snippet was found\n                if ((lookupResult !== null) && (lookupResult !== undefined)) {\n                    // Parameter was found.  Use the parameters value.\n                    replaceText = lookupResult;\n                }\n                else {\n                    // Parameter was NOT found.  Remove the curly braces & put the find and replace marker back in its place.\n                    replaceText = wholeMatch.substring(1, wholeMatch.length - 1);\n                }\n            }\n            \n            // Test if there is a replacement string\n            if ((replaceText !== null) && (replaceText !== undefined)) {\n                // Perform the replacement\n                returnValue = returnValue.substring(0, match.index) + replaceText + returnValue.substring(reNonCode.lastIndex);\n                \n                // Start the RegExp's pointer to start scanning at the beginning of the last match\n                // This is done in case the replacement also contains matches that need replacing\n                reNonCode.lastIndex = match.index;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar resolveCommentPlaceholders = function (msg, lookupKey, stringToResolve) {\n    // This function resolves all comment placeholder find and replace markers into their requested values\n    // This function currently supports the following comment markers:\n    //  1) {Comment[SnippetName]}\n    //  2) {DerivedComment[SnippetName]}\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"resolveCommentPlaceholders\";\n    \n    // Determine what format the lookupKey is in\n    var lookupKeyType = null;\n    if ((lookupKey.controllerName !== undefined) && (lookupKey.moduleTagName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->resolveCommentPlaceholders(\" + lookupKey.controllerName + \", \" + \n            lookupKey.moduleTagName + \", \" + stringToResolve + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Module\";\n    }\n    else if ((lookupKey.controllerName !== undefined) && (lookupKey.taskName !== undefined) && \n            (lookupKey.programName !== undefined) && (lookupKey.routineName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->resolveCommentPlaceholders(\" + lookupKey.controllerName + \", \" + \n            lookupKey.taskName + \", \" + lookupKey.programName + \", \" + lookupKey.routineName + \", \" + \n            stringToResolve + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Routine\";\n    }\n    /*\n    FUTURE:\n    else if ((lookupKey.className !== undefined) && (lookupKey.usageScenario !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->resolveCommentPlaceholders(\" + lookupKey.className + \", \" + \n            lookupKey.usageScenario + \", \" + snippetType + \", \" + snippetName + \")\");\n            \n        // Set the lookup key type\n        lookupKeyType = \"Raw\";\n    }\n    */\n    else {\n        // Debug Messages\n        logErrorMessage(thisCallStackLevel, \"resolveCommentPlaceholders doesn't have a valid lookup key.\");\n    }\n    \n    // Default the return value\n    var returnValue = \"\";\n    \n    // Reduce the raw branch code snippet down as much as possible\n    // Find and replace all {Comment[~~]} & {DerivedComment[~~]} references that will resolve correctly\n    var reComment = RegExp(CommentDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reComment.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Pull the next match\n        var match = reComment.exec(stringToResolve);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Perform find & replace based on the operator type\n            var resolvedText = null;\n            var lookupResult = null;\n            var validKeywordFound = false;\n            switch(operator) {\n                case CommentKeyword:\n                    // Do a module code's comment lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getModuleSnippetComment(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    /*\n                    FUTURE:\n                    else if (lookupKeyType == \"Raw\") {\n                        lookupResult = getSnippetComment(msg, lookupKey.className, lookupKey.usageScenario, operand);\n                    }\n                    */\n                    else {\n                        validKeywordFound = false;\n                    }\n                    break;\n                \n                case RoutineCommentKeyword:\n                    /// Do a module's routine's code's comment lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getRoutineSnippetCommentForModule(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    else if (lookupKeyType == \"Routine\") {\n                        lookupResult = getRoutineSnippetComment(msg, lookupKey.controllerName, lookupKey.taskName, lookupKey.programName, lookupKey.routineName, operand);\n                    }\n                    break;\n                    \n                case DerivedCommentKeyword:\n                    // Do a derived code's comment lookup.\n                    validKeywordFound = true;\n                    if (lookupKeyType == \"Module\") {\n                        lookupResult = getModuleDerivedComment(msg, lookupKey.controllerName, lookupKey.moduleTagName, operand);\n                    }\n                    /*\n                    FUTURE:\n                    else if (lookupKeyType == \"Raw\") {\n                        lookupResult = getDerivedComment(msg, lookupKey.className, lookupKey.usageScenario, operand);\n                    }\n                    */\n                    else {\n                        validKeywordFound = false;\n                    }\n                    break;\n            }\n            \n            // Test if a valid keyword was found\n            if (validKeywordFound) {\n                // Test if snippet was found\n                if ((lookupResult !== null) && (lookupResult !== undefined)) {\n                    // Parameter was found.  Use the parameters value.\n                    resolvedText = lookupResult;\n                }\n                else {\n                    // Parameter was NOT found.  Remove the curly braces & put the find and replace marker back in its place.\n                    resolvedText = wholeMatch.substring(1, wholeMatch.length - 1);\n                }\n            }\n            \n            // Test if there is a replacement string\n            if ((resolvedText !== null) && (resolvedText !== undefined)) {\n                // Add the resolved text to the return value.  Prefix with the comment delimiter if there is anything already there.\n                returnValue = returnValue + (returnValue.length > 0 ? commentDelimiter : \"\") + resolvedText;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Resolve all non-code references before returning the result\n    returnValue = resolveNonCodeReferences(msg, lookupKey, returnValue);\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\nvar getResolvedCodeAndCommentPlaceholderPairs = function (msg, lookupKey, snippetType, snippetName) {\n    // This function resolves all code find and replace markers for the given snippet name into the code segment-comment placeholder pairs.\n    // The resolved string is split into code segments using the End of Segment marker\n    //   i.e. End of Segment marker is a semi-colon for RSLogix 5000 rungs in neutral text syntax.\n    // The comment placeholders are used instead of the resolved comments in order to properly generate \n    //  combined comments when the code contains End of Segment markers.\n    //\n    // Lookup key can be either:\n    //  {\n    //      controllerName, \n    //      moduleTagName\n    //  }\n    //  OR\n    //  {\n    //      controllerName, \n    //      taskName, \n    //      programName, \n    //      routineName\n    //  }\n    //  OR (FUTURE)\n    //  {\n    //      className,\n    //      usageScenario\n    //  }\n    //\n    // This function currently supports the following code markers:\n    //  1) {Code[SnippetName]}\n    //  2) {DerivedComment[SnippetName]}\n    // \n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"CommentPlaceholder\":commentPlaceholder_i\n    // }]\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getResolvedCodeAndCommentPlaceholderPairs\";\n    \n    // Determine what format the lookupKey is in\n    var lookupKeyType = null;\n    if ((lookupKey.controllerName !== undefined) && (lookupKey.moduleTagName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->getResolvedCodeAndCommentPlaceholderPairs(\" + lookupKey.controllerName + \", \" + \n            lookupKey.moduleTagName + \", \" + snippetType + \", \" + snippetName + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Module\";\n    }\n    else if ((lookupKey.controllerName !== undefined) && (lookupKey.taskName !== undefined) && \n            (lookupKey.programName !== undefined) && (lookupKey.routineName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->getResolvedCodeAndCommentPlaceholderPairs(\" + lookupKey.controllerName + \", \" + \n            lookupKey.taskName + \", \" + lookupKey.programName + \", \" + lookupKey.routineName + \", \" + \n            snippetType + \", \" + snippetName + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Routine\";\n    }\n    /*\n    FUTURE:\n    else if ((lookupKey.className !== undefined) && (lookupKey.usageScenario !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->getResolvedCodeAndCommentPlaceholderPairs(\" + lookupKey.className + \", \" + \n            lookupKey.usageScenario + \", \" + snippetType + \", \" + snippetName + \")\");\n            \n        // Set the lookup key type\n        lookupKeyType = \"Raw\";\n    }\n    */\n    else {\n        // Debug Messages\n        logErrorMessage(thisCallStackLevel, \"getResolvedCodeAndCommentPlaceholderPairs doesn't have a valid lookup key.\");\n    }\n    \n    // Default the return value as an empty array\n    var codeAndCommentPlaceholderPairs = [];\n    \n    // Create the regex objects for pattern matching\n\tvar reCode = new RegExp(CodeDynamicRefsRegex, \"mg\");        //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n\tvar reNonCode = new RegExp(NonCodeDynamicRefsRegex, \"mg\");  //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    \n    // Pull the code & comment for this snippet\n    var thisCode = null;\n\tvar thisCommentPlaceholder = null;\n    switch(snippetType) {\n        case CodeKeyword:\n            if (lookupKeyType == \"Module\") {\n                thisCode = getModuleSnippetCode(msg, lookupKey.controllerName, lookupKey.moduleTagName, snippetName);\n            }\n            /*\n            FUTURE:\n            else if (lookupKeyType == \"Raw\") {\n                thisCode = getSnippetCode(msg, lookupKey.className, lookupKey.usageScenario, snippetName);\n            }\n            */\n\t        thisCommentPlaceholder = \"{Comment[\" + snippetName + \"]}\";\n            break;\n            \n        case RoutineCodeKeyword:\n            if (lookupKeyType == \"Module\") {\n                thisCode = getRoutineSnippetCodeForModule(msg, lookupKey.controllerName, lookupKey.moduleTagName, snippetName);\n            }\n            else if (lookupKeyType == \"Routine\") {\n                thisCode = getRoutineSnippetCode(msg, lookupKey.controllerName, lookupKey.taskName, lookupKey.programName, lookupKey.routineName, snippetName);\n            }\n\t        thisCommentPlaceholder = \"{RoutineComment[\" + snippetName + \"]}\";\n            break;\n            \n        case DerivedKeyword:\n            if (lookupKeyType == \"Module\") {\n                thisCode = getModuleDerivedCode(msg, lookupKey.controllerName, lookupKey.moduleTagName, snippetName);\n            }\n            /*\n            FUTURE:\n            else if (lookupKeyType == \"Raw\") {\n                thisCode = getDerivedCode(msg, snippetName);\n            }\n            */\n\t        thisCommentPlaceholder = \"{DerivedComment[\" + snippetName + \"]}\";\n            break;\n    }\n\t\n\t// Debug Messages\n    logTraceMessage(thisCallStackLevel, \"    \" + \"thisCode = \" + thisCode);\n    logTraceMessage(thisCallStackLevel, \"    \" + \"thisCommentPlaceholder = \" + thisCommentPlaceholder);\n\t\n    // Test if the given snippet could be found\n    if ((thisCode !== null) && (thisCode !== undefined)) {\n        // Code exists.\n        // Default the return value to an array with the base code-comment placeholder pair\n        codeAndCommentPlaceholderPairs = [{\n            \"Code\":thisCode,\n            \"CommentPlaceholder\":thisCommentPlaceholder\n        }];\n        \n        // Default looping variables\n    \tvar loopCounter = 0;\n    \tvar ptr = 0;\n    \tvar maxLoops = 5000;\n    \t\n    \t// Iterate the list of code-comment pairs as long as the pointer is valid & the max loop counter hasn't been exceeded.\n    \twhile ((ptr < codeAndCommentPlaceholderPairs.length) && (loopCounter < maxLoops)) {\n    \t    // Pull a reference to the current code & comment placeholder\n    \t    var codeAndCommentPlaceholder_i = codeAndCommentPlaceholderPairs[ptr];\n    \t    \n    \t    // Debug Messages\n            logTraceMessage(thisCallStackLevel, \"    \" + \"Initial:  ptr = \" + ptr + \", count = \" + codeAndCommentPlaceholderPairs.length + \", loopCounter = \" + loopCounter);\n    \t    \n    \t    // Start each regex object back at the beginning on every pass through the loop\n    \t    reCode.lastIndex = 0;\n    \t    reNonCode.lastIndex = 0;\n    \t    \n    \t\t// Pull out the parameters\n    \t\tvar code_i = codeAndCommentPlaceholder_i.Code;\n    \t\tvar commentPlaceholder_i = codeAndCommentPlaceholder_i.CommentPlaceholder;\n    \t\t\n    \t\t// Debug Messages\n            logTraceMessage(thisCallStackLevel, \"    \" + \"Initial code_i = \" + code_i);\n            logTraceMessage(thisCallStackLevel, \"    \" + \"Initial commentPlaceholder_i = \" + commentPlaceholder_i);\n    \t\t\n    \t\t// Resolve any non-code references\n    \t\tif (reNonCode.test(code_i)) {\n    \t\t    // Debug Messages\n                logTraceMessage(thisCallStackLevel, \"    \" + \"Resolving non-code references.\");\n                \n    \t\t\t// Has at least 1 non-code reference\n    \t\t\tcode_i = resolveNonCodeReferences(msg, lookupKey, code_i);\n    \t\t\t\n    \t\t\t// Push result back to the list item in case no splits or code reference resolutions occur.\n    \t\t\tcodeAndCommentPlaceholder_i.Code = code_i;\n    \t\t}\n    \t\t\n    \t\t// Count the number of End of Segment markers\n    \t\tvar eosCount = (code_i.length - code_i.replace(new RegExp(endOfSegmentMarker, 'g'), \"\").length) / endOfSegmentMarker.length;\n    \t\t\n    \t\t// Debug Messages\n            logTraceMessage(thisCallStackLevel, \"    \" + \"End of Segment Marker Count = \" + eosCount.toString() + \"; Ends with EOS = \" + code_i.endsWith(endOfSegmentMarker).toString());\n    \t\tlogVerboseMessage(thisCallStackLevel, \"        \" + \"code_i.length = \" + code_i.length.toString());\n    \t\tlogVerboseMessage(thisCallStackLevel, \"        \" + \"code_i.replace(endOfSegmentMarkers).length = \" + code_i.replace(new RegExp(endOfSegmentMarker, 'g'), \"\").length.toString());\n    \t\tlogVerboseMessage(thisCallStackLevel, \"        \" + \"endOfSegmentMarker = (\" + endOfSegmentMarker + \"); endOfSegmentMarker.length = \" + endOfSegmentMarker.length.toString());\n    \t\t\n    \t\t// Test if the current item's code needs to be split into segments.  If no split is required, test if it needs a code reference replacement.\n    \t\t// The code needs to be split if there is more than 1 End Of Segment (EOS) Marker OR there is only 1 and it isn't at the end of the string.\n    \t\tif ((eosCount > 1) || (eosCount == 1 && !(code_i.endsWith(endOfSegmentMarker)))) {\n    \t\t\t// The current code needs splitting.\n    \t\t\t// Debug Messages\n                logTraceMessage(thisCallStackLevel, \"    \" + \"Current item needs splitting, eosCount = \" + eosCount);\n    \t\t\t\n    \t\t\t// Split the current code into segments by splitting on the End Of Segment (EOS) marker\n    \t\t\t// Note: string.split does NOT have a remove empty entries option like .NET.  Need to follow this with a filter statement.\n    \t\t\tvar tempCodeSegments = code_i.split(endOfSegmentMarker);\n    \t\t\t\n    \t\t\t// Delete all empty items\n    \t\t\t// Note:  Ignore empty segment!  Replicates .NET's System.String.Split(Delimiter, StringSplitOptions.RemoveEmptyEntries)\n    \t\t\ttempCodeSegments = tempCodeSegments.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            // Element is NOT null or undefined.  Return true for non-blank items to keep them and false for blank items to filter them out.\n                            return (element.length > 0);\n                        }\n                    });\n                \n                // Debug Messages\n                logTraceMessage(thisCallStackLevel, \"    \" + \"The current code segment split into \" + tempCodeSegments.length + \" pieces.\");\n                logTraceMessage(thisCallStackLevel, \"    \" + \"Preparing to iterate the segment's pieces.\");\n                \n    \t\t\t// Iterate the code segments IN REVERSE ORDER to manipulate them & insert them back into the base list one at a time.\n    \t\t\tfor (var i = tempCodeSegments.length - 1; i >= 0; i--) {\n    \t\t\t    // Debug Messages\n    \t\t\t    logTraceMessage(thisCallStackLevel, \"        \" + \"i = \" + i);\n    \t\t\t    logTraceMessage(thisCallStackLevel, \"        \" + \"Split piece = \" + tempCodeSegments[i]);\n    \t\t\t    \n    \t\t\t\t// Test if this is the LAST code segment AND that the original code did NOT end with an EOS marker\n    \t\t\t\tif ((i == tempCodeSegments.length - 1) && !(code_i.endsWith(endOfSegmentMarker))) {\n    \t\t\t\t    // Debug Messages\n    \t\t\t        logTraceMessage(thisCallStackLevel, \"        \" + \"This is the last code segment and it did NOT end in an EOS marker.  Inserting the code segment without an EOS marker appended.\");\n    \t\t\t        \n    \t\t\t\t\t// Insert the code segment WITHOUT an EOS marker appended to it as the next item after the one currently being processed.\n    \t\t\t\t\t// Copy the current code's comment place holder to apply it to each segment being split apart.\n    \t\t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": tempCodeSegments[i], \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t\t}\n    \t\t\t\telse {\n    \t\t\t\t    // Debug Messages\n    \t\t\t        logTraceMessage(thisCallStackLevel, \"        \" + \"This is the last code segment and it did end in an EOS marker OR it is not the last code segment.  Inserting the code segment with an EOS marker appended.\");\n    \t\t\t        \n    \t\t\t\t\t// Insert the code segment WITH an EOS marker appended to it as the next item after the one currently being processed.\n    \t\t\t\t\t// Copy the current code's comment place holder to apply it to each segment being split apart.\n    \t\t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": tempCodeSegments[i] + endOfSegmentMarker, \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\t// Debug Messages\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"    \" + \"Done iterating the segment's pieces.\");\n    \t\t\t\n    \t\t\t// Test if there was a blank segment at the beginning of the original code that was dropped\n    \t\t\tif (code_i.startsWith(endOfSegmentMarker)) {\n    \t\t\t    // Debug Messages\n    \t\t\t    logTraceMessage(thisCallStackLevel, \"    \" + \"The original code started with an EOS marker. Inserting a segment with the EOS marker only.\");\n    \t\t\t    \n    \t\t\t\t// Insert a blank code segment with appended EOS marker as the next item after the one currently being processed.\n    \t\t\t\t// Copy the current code's comment place holder to apply it to each segment being split apart.\n    \t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": endOfSegmentMarker, \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t}\n    \t\t\t\n    \t\t\t// Debug Messages\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"    \" + \"Removing the original piece at ptr = \" + ptr);\n    \t\t\t\n    \t\t\t// Remove the original code from the list since it has been split apart and all of the pieces have been inserted back into the list\n    \t\t\t// Note: splice(Index, 1) is equivilent to .NET's Array.RemoveAt(Index)\n    \t\t\tcodeAndCommentPlaceholderPairs.splice(ptr, 1);\n    \t\t\t\n    \t\t\t// Do NOT increment the list pointer.  The code segements that were just added start at the current list pointer.\n    \t\t}\n    \t\telse if (reCode.test(code_i)) {\n    \t\t\t// Has at least 1 code reference\n    \t\t\t// Debug Messages\n                logTraceMessage(thisCallStackLevel, \"    \" + \"Current item has at least 1 code reference to resolve.\");\n    \t\t\t\n    \t\t\t// The current code  needs a code reference replacement.\n    \t\t\t// Retrieve the first Match & the Captures.\n    \t\t\treCode.lastIndex = 0;\n                var match = reCode.exec(code_i);\n                \n                // A match was found.\n                // Pull the match information\n                var wholeMatch = match[0];\n                var operator = match[1];\n                var operand = match[2];\n    \t\t\tvar leftOfMatchString = code_i.substring(0, match.index);\n    \t\t\tvar rightOfMatchString = code_i.substring(reCode.lastIndex);\n    \t\t\t\n    \t\t\t// Debug Messages\n                logTraceMessage(thisCallStackLevel, \"        \" + \"wholeMatch = \" + wholeMatch);\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"        \" + \"operator = \" + operator);\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"        \" + \"operand = \" + operand);\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"        \" + \"leftOfMatchString = \" + leftOfMatchString);\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"        \" + \"rightOfMatchString = \" + rightOfMatchString);\n    \t\t\tlogTraceMessage(thisCallStackLevel, \"    \" + \"Pulling resolved c-cph pairs...\");\n    \t\t\t\n    \t\t\t// Pull the code-comment pairs for the requested code snippet\n    \t\t\tvar requestedCodeAndCommentPlaceholderPairs = getResolvedCodeAndCommentPlaceholderPairs(msg, lookupKey, operator, operand);\n    \t\t\t\n    \t\t\t// Debug Messages\n                logTraceMessage(thisCallStackLevel, \"    \" + \"Pull resulted in \" + requestedCodeAndCommentPlaceholderPairs.length + \" pairs.\");\n    \t\t\t\n    \t\t\t// Test if anything was returned.\n    \t\t\tif (requestedCodeAndCommentPlaceholderPairs.length === 0) {\n    \t\t\t    // Debug Messages\n                    logTraceMessage(thisCallStackLevel, \"    \" + \"Nothing was found.  Replace code reference with an empty string.\");\n                    \n    \t\t\t\t// Nothing was found.  Replace code reference with an empty string.\n    \t\t\t\tcodeAndCommentPlaceholderPairs[ptr].Code = leftOfMatchString + rightOfMatchString;\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\t// Prepend the text in the original code to the LEFT of the code reference to the code in the FIRST code-comment pair returned.\n    \t\t\t\t// Previous splitting code ensures that no additional split will be required.\n    \t\t\t\trequestedCodeAndCommentPlaceholderPairs[0].Code = leftOfMatchString + requestedCodeAndCommentPlaceholderPairs[0].Code;\n    \t\t\t\t\n    \t\t\t\t// Debug Messages\n                    logTraceMessage(thisCallStackLevel, \"    \" + \"Preparing to iterate the returned pieces.\");\n    \t\t\t\t\n    \t\t\t\t// Iterate the code-comment pairs IN REVERSE ORDER to manipulate them & insert them back into the base list one at a time.\n    \t\t\t\tfor (var i = requestedCodeAndCommentPlaceholderPairs.length - 1; i >= 0; i--) {\n    \t\t\t\t    // Debug Messages\n                        logTraceMessage(thisCallStackLevel, \"        \" + \"i = \" + i);\n                        \n    \t\t\t\t\t// Test if this is the LAST element returned and whether or not a split (dual insert) or non-split (single insert) should be performed\n    \t\t\t\t\tif (i == requestedCodeAndCommentPlaceholderPairs.length - 1) {\n    \t\t\t\t\t\t// Test if the LAST code-comment pair ends with an End of Segment marker.\n    \t\t\t\t\t\tif (requestedCodeAndCommentPlaceholderPairs[i].Code.endsWith(endOfSegmentMarker)) {\n    \t\t\t\t\t\t\t// Dual insert\n    \t\t\t\t\t\t\t// The LAST code-comment pair should NOT be appended with the text in the original code to the RIGHT of the code reference.\n    \t\t\t\t\t\t\t// The text in the original code to the RIGHT of the code reference should be inserted as its own code segment IF AND ONLY IF it is NOT blank.\n    \t\t\t\t\t\t\t// Insert the code-comment pair as the next item after the one currently being processed.\n    \t\t\t\t\t\t\t// The comment should NOT retain the comment from the last requested segment.\n    \t\t\t\t\t\t\tif (rightOfMatchString.length > 0) {\n    \t\t\t\t\t\t\t    // Debug Messages\n                                    logTraceMessage(thisCallStackLevel, \"        \" + \"Last resolved piece ended in an EOS marker.  Inserting rightOfMatchString as a new return piece.\");\n                                    logTraceMessage(thisCallStackLevel, \"            \" + \"commentPlaceholder_i = \" + commentPlaceholder_i);\n                                    \n    \t\t\t\t\t\t\t    // Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": rightOfMatchString, \"CommentPlaceholder\": commentPlaceholder_i});\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse {\n    \t\t\t\t\t\t\t// Single insert\n    \t\t\t\t\t\t\t// Debug Messages\n                                logTraceMessage(thisCallStackLevel, \"        \" + \"Last resolved piece did NOT end in an EOS marker.  Appending rightOfMatchString to the end of it.\");\n                                \n    \t\t\t\t\t\t\t// The LAST code-comment pair should be appended with the text in the original code to the RIGHT of the code reference.\n    \t\t\t\t\t\t\t// Append the text in the original code to the RIGHT of the code reference to the code in the LAST code-comment pair returned.\n    \t\t\t\t\t\t\trequestedCodeAndCommentPlaceholderPairs[i].Code = requestedCodeAndCommentPlaceholderPairs[i].Code + rightOfMatchString;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\t// Debug Messages\n                        logTraceMessage(thisCallStackLevel, \"        \" + \"Inserting resolved piece as a new return piece.\");\n                        logTraceMessage(thisCallStackLevel, \"            \" + \"commentPlaceholder_i = \" + commentPlaceholder_i);\n                        logTraceMessage(thisCallStackLevel, \"            \" + \"requestedCodeAndCommentPlaceholderPairs[i].CommentPlaceholder = \" + requestedCodeAndCommentPlaceholderPairs[i].CommentPlaceholder);\n                        \n    \t\t\t\t\t// Insert the code-comment pair as the next item after the one currently being processed.\n    \t\t\t\t\t// Prepend the current code's comment place holder to each code-comment pair.\n    \t\t\t\t\t// Note: splice(Index, 0, NewItem) is equivilent to .NET's Array.Insert(Index, NewItem)\n    \t\t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr + 1, 0, {\"Code\": requestedCodeAndCommentPlaceholderPairs[i].Code, \"CommentPlaceholder\": commentPlaceholder_i + requestedCodeAndCommentPlaceholderPairs[i].CommentPlaceholder});\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\t// Debug Messages\n                    logTraceMessage(thisCallStackLevel, \"    \" + \"Done iterating the returned pieces.\");\n    \t\t\t\tlogTraceMessage(thisCallStackLevel, \"    \" + \"Removing the original piece at ptr = \" + ptr);\n    \t\t\t\t\n    \t\t\t\t// Remove the original code from the list since it has been split apart and all of the pieces have been inserted back into the list\n    \t\t\t\t// Note: splice(Index, 1) is equivilent to .NET's Array.RemoveAt(Index)\n    \t\t\t\tcodeAndCommentPlaceholderPairs.splice(ptr, 1);\n    \t\t\t\t\n    \t\t\t\t// Do NOT increment the list pointer.  The code segements that were just added start at the current list pointer.\n    \t\t\t}\n            }\n            else {\n            \t// No split or code reference replacement was required\n            \t// Increment the list pointer\n            \tptr++;\n            }\n            \n    \t\t// Increment the loop counter\n    \t\tloopCounter++;\n    \t\t\n    \t\t// Debug Messages\n            logTraceMessage(thisCallStackLevel, \"    \" + \"Final:  ptr = \" + ptr + \", count = \" + codeAndCommentPlaceholderPairs.length + \", loopCounter = \" + loopCounter);\n    \t} // End of while\n    }\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"<-- returnValue = (\" + codeAndCommentPlaceholderPairs + \")\");\n    \n    // Return the result\n    return codeAndCommentPlaceholderPairs;\n};\n/*********************************************************/\n\n\n/*********************************************************/\nvar getResolvedCodeSegments = function (msg, lookupKey, snippetType, snippetName) {\n    // This function pulls the code for the given lookup key, snippet type, and snippet name and resolves it into the code segment-comment pairs.\n    //   i.e. A rung is a code sgement in RSLogix 5000 ladder logic.\n    //\n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"Comment\":comment_i\n    // }]\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getResolvedCodeSegments\";\n    \n    // Determine what format the lookupKey is in\n    var lookupKeyType = null;\n    if ((lookupKey.controllerName !== undefined) && (lookupKey.moduleTagName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->getResolvedCodeSegments(\" + lookupKey.controllerName + \", \" + \n            lookupKey.moduleTagName + \", \" + snippetType + \", \" + snippetName + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Module\";\n    }\n    else if ((lookupKey.controllerName !== undefined) && (lookupKey.taskName !== undefined) && \n            (lookupKey.programName !== undefined) && (lookupKey.routineName !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->getResolvedCodeSegments(\" + lookupKey.controllerName + \", \" + \n            lookupKey.taskName + \", \" + lookupKey.programName + \", \" + lookupKey.routineName + \", \" + \n            snippetType + \", \" + snippetName + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Routine\";\n    }\n    /*\n    FUTURE:\n    else if ((lookupKey.className !== undefined) && (lookupKey.usageScenario !== undefined)) {\n        // Debug Messages\n        logTraceMessage(thisCallStackLevel, \"-->getResolvedCodeSegments(\" + lookupKey.className + \", \" + \n            lookupKey.usageScenario + \", \" + snippetType + \", \" + snippetName + \")\");\n        \n        // Set the lookup key type\n        lookupKeyType = \"Raw\";\n    }\n    */\n    else {\n        // Debug Messages\n        logErrorMessage(thisCallStackLevel, \"getResolvedCodeSegments doesn't have a valid lookup key.\");\n    }\n    \n    // Default the return value\n    var returnValue = null;\n    \n    // Resolve the entry point code to code-comment placeholder pairs\n    var codeCommentPlaceholderPairs = getResolvedCodeAndCommentPlaceholderPairs(msg, lookupKey, snippetType, snippetName);\n    \n    // Test if anything was returned\n    if ((codeCommentPlaceholderPairs === null) || (codeCommentPlaceholderPairs === undefined)) {\n        // Log a validation error\n        if (lookupKeyType == \"Module\") {\n            logValidationErrorMessage(thisCallStackLevel, lookupKey.controllerName + \"'s \" + lookupKey.moduleTagName + \" failed to return a resolved code-comment placeholders array for \" + \n                \"snippetType = \" + snippetType + \" and snippetName = \" + snippetName + \".\");\n        }\n        else if (lookupKeyType == \"Routine\") {\n            logValidationErrorMessage(thisCallStackLevel, lookupKey.controllerName + \"'s \" + lookupKey.routineName + \" failed to return a resolved code-comment placeholders array for \" + \n                \"snippetType = \" + snippetType + \" and snippetName = \" + snippetName + \".\");\n        }\n        /*\n        FUTURE:\n        else if (lookupKeyType == \"Raw\") {\n            logValidationErrorMessage(thisCallStackLevel, lookupKey.className + \"'s \" + lookupKey.usageScenario + \" failed to return a resolved code-comment placeholders array for \" + \n                \"snippetType = \" + snippetType + \" and snippetName = \" + snippetName + \".\");\n        }\n        */\n    }\n    else {\n        // Object exists\n        // Test if there is anything to iterate\n        if (codeCommentPlaceholderPairs.length <= 0) {\n            // Log a validation error\n            if (lookupKeyType == \"Module\") {\n                logValidationErrorMessage(thisCallStackLevel, lookupKey.controllerName + \"'s \" + lookupKey.moduleTagName + \" failed to return any resolved code-comment placeholders for \" + \n                    \"snippetType = \" + snippetType + \" and snippetName = \" + snippetName + \".\");\n            }\n            else if (lookupKeyType == \"Routine\") {\n                logValidationErrorMessage(thisCallStackLevel, lookupKey.controllerName + \"'s \" + lookupKey.routineName + \" failed to return any resolved code-comment placeholders for \" + \n                    \"snippetType = \" + snippetType + \" and snippetName = \" + snippetName + \".\");\n            }\n            /*\n            FUTURE:\n            else if (lookupKeyType == \"Raw\") {\n                logValidationErrorMessage(thisCallStackLevel, lookupKey.className + \"'s \" + lookupKey.usageScenario + \" failed to return any resolved code-comment placeholders for \" + \n                    \"snippetType = \" + snippetType + \" and snippetName = \" + snippetName + \".\");\n            }\n            */\n        }\n        else {\n            // Iterate the code-comment placeholder pairs to resolve the comments\n            for (var i = 0; i < codeCommentPlaceholderPairs.length; i++){\n                // Pull a reference to the current code-comment placeholder pair\n                var codeCommentPlaceholderPair_i = codeCommentPlaceholderPairs[i];\n                \n                // Pull the pieces\n                var code_i = codeCommentPlaceholderPair_i.Code;\n                var commentPlaceholder_i = codeCommentPlaceholderPair_i.CommentPlaceholder;\n                \n                // Resolve the comment placeholder\n                var comment_i = resolveCommentPlaceholders(msg, lookupKey, commentPlaceholder_i);\n                \n                if (returnValue === null) {\n                    // Create the initial object\n                    returnValue = [];\n                }\n                \n                // Add the pieces to the return dataset\n                returnValue.push({\n                    \"Code\": code_i,\n                    \"Comment\": comment_i\n                });\n            }\n        }\n    }\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"<-- returnValue = (\" + returnValue + \")\");\n    \n    // Return the result\n    return returnValue;\n};\n/*********************************************************/\n\n\n\n/*********************************************************/\n/***************************************\n* Main external helper function calls  *\n****************************************/\nvar resolveModuleNonCodeReferences = function (msg, controllerName, moduleTagName, stringToResolve) {\n    // This function resolves the given string using the given module as context.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"resolveModuleNonCodeReferences\";\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"Start of resolveModuleNonCodeReferences(\" + controllerName + \", \" + moduleTagName + \", \" + stringToResolve + \").\");\n    \n    // Return the result\n    return resolveNonCodeReferences(msg, {\"controllerName\":controllerName, \"moduleTagName\":moduleTagName}, stringToResolve);\n};\n\nvar resolveRoutineNonCodeReferences = function (msg, controllerName, taskName, programName, routineName, stringToResolve) {\n    // This function resolves the given string using the given routine as context.\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"resolveRoutineNonCodeReferences\";\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"Start of resolveRoutineNonCodeReferences(\" + controllerName + \", \" + taskName + \", \" + programName + \", \" + routineName + \", \" + stringToResolve + \").\");\n    \n    // Return the result\n    return resolveNonCodeReferences(msg, {\"controllerName\":controllerName, \"taskName\":taskName, \"programName\":programName, \"routineName\":routineName}, stringToResolve);\n};\n\nvar getModuleResolvedMainCodeSegments = function (msg, controllerName, moduleTagName) {\n    // This function pulls the entry point code for the given module and resolves it into the code segment-comment pairs.\n    //   i.e. A rung is a code sgement in RSLogix 5000 ladder logic.\n    //\n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"Comment\":comment_i\n    // }]\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getModuleResolvedMainCodeSegments\";\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"Start of getModuleResolvedMainCodeSegments(\" + controllerName + \", \" + moduleTagName + \").\");\n    \n    // Return the result\n    return getResolvedCodeSegments(msg, {\"controllerName\":controllerName, \"moduleTagName\":moduleTagName}, \"Code\", \"Main\");\n};\n\nvar getRoutineResolvedCodeSegments = function (msg, controllerName, taskName, programName, routineName, snippetName) {\n    // This function pulls the code for the given routine's snippet and resolves it into the code segment-comment pairs.\n    //   i.e. A rung is a code sgement in RSLogix 5000 ladder logic.\n    //\n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"Comment\":comment_i\n    // }]\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineResolvedCodeSegments\";\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"Start of getRoutineResolvedCodeSegments(\" + controllerName + \", \" + taskName + \", \" + programName + \", \" + routineName + \").\");\n    \n    // Return the result\n    return getResolvedCodeSegments(msg, {\"controllerName\":controllerName, \"taskName\":taskName, \"programName\":programName, \"routineName\":routineName}, \"RoutineCode\", snippetName);\n};\n\nvar getRoutineResolvedMainCodeSegments = function (msg, controllerName, taskName, programName, routineName) {\n    // This function pulls the entry point code for the given routine and resolves it into the code segment-comment pairs.\n    //   i.e. A rung is a code sgement in RSLogix 5000 ladder logic.\n    //\n    // Return value signature:\n    // [{\n    //      \"Code\":code_i,\n    //      \"Comment\":comment_i\n    // }]\n    \n    // Set variables for logging\n    var thisCallStackLevel = \"getRoutineResolvedMainCodeSegments\";\n    \n    // Debug Messages\n    logTraceMessage(thisCallStackLevel, \"Start of getRoutineResolvedMainCodeSegments(\" + controllerName + \", \" + taskName + \", \" + programName + \", \" + routineName + \").\");\n    \n    // Return the result\n    return getResolvedCodeSegments(msg, {\"controllerName\":controllerName, \"taskName\":taskName, \"programName\":programName, \"routineName\":routineName}, \"RoutineCode\", \"Main\");\n};\n/*********************************************************/\n\n\n\n\n\n\n/*********************************************************/\n// Add future functions here\n/*********************************************************/\n\n\n\n// Store all locally created functions to the global context\nglobal.set(\"getModuleParameter\", getModuleParameter);                                   //function (msg, controllerName, moduleTagName, parameterName)\n\nglobal.set(\"getCodeSnippet\", getCodeSnippet);                                           //function (msg, className, usageScenario, snippetName)\nglobal.set(\"getModuleSnippet\", getModuleSnippet);                                       //function (msg, controllerName, moduleTagName, snippetName)\nglobal.set(\"getModuleSnippetCode\", getModuleSnippetCode);                               //function (msg, controllerName, moduleTagName, snippetName)\nglobal.set(\"getModuleSnippetComment\", getModuleSnippetComment);                         //function (msg, controllerName, moduleTagName, snippetName)\n\nglobal.set(\"getDerivedItem\", getDerivedItem);                                           //function (msg, itemName)\nglobal.set(\"getModuleDerivedItem\", getModuleDerivedItem);                               //function (msg, controllerName, moduleTagName, itemName)\nglobal.set(\"getModuleDerivedCode\", getModuleDerivedCode);                               //function (msg, controllerName, moduleTagName, itemName)\nglobal.set(\"getModuleDerivedComment\", getModuleDerivedComment);                         //function (msg, controllerName, moduleTagName, itemName)\n\nglobal.set(\"getRoutineParameter\", getRoutineParameter);                                 //function (msg, controllerName, taskName, programName, routineName, parameterName)\nglobal.set(\"getRoutineParameterForModule\", getRoutineParameterForModule);               //function (msg, controllerName, moduleTagName, parameterName)\n\nglobal.set(\"getProgramParameter\", getProgramParameter);                                 //function (msg, controllerName, taskName, programName, parameterName)\nglobal.set(\"getProgramParameterForModule\", getProgramParameterForModule);               //function (msg, controllerName, moduleTagName, parameterName)\n\nglobal.set(\"getTaskParameter\", getTaskParameter);                                       //function (msg, controllerName, taskName, parameterName)\nglobal.set(\"getTaskParameterForModule\", getTaskParameterForModule);                     //function (msg, controllerName, moduleTagName, parameterName)\n\nglobal.set(\"getRoutineSnippet\", getRoutineSnippet);                                     //function (msg, controllerName, taskName, programName, routineName, snippetName)\nglobal.set(\"getRoutineSnippetCode\", getRoutineSnippetCode);                             //function (msg, controllerName, taskName, programName, routineName, snippetName)\nglobal.set(\"getRoutineSnippetComment\", getRoutineSnippetComment);                       //function (msg, controllerName, taskName, programName, routineName, snippetName)\nglobal.set(\"getRoutineSnippetForModule\", getRoutineSnippetForModule);                   //function (msg, controllerName, moduleTagName, snippetName)\nglobal.set(\"getRoutineSnippetCodeForModule\", getRoutineSnippetCodeForModule);           //function (msg, controllerName, moduleTagName, snippetName)\nglobal.set(\"getRoutineSnippetCommentForModule\", getRoutineSnippetCommentForModule);     //function (msg, controllerName, moduleTagName, snippetName)\n\n// Helper functions: code & comments\nglobal.set(\"resolveNonCodeReferences\", resolveNonCodeReferences);                       //function (msg, lookupKey, stringToResolve)\nglobal.set(\"resolveCommentPlaceholders\", resolveCommentPlaceholders);                   //function (msg, lookupKey, stringToResolve)\nglobal.set(\"getResolvedCodeAndCommentPlaceholderPairs\", getResolvedCodeAndCommentPlaceholderPairs);     //function (msg, lookupKey, snippetType, snippetName)\nglobal.set(\"getResolvedCodeSegments\", getResolvedCodeSegments);                         //function (msg, lookupKey, snippetType, snippetName)\n\n/***************************************\n* Main external helper function calls  *\n****************************************/\nglobal.set(\"resolveModuleNonCodeReferences\", resolveModuleNonCodeReferences);           //function (msg, controllerName, moduleTagName, stringToResolve)\nglobal.set(\"resolveRoutineNonCodeReferences\", resolveRoutineNonCodeReferences);         //function (msg, controllerName, taskName, programName, routineName, stringToResolve)\nglobal.set(\"getModuleResolvedMainCodeSegments\", getModuleResolvedMainCodeSegments);     //function (msg, controllerName, moduleTagName)\nglobal.set(\"getRoutineResolvedCodeSegments\", getRoutineResolvedCodeSegments);           //function (msg, controllerName, taskName, programName, routineName, snippetName)\nglobal.set(\"getRoutineResolvedMainCodeSegments\", getRoutineResolvedMainCodeSegments);   //function (msg, controllerName, taskName, programName, routineName)\n\n\n/*********************************************************/\n// Add future functions here\n/*********************************************************/\n\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done loading data resolver functions\");\n\n// Pass incoming message on\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 850,
    "y": 120,
    "wires": [
      []
    ]
  },
  {
    "id": "388f2059.2b812",
    "type": "link in",
    "z": "98969df7.44714",
    "name": "Pull & Manipulate Data",
    "links": [
      "97648f1d.2c451",
      "9189d9c8.cb5b48"
    ],
    "x": 215,
    "y": 100,
    "wires": [
      [
        "cd421859.440e78",
        "cd595aa3.7d9278",
        "8b160ec6.4cf93",
        "3b4da33b.08893c",
        "762ee981.c405b8"
      ]
    ]
  },
  {
    "id": "cd421859.440e78",
    "type": "function",
    "z": "98969df7.44714",
    "name": "ILock & Perm Options",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Ilock and Perm Options\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n\nmsg.payload = {\n    \"InterlockOptions\":{\n        \"MinimumIndex\":0,     \t\t\t// The starting index to use\n        \"MaximumIndex\":15,    \t\t\t// The ending index to use\n        \"InsertPlaceHolders\":false,     // Enables inserting placeholder branches for indexes that aren't specified\n        \"MinimumIntegerDigits\": 2       // The minimum string length when printing out the current index\n    },\n    \"PermissiveOptions\":{\n        \"MinimumIndex\":0,     \t\t\t// The starting index to use\n        \"MaximumIndex\":15,   \t\t\t// The ending index to use\n        \"InsertPlaceHolders\":false,     // Enables inserting placeholder branches for indexes that aren't specified\n        \"MinimumIntegerDigits\": 2       // The minimum string length when printing out the current index\n    },\n};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 500,
    "y": 380,
    "wires": [
      [
        "c19341ac.cd35b"
      ]
    ]
  },
  {
    "id": "75bd4bb4.aec224",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Pivot Permissives",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pivot Permissives\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Declare variables\n/*{\n    \"Permissives_Pivoted\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Permissives\":[{\n            \"Index\":index_i,\n            \"ConditionCode\":conditionCode_i,\n            \"Description\":description_i,\n            \"IsDebounced\":isDebounced_i,\n            \"DebounceTime\":debounceTime_i,\n            \"OkayState\":okayState_i,\n            \"IsBypassable\":isBypassable_i,\n            \"CanNavigate\":canNavigate_i,\n            \"AssociatedTag\":associatedTag_i\n        }],\n    }]\n}*/\nvar returnDataSet = [];\n\n// Pull all of the permissive options to use\nvar minimumIndex = Number(msg.payload.PermissiveOptions.MinimumIndex);\nvar maximumIndex = Number(msg.payload.PermissiveOptions.MaximumIndex);\nvar insertPlaceHolders = parseBoolean(msg.payload.PermissiveOptions.InsertPlaceHolders);\n\n// Pre-sort msg.payload.Permissives\nmsg.payload.Permissives.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) Controller then\n    //  b) ModuleTagName then\n    //  c) Index (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if ((element1.Controller < element2.Controller)) {return -1;}\n    else if ((element1.Controller > element2.Controller)) {return +1;}\n    else if ((element1.ModuleTagName < element2.ModuleTagName)) {return -1;}\n    else if ((element1.ModuleTagName > element2.ModuleTagName)) {return +1;}\n    else if (isNaN(element1.Index) && !isNaN(element2.Index)) {return -1;}\n    else if (!isNaN(element1.Index) && isNaN(element2.Index)) {return +1;}\n    else if ((Number(element1.Index) < Number(element2.Index))) {return -1;}\n    else if ((Number(element1.Index) > Number(element2.Index))) {return +1;}\n    else {return 0;}\n});\n\n//Iterate the rows in the Permissives data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.Permissives.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.Permissives[i];\n    \n    // Pull the current row's data\n    var controller_i = row.Controller;\n    var moduleTagName_i = row.ModuleTagName;\n    var index_i = row.Index;\n    var conditionCode_i = row.ConditionCode;\n    var description_i = row.Description;\n    var isDebounced_i = parseBoolean(row.IsDebounced);\n    var debounceTime_i = Number(row.DebounceTime);\n    var okayState_i = parseBoolean(row.OkayState);\n    var isBypassable_i = parseBoolean(row.IsBypassable);\n    var canNavigate_i = parseBoolean(row.CanNavigate);\n    var associatedTag_i = row.AssociatedTag;\n    \n    // Test if this row is missing the row's primary key info\n    if ((controller_i !== null) && (controller_i !== undefined) && \n            (moduleTagName_i !== null) && (moduleTagName_i !== undefined)) {\n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Row = \" + controller_i + \"-\" + moduleTagName_i + \".\");\n        \n        // Test if the index is a number or not\n        if (isNaN(index_i)) {\n            // Index is not a number\n            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": cannot add permissive because index (\" +\n                    index_i + \") is not a number.\");\n        }\n        else {\n            // Index is a number\n            // Force to be an integer\n            index_i = Math.trunc(index_i)\n            \n            // Get a list of all elements matching the current Controller & Module Tag Name\n            var tempModulesArray = returnDataSet.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === controller_i) &&\n                            (element.ModuleTagName === moduleTagName_i));\n                    }\n                });\n            \n            // Debug Messages\n            //logDebugMessage(thisCallStackLevel, \"Number of Elements = \" + tempModulesArray.length;\n            \n            // Test if the module exists yet or not.\n            if (tempModulesArray.length <= 0) {\n                // Cannot find this ClassName in the returnDataSet\n                var tempObj = {\n                        \"Controller\":controller_i,\n                        \"ModuleTagName\":moduleTagName_i,\n                        \"Permissives\":[]\n                    }\n                \n                // Insert all placeholders if configured to do so\n                if (insertPlaceHolders) {\n                    for (var j = minimumIndex; j <= maximumIndex; j++) {\n                        // Add a new object to the return set\n                        tempObj.Permissives.push({\n                                \"Index\":j,\n                                \"ConditionCode\":null,\n                                \"Description\":\"\",\n                                \"IsDebounced\":false,\n                                \"DebounceTime\":0,\n                                \"OkayState\":0,\n                                \"IsBypassable\":false,\n                                \"CanNavigate\":false,\n                                \"AssociatedTag\":\"\"\n                            });\n                    }\n                }\n                \n                // Add a new object to the return set\n                returnDataSet.push(tempObj);\n            }\n            \n            // Re-pull list of all elements matching the current Controller & Module Tag Name\n            tempModulesArray = returnDataSet.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === controller_i) &&\n                            (element.ModuleTagName === moduleTagName_i));\n                    }\n                });\n            \n            // Test if the module exists yet or not.\n            if (tempModulesArray.length > 0) {\n                // Already found this module in the returnDataSet\n                // Cache a reference to the first element for the current moduloe\n                var tempModule = tempModulesArray[0];\n                \n                //Test if index is valid\n                if ((index_i < minimumIndex) || (index_i > maximumIndex)) {\n                    // Index is outside of acceptable range\n                    // Log a validation error\n                    logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": permissive index (\" + index_i + \n                        \") is outside of the acceptable range of \" + minimumIndex + \" to \" + maximumIndex);\n                }\n                else {\n                    // Index is within acceptable range\n                    // Get a list of all elements matching the current index\n                    var tempPermissivesArray = tempModule.Permissives.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.Index === index_i);\n                            }\n                        });\n                    \n                    // Test if the index exists yet or not.\n                    if (tempPermissivesArray.length > 0) {\n                        // Already found this index in the returnDataSet\n                        // Cache a reference to the first element \n                        var tempPermissive = tempPermissivesArray[0];\n                        \n                        // Test if the condition code was created as part of the placeholder insertion, but has NOT already been set\n                        if (insertPlaceHolders && (tempPermissive.ConditionCode === null)) {\n                            // Update the existing permissive\n                            tempPermissive.Index = index_i;\n                            tempPermissive.ConditionCode = conditionCode_i;\n                            tempPermissive.Description = description_i;\n                            tempPermissive.IsDebounced = isDebounced_i;\n                            tempPermissive.DebounceTime = debounceTime_i;\n                            tempPermissive.OkayState = okayState_i;\n                            tempPermissive.IsBypassable = isBypassable_i;\n                            tempPermissive.CanNavigate = canNavigate_i;\n                            tempPermissive.AssociatedTag = associatedTag_i;\n                        }\n                        else {\n                            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": cannot add permissive \" +\n                                index_i + \" to the list because it already exists.\");\n                        }\n                    }\n                    else {\n                        // Cannot find this UsageScenario in the returnDataSet\n                        // Add a new object to the return set\n                        tempModule.Permissives.push({\n                                \"Index\":index_i,\n                                \"ConditionCode\":conditionCode_i,\n                                \"Description\":description_i,\n                                \"IsDebounced\":isDebounced_i,\n                                \"DebounceTime\":debounceTime_i,\n                                \"OkayState\":okayState_i,\n                                \"IsBypassable\":isBypassable_i,\n                                \"CanNavigate\":canNavigate_i,\n                                \"AssociatedTag\":associatedTag_i\n                            });\n                    }\n                }\n            }\n            else {\n                // Cannot find this module in the returnDataSet\n                // Log a validation error\n                logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": cannot find this module immediately after adding it.\");\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload = {\n    \"Permissives_Pivoted\": returnDataSet,\n    \"PermissiveOptions\": msg.payload.PermissiveOptions\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1250,
    "y": 400,
    "wires": [
      [
        "b3da362f.ac4ca8"
      ]
    ]
  },
  {
    "id": "b92b4ca.662b8b",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Pivot Interlocks",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pivot Interlocks\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Declare variables\n/*{\n    \"Interlocks_Pivoted\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Interlocks\":[{\n            \"Index\":index_i,\n            \"ConditionCode\":conditionCode_i,\n            \"ConditionDescription\":conditionDescription_i,\n            \"IsDebounced\":isDebounced_i,\n            \"DebounceTime\":debounceTime_i,\n            \"OkayState\":okayState_i,\n            \"IsBypassable\":isBypassable_i,\n            \"CanNavigate\":canNavigate_i,\n            \"AssociatedTag\":associatedTag_i\n        }],\n    }]\n}*/\nvar returnDataSet = [];\n\n// Pull all of the interlock options to use\nvar minimumIndex = Number(msg.payload.InterlockOptions.MinimumIndex);\nvar maximumIndex = Number(msg.payload.InterlockOptions.MaximumIndex);\nvar insertPlaceHolders = parseBoolean(msg.payload.InterlockOptions.InsertPlaceHolders);\n\n// Pre-sort msg.payload.Interlocks\nmsg.payload.Interlocks.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) Controller then\n    //  b) ModuleTagName then\n    //  c) Index (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if ((element1.Controller < element2.Controller)) {return -1;}\n    else if ((element1.Controller > element2.Controller)) {return +1;}\n    else if ((element1.ModuleTagName < element2.ModuleTagName)) {return -1;}\n    else if ((element1.ModuleTagName > element2.ModuleTagName)) {return +1;}\n    else if (isNaN(element1.Index) && !isNaN(element2.Index)) {return -1;}\n    else if (!isNaN(element1.Index) && isNaN(element2.Index)) {return +1;}\n    else if ((Number(element1.Index) < Number(element2.Index))) {return -1;}\n    else if ((Number(element1.Index) > Number(element2.Index))) {return +1;}\n    else {return 0;}\n});\n\n//Iterate the rows in the Interlocks data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.Interlocks.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.Interlocks[i];\n    \n    // Pull the current row's data\n    var controller_i = row.Controller;\n    var moduleTagName_i = row.ModuleTagName;\n    var index_i = row.Index;\n    var conditionCode_i = row.ConditionCode;\n    var conditionDescription_i = row.ConditionDescription;\n    var isDebounced_i = parseBoolean(row.IsDebounced);\n    var debounceTime_i = Number(row.DebounceTime);\n    var okayState_i = parseBoolean(row.OkayState);\n    var isBypassable_i = parseBoolean(row.IsBypassable);\n    var canNavigate_i = parseBoolean(row.CanNavigate);\n    var associatedTag_i = row.AssociatedTag;\n    \n    // Test if this row is missing the row's primary key info\n    if ((controller_i !== null) && (controller_i !== undefined) && \n            (moduleTagName_i !== null) && (moduleTagName_i !== undefined)) {\n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Row = \" + controller_i + \"-\" + moduleTagName_i + \".\");\n        \n        // Test if the index is a number or not\n        if (isNaN(index_i)) {\n            // Index is not a number\n            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": cannot add interlock because index (\" +\n                    index_i + \") is not a number.\");\n        }\n        else {\n            // Index is a number\n            // Force to be an integer\n            index_i = Math.trunc(index_i)\n            \n            // Get a list of all elements matching the current Controller & Module Tag Name\n            var tempModulesArray = returnDataSet.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === controller_i) &&\n                            (element.ModuleTagName === moduleTagName_i));\n                    }\n                });\n            \n            // Debug Messages\n            //logDebugMessage(thisCallStackLevel, \"Number of Elements = \" + tempModulesArray.length;\n            \n            // Test if the module exists yet or not.\n            if (tempModulesArray.length <= 0) {\n                // Cannot find this ClassName in the returnDataSet\n                var tempObj = {\n                        \"Controller\":controller_i,\n                        \"ModuleTagName\":moduleTagName_i,\n                        \"Interlocks\":[]\n                    }\n                \n                // Insert all placeholders if configured to do so\n                if (insertPlaceHolders) {\n                    for (var j = minimumIndex; j <= maximumIndex; j++) {\n                        // Add a new object to the return set\n                        tempObj.Interlocks.push({\n                                \"Index\":j,\n                                \"ConditionCode\":null,\n                                \"ConditionDescription\":\"\",\n                                \"IsDebounced\":false,\n                                \"DebounceTime\":0,\n                                \"OkayState\":0,\n                                \"IsBypassable\":false,\n                                \"CanNavigate\":false,\n                                \"AssociatedTag\":\"\"\n                            });\n                    }\n                }\n                \n                // Add a new object to the return set\n                returnDataSet.push(tempObj);\n            }\n            \n            // Re-pull list of all elements matching the current Controller & Module Tag Name\n            tempModulesArray = returnDataSet.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return ((element.Controller === controller_i) &&\n                            (element.ModuleTagName === moduleTagName_i));\n                    }\n                });\n            \n            // Test if the module exists yet or not.\n            if (tempModulesArray.length > 0) {\n                // Already found this module in the returnDataSet\n                // Cache a reference to the first element for the current moduloe\n                var tempModule = tempModulesArray[0];\n                \n                //Test if index is valid\n                if ((index_i < minimumIndex) || (index_i > maximumIndex)) {\n                    // Index is outside of acceptable range\n                    // Log a validation error\n                    logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": interlock index (\" + index_i + \n                        \") is outside of the acceptable range of \" + minimumIndex + \" to \" + maximumIndex);\n                }\n                else {\n                    // Index is within acceptable range\n                    // Get a list of all elements matching the current index\n                    var tempInterlocksArray = tempModule.Interlocks.filter((element)=>{\n                            if ((element !== null) && (element !== undefined)){\n                                return (element.Index === index_i);\n                            }\n                        });\n                    \n                    // Test if the index exists yet or not.\n                    if (tempInterlocksArray.length > 0) {\n                        // Already found this index in the returnDataSet\n                        // Cache a reference to the first element \n                        var tempInterlock = tempInterlocksArray[0];\n                        \n                        // Test if the condition code was created as part of the placeholder insertion, but has NOT already been set\n                        if (insertPlaceHolders && (tempInterlock.ConditionCode === null)) {\n                            // Update the existing interlock\n                            tempInterlock.Index = index_i;\n                            tempInterlock.ConditionCode = conditionCode_i;\n                            tempInterlock.ConditionDescription = conditionDescription_i;\n                            tempInterlock.IsDebounced = isDebounced_i;\n                            tempInterlock.DebounceTime = debounceTime_i;\n                            tempInterlock.OkayState = okayState_i;\n                            tempInterlock.IsBypassable = isBypassable_i;\n                            tempInterlock.CanNavigate = canNavigate_i;\n                            tempInterlock.AssociatedTag = associatedTag_i;\n                        }\n                        else {\n                            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": cannot add interlock \" +\n                                index_i + \" to the list because it already exists.\");\n                        }\n                    }\n                    else {\n                        // Cannot find this UsageScenario in the returnDataSet\n                        // Add a new object to the return set\n                        tempModule.Interlocks.push({\n                                \"Index\":index_i,\n                                \"ConditionCode\":conditionCode_i,\n                                \"ConditionDescription\":conditionDescription_i,\n                                \"IsDebounced\":isDebounced_i,\n                                \"DebounceTime\":debounceTime_i,\n                                \"OkayState\":okayState_i,\n                                \"IsBypassable\":isBypassable_i,\n                                \"CanNavigate\":canNavigate_i,\n                                \"AssociatedTag\":associatedTag_i\n                            });\n                    }\n                }\n            }\n            else {\n                // Cannot find this module in the returnDataSet\n                // Log a validation error\n                logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \": cannot find this module immediately after adding it.\");\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload = {\n    \"Interlocks_Pivoted\": returnDataSet,\n    \"InterlockOptions\": msg.payload.InterlockOptions\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1240,
    "y": 360,
    "wires": [
      [
        "b3da362f.ac4ca8"
      ]
    ]
  },
  {
    "id": "923df7c3.d41f68",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Pivot CDef_CodeSnippets",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pivot CDef_CodeSnippets\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Declare variables\n/*{\n    \"CDef_CodeSnippets_Pivoted\":[{\n        \"ClassName\":className_i,\n        \"UsageScenarios\":[{\n            \"UsageScenarioName\":usageScenario_i,\n            \"Snippets\":[{\n                \"SnippetName\":snippetName_i,\n                \"Code\":code_i,\n                \"Comment\":comment_i\n            }]\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n//Iterate the rows in the CDef_CodeSnippets data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_CodeSnippets.length; i++) {\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_CodeSnippets[i];\n    \n    // Pull the current rows data\n    var className_i = row.ClassName;\n    var usageScenario_i = row.UsageScenario;\n    var snippetName_i = row.SnippetName;\n    var code_i = row.Code;\n    var comment_i = row.Comment;\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Row = \" + className_i + \"-\" + usageScenario_i + \"-\" + snippetName_i + \".\");\n    \n    // Get a list of all elements matching the current ClassName\n    var tempClassNamesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === className_i);\n            }\n        });\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Number of Elements = \" + tempClassNamesArray.length);\n    \n    // Test if the ClassName exists yet or not.\n    if (tempClassNamesArray.length > 0) {\n        // Already found this ClassName in the returnDataSet\n        // Cache a reference to the first element for the current ClassName\n        var tempClassName = tempClassNamesArray[0];\n        \n        // Get a list of all elements matching the current ClassName\n        var tempUsageScenariosArray = tempClassName.UsageScenarios.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.UsageScenarioName === usageScenario_i);\n                }\n            });\n        \n         // Test if the UsageScenario exists yet or not.\n        if (tempUsageScenariosArray.length > 0) {\n            // Already found this UsageScenario in the returnDataSet\n            // Cache a reference to the first element for the current UsageScenario\n            var tempUsageScenario = tempUsageScenariosArray[0];\n            \n            // Get a list of all elements matching the current SnippetName\n            var tempSnippetsArray = tempUsageScenario.Snippets.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.SnippetName === snippetName_i);\n                    }\n                });\n            \n             // Test if the SnippetName exists yet or not.\n            if (tempSnippetsArray.length > 0) {\n                // Already found this SnippetName in the returnDataSet\n                // Debug messages\n                logValidationErrorMessage(thisCallStackLevel, \"Cannot add \" + snippetName_i + \" to the class definition because it already exists.\");\n            }\n            else {\n                // Cannot find this UsageScenario in the returnDataSet\n                // Add a new object to the return set\n                tempUsageScenario.Snippets.push({\n                        \"SnippetName\":snippetName_i,\n                        \"Code\":code_i,\n                        \"Comment\":comment_i\n                    });\n            }\n        }\n        else {\n            // Cannot find this UsageScenario in the returnDataSet\n            // Add a new object to the return set\n            tempClassName.UsageScenarios.push({\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Snippets\":[{\n                        \"SnippetName\":snippetName_i,\n                        \"Code\":code_i,\n                        \"Comment\":comment_i\n                    }]\n                });\n        }\n    }\n    else {\n        // Cannot find this ClassName in the returnDataSet\n        // Add a new object to the return set\n        returnDataSet.push({\n                \"ClassName\":className_i,\n                \"UsageScenarios\":[{\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Snippets\":[{\n                        \"SnippetName\":snippetName_i,\n                        \"Code\":code_i,\n                        \"Comment\":comment_i\n                    }]\n                }]\n            });\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload.CDef_CodeSnippets_Pivoted = returnDataSet;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1270,
    "y": 160,
    "wires": [
      [
        "a4eea0e8.6ed2a"
      ]
    ]
  },
  {
    "id": "347a915c.cc37ee",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Pivot CDef_Parameters",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pivot CDef_Parameters\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Declare variables\n/*{\n    \"CDef_Parameters_Pivoted\":[{\n        \"ClassName\":className_i,\n        \"Parameters\":[{\n            \"ParameterName\":parameterName_i,\n            \"Usage\":usage_i,\n            \"DataType\":dataType_i,\n            \"Description\":description_i,\n            \"DefaultValue\":defaultValue_i,\n            \"IsConfig\":isConfig_i,\n            \"IsBasicConfig\":isBasicConfig_i,\n            \"IsOperatorEditable\":isOperatorEditable_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n//Iterate the rows in the CDef_Parameters data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_Parameters.length; i++) {\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_Parameters[i];\n    \n    // Pull the current row's data\n    var className_i = row.ClassName;\n    var parameterName_i = row.ParameterName;\n    var usage_i = row.Usage;\n    var dataType_i = row.DataType;\n    var description_i = row.Description;\n    var defaultValue_i = row.DefaultValue;\n    var isConfig_i = parseBoolean(row.IsConfig);\n    var isBasicConfig_i = parseBoolean(row.IsBasicConfig);\n    var isOperatorEditable_i = parseBoolean(row.IsOperatorEditable);\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Row = \" + className_i + \"-\" + parameterName_i + \".\");\n    \n    // Get a list of all elements matching the current ClassName\n    var tempClassNamesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === className_i);\n            }\n        });\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Number of Elements = \" + tempClassNamesArray.length);\n    \n    // Test if the ClassName exists yet or not.\n    if (tempClassNamesArray.length > 0) {\n        // Already found this ClassName in the returnDataSet\n        // Cache a reference to the first element for the current ClassName\n        var tempClassName = tempClassNamesArray[0];\n        \n        // Get a list of all elements matching the current ParameterName\n        var tempParametersArray = tempClassName.Parameters.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.ParameterName === parameterName_i);\n                }\n            });\n        \n        // Test if the ParameterName exists yet or not.\n        if (tempParametersArray.length > 0) {\n            // Already found this ParameterName in the returnDataSet\n            // Debug messages\n            logValidationErrorMessage(thisCallStackLevel, \"Cannot add \" + parameterName_i + \" to the class definition because it already exists.\");\n        }\n        else {\n            // Cannot find this UsageScenario in the returnDataSet\n            // Add a new object to the return set\n            tempClassName.Parameters.push({\n                    \"ParameterName\":parameterName_i,\n                    \"Usage\":usage_i,\n                    \"DataType\":dataType_i,\n                    \"Description\":description_i,\n                    \"DefaultValue\":defaultValue_i,\n                    \"IsConfig\":isConfig_i,\n                    \"IsBasicConfig\":isBasicConfig_i,\n                    \"IsOperatorEditable\":isOperatorEditable_i\n                });\n        }\n    }\n    else {\n        // Cannot find this ClassName in the returnDataSet\n        // Add a new object to the return set\n        returnDataSet.push({\n                \"ClassName\":className_i,\n                \"Parameters\":[{\n                    \"ParameterName\":parameterName_i,\n                    \"Usage\":usage_i,\n                    \"DataType\":dataType_i,\n                    \"Description\":description_i,\n                    \"DefaultValue\":defaultValue_i,\n                    \"IsConfig\":isConfig_i,\n                    \"IsBasicConfig\":isBasicConfig_i,\n                    \"IsOperatorEditable\":isOperatorEditable_i\n                }]\n            });\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload.CDef_Parameters_Pivoted = returnDataSet;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1273.6666564941406,
    "y": 219.66666412353516,
    "wires": [
      [
        "a4eea0e8.6ed2a"
      ]
    ]
  },
  {
    "id": "20c49f09.b4e55",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Pivot CDef_UsageScenarios",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pivot CDef_UsageScenarios\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Declare variables\n/*{\n    \"CDef_UsageScenarios_Pivoted\":[{\n        \"ClassName\":className_i,\n        \"UsageScenarios\":[{\n            \"UsageScenarioName\":usageScenario_i,\n            \"Parameters\":[{\n                \"ParameterName\":parameterName_i,\n                \"DataType\":dataType_i,\n                \"ParameterMappingAction\":parameterMappingAction_i,\n                \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                \"CreateTag\":createTag_i,\n                \"TagName\":tagName_i,\n                \"TagDescription\":tagDescription_i\n            }]\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_UsageScenarios.length; i++) {\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_UsageScenarios[i];\n    \n    // Pull the current rows data\n    var className_i = row.ClassName;\n    var usageScenario_i = row.UsageScenario;\n    var parameterName_i = row.ParameterName;\n    var dataType_i = row.DataType;\n    var parameterMappingAction_i = row.ParameterMappingAction;\n    var validateAgainstIOList_i = parseBoolean(row.ValidateAgainstIOList);\n    var createTag_i = parseBoolean(row.CreateTag);\n    var tagName_i = row.TagName;\n    var tagDescription_i = row.TagDescription;\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Row = \" + className_i + \"-\" + usageScenario_i + \"-\" + parameterName_i + \".\");\n    \n    // Get a list of all elements matching the current ClassName\n    var tempClassNamesArray = returnDataSet.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === className_i);\n            }\n        });\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Number of Elements = \" + tempClassNamesArray.length);\n    \n    // Test if the ClassName exists yet or not.\n    if (tempClassNamesArray.length > 0) {\n        // Already found this ClassName in the returnDataSet\n        // Cache a reference to the first element for the current ClassName\n        var tempClassName = tempClassNamesArray[0];\n        \n        // Get a list of all elements matching the current ClassName\n        var tempUsageScenariosArray = tempClassName.UsageScenarios.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.UsageScenarioName === usageScenario_i);\n                }\n            });\n        \n         // Test if the UsageScenario exists yet or not.\n        if (tempUsageScenariosArray.length > 0) {\n            // Already found this UsageScenario in the returnDataSet\n            // Cache a reference to the first element for the current UsageScenario\n            var tempUsageScenario = tempUsageScenariosArray[0];\n            \n            // Get a list of all elements matching the current ParameterName\n            var tempParametersArray = tempUsageScenario.Parameters.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.ParameterName === parameterName_i);\n                    }\n                });\n            \n             // Test if the ParameterName exists yet or not.\n            if (tempParametersArray.length > 0) {\n                // Already found this ParameterName in the returnDataSet\n                // Debug messages\n                logValidationErrorMessage(thisCallStackLevel, \"Cannot add \" + parameterName_i + \" to the class definition because it already exists.\");\n            }\n            else {\n                // Cannot find this UsageScenario in the returnDataSet\n                // Add a new object to the return set\n                tempUsageScenario.Parameters.push({\n                        \"ParameterName\":parameterName_i,\n                        \"DataType\":dataType_i,\n                        \"ParameterMappingAction\":parameterMappingAction_i,\n                        \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                        \"CreateTag\":createTag_i,\n                        \"TagName\":tagName_i,\n                        \"TagDescription\":tagDescription_i\n                    });\n            }\n        }\n        else {\n            // Cannot find this UsageScenario in the returnDataSet\n            // Add a new object to the return set\n            tempClassName.UsageScenarios.push({\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Parameters\":[{\n                        \"ParameterName\":parameterName_i,\n                        \"DataType\":dataType_i,\n                        \"ParameterMappingAction\":parameterMappingAction_i,\n                        \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                        \"CreateTag\":createTag_i,\n                        \"TagName\":tagName_i,\n                        \"TagDescription\":tagDescription_i\n                    }]\n                });\n        }\n    }\n    else {\n        // Cannot find this ClassName in the returnDataSet\n        // Add a new object to the return set\n        returnDataSet.push({\n                \"ClassName\":className_i,\n                \"UsageScenarios\":[{\n                    \"UsageScenarioName\":usageScenario_i,\n                    \"Parameters\":[{\n                        \"ParameterName\":parameterName_i,\n                        \"DataType\":dataType_i,\n                        \"ParameterMappingAction\":parameterMappingAction_i,\n                        \"ValidateAgainstIOList\":validateAgainstIOList_i,\n                        \"CreateTag\":createTag_i,\n                        \"TagName\":tagName_i,\n                        \"TagDescription\":tagDescription_i\n                    }]\n                }]\n            });\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload.CDef_UsageScenarios_Pivoted = returnDataSet;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1283.6666564941406,
    "y": 99.66666412353516,
    "wires": [
      [
        "a4eea0e8.6ed2a"
      ]
    ]
  },
  {
    "id": "5389a0cd.57ca1",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Incoming Trigger",
    "info": "",
    "x": 280,
    "y": 60,
    "wires": []
  },
  {
    "id": "a4eea0e8.6ed2a",
    "type": "join",
    "z": "98969df7.44714",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "3",
    "x": 1613.6666564941406,
    "y": 139.66666412353516,
    "wires": [
      [
        "6b52eff0.5e944",
        "5e897515.9394dc"
      ]
    ]
  },
  {
    "id": "3f9647a9.f26028",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Pull the Dataset Files",
    "info": "",
    "x": 500,
    "y": 60,
    "wires": []
  },
  {
    "id": "dbef288a.b81948",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Pivot the Datasets",
    "info": "",
    "x": 1250,
    "y": 60,
    "wires": []
  },
  {
    "id": "db02be8c.1523",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Convert Data CDef_UsageScenarios",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Convert CDef_UsageScenarios\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_UsageScenarios.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_UsageScenarios[i];\n    \n    // Modify the current row's data.  Convert incoming raw data to native data types.\n    row.ValidateAgainstIOList = parseBoolean(row.ValidateAgainstIOList);\n    row.CreateTag = parseBoolean(row.CreateTag);\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 833.6666564941406,
    "y": 99.66666412353516,
    "wires": [
      [
        "20c49f09.b4e55"
      ]
    ]
  },
  {
    "id": "96b81d59.71328",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Convert Raw Data into Native Types",
    "info": "",
    "x": 820,
    "y": 60,
    "wires": []
  },
  {
    "id": "4a18ab65.59d8e4",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Convert Data CDef_CodeSnippets",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Convert CDef_CodeSnippets\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n//Iterate the rows in the CDef_CodeSnippets data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_CodeSnippets.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_CodeSnippets[i];\n    \n    // Modify the current row's data.\n    // Replace all \"\\r\\r\\n\" markers with \"\\r\\n\" in the Code\n    if ((row.Code !== null) && (row.Code !== undefined)) {\n        row.Code = row.Code.replace(/\\r\\r\\n/mg,\"\\r\\n\");\n    }\n    // Replace all \"\\r\\r\\n\" markers with \"\\r\\n\" in the Comment\n    if ((row.Comment !== null) && (row.Comment !== undefined)) {\n        row.Comment = row.Comment.replace(/\\r\\r\\n/mg,\"\\r\\n\");\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 823.6666564941406,
    "y": 159.66666412353516,
    "wires": [
      [
        "923df7c3.d41f68"
      ]
    ]
  },
  {
    "id": "8d4209c4.770408",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Convert Data CDef_Parameters",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Convert CDef_Parameters\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n//Iterate the rows in the CDef_Parameters data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.CDef_Parameters.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.CDef_Parameters[i];\n    \n    // Modify the current row's data.  Convert incoming raw data to native data types.\n    row.IsConfig = parseBoolean(row.IsConfig);\n    row.IsBasicConfig = parseBoolean(row.IsBasicConfig);\n    row.IsOperatorEditable = parseBoolean(row.IsOperatorEditable);\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 813.6666564941406,
    "y": 219.66666412353516,
    "wires": [
      [
        "347a915c.cc37ee"
      ]
    ]
  },
  {
    "id": "5a46764f.9751f8",
    "type": "join",
    "z": "98969df7.44714",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "3",
    "x": 1613.6666564941406,
    "y": 259.66666412353516,
    "wires": [
      [
        "6b52eff0.5e944",
        "3ec1f0ad.e0ee5"
      ]
    ]
  },
  {
    "id": "b3da362f.ac4ca8",
    "type": "join",
    "z": "98969df7.44714",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 1610,
    "y": 360,
    "wires": [
      [
        "6b52eff0.5e944",
        "4e0f5f5f.a4f48"
      ]
    ]
  },
  {
    "id": "6b52eff0.5e944",
    "type": "join",
    "z": "98969df7.44714",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "3",
    "x": 1793.6666564941406,
    "y": 259.66666412353516,
    "wires": [
      [
        "c28bf6a1.164b88",
        "67b612ee.1dadbc"
      ]
    ]
  },
  {
    "id": "9c69faa2.1aad68",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Join Groups of Return Datasets",
    "info": "",
    "x": 1690,
    "y": 100,
    "wires": []
  },
  {
    "id": "31df7bd5.c6eb64",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Join All Return Datasets",
    "info": "",
    "x": 1260,
    "y": 560,
    "wires": []
  },
  {
    "id": "8d6467e5.255fc8",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Publish All Datasets",
    "links": [
      "5e607e08.cce0d"
    ],
    "x": 1855,
    "y": 680,
    "wires": []
  },
  {
    "id": "c28bf6a1.164b88",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Get Usage Scenarios",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Usage Scenarios\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\nconst RegexMappingActionRegex = \"^/.*/[imguy]{0,5}$\";\n\n// This function's purpose is to iterate the module tag names in the modules list\n// For each tag:\n//  1) Cache data needed for later\n//      a) Module tag name\n//      b) Module's class name\n//  2) Pull the tag's module data table row\n//      a) Log a validation error if the table doesn't exist\n//      b) Log a validation error if the tag doesn't exist in the table or exists too many times\n//      c) Cache a reference to the tag's module data row.\n//  3) Pull the class definition from CDef_UsageScenarios_Pivoted\n//      a) Log a validation error class def doesn't exist\n//  4) Iterate the usage scenarios in the class definition.   Note: set UsageScenarioFound = false.\n//  5) For each usage scenario, iterate the parameter names.  Note: set AllParametersMatch = true\n//  6) For each parameter in the usage scenario,\n//      a) Cache off if the parameter was supposed to be configured or not (ParameterMappingAction).\n//      b) Pull the data from tag's module data row for column matching the parameter name.  Note: trim whitespace during the pull.\n//      c) ParameterMatches = ((TagParamConfig.length > 0) == ParameterMappingAction)\n//      d) AllParametersMatch = AllParametersMatch && ParameterMatches\n//  7) If AllParametersMatch = true, set UsageScenarioFound = true & quit iterating the usage scenarios.\n//  8) Check if a usage scenario was found or not\n//      a) If UsageScenarioFound = true, append the usage scenario to the modules list data.\n//      b)If UsageScenarioFound = false, log a validation error.\n\n/*{\n    \"ClassName\":className_i,\n    \"UsageScenarios\":[{\n        \"UsageScenarioName\":usageScenario_i,\n        \"Parameters\":[{\n            \"ParameterName\":parameterName_i,\n            \"DataType\":dataType_i,\n            \"ParameterMappingAction\":parameterMappingAction_i,\n            \"ValidateAgainstIOList\":validateAgainstIOList_i\n        }]\n    }]\n}*/\n\n// Cache a reference to the relevant data sets that need to be used\nvar cDef_UsageScenarios = msg.payload.CDef_UsageScenarios_Pivoted;\nvar modulesList = msg.payload.Modules;\n\n// Iterate the tags in the Modules list dataset\nfor (var i = 0; i < modulesList.length; i++){\n    // Cache a reference to the current module's list data\n    var module_i = modulesList[i];\n    \n    // Cache off the common paramaters from the current module\n    var controller_i = module_i.Controller;\n    var moduleTagName_i = module_i.ModuleTagName;\n    var moduleClassName_i = module_i.ClassName;\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Controller = \" + controller_i + \".\");\n    logDebugMessage(thisCallStackLevel, \"Module Tag Name = \" + moduleTagName_i + \".\");\n    logDebugMessage(thisCallStackLevel, \"Class Name = \" + moduleClassName_i + \".\");\n    \n    // Attempt to pull the data table for the class\n    var moduleDataTable = msg.payload[moduleClassName_i];\n    \n    // Test if the module's data table exists\n    // If it does, filter it for the current module tag name\n    // If it doesn't, log a validation error\n    if ((moduleDataTable === null) || (moduleDataTable === undefined)){\n        // Log a validation error\n        logValidationErrorMessage(thisCallStackLevel, moduleTagName_i + \"'s class (\" + \n            moduleClassName_i + \") doesn't have a corresponding data table.\");\n    }\n    else {\n        // Data table exists.  Attempt to filter it down to just the current tag.\n        var tempModuleDataArray = moduleDataTable.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return ((element.Controller === controller_i) &&\n                        (element.ModuleTagName === moduleTagName_i));\n                }\n            });\n        \n        // Check how many times the tag shows up in the data table\n        if (tempModuleDataArray.length == 0){\n            // Tag doesn't exist.  Log a validation error\n            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \n                \" doesn't have a row in its class's data table.\");\n        }\n        else if(tempModuleDataArray.length > 1) {\n            // Tag exists more than once.  Log a validation error\n            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \n                \" has more than one row in its class's data table (row count = \" + tempModuleDataArray.length + \").\");\n        }\n        else {\n            // Tag exists once and only once in the data table.\n            //  Cache a reference to the current module's data table row\n            var moduleData_i = tempModuleDataArray[0];\n            \n            // Pull the first match for this module's class from CDef_UsageScenarios_Pivoted\n            var cDef_UsageScenarios_i = null\n            tempModuleDataArray = cDef_UsageScenarios.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.ClassName === moduleClassName_i);\n                    }\n                });\n                \n            // Check if anything returned\n            if (tempModuleDataArray.length > 0){\n                // Cache a reference to this module's usage scenario class def\n                cDef_UsageScenarios_i = tempModuleDataArray[0];\n            }\n            \n            // Check if a usage scenario exists for the current class name\n            var firstMatch_UsageScenarioName = null;\n            if ((cDef_UsageScenarios_i === null) || (cDef_UsageScenarios_i === undefined)){\n                // Log a validation error\n                logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \"'s class (\" + \n                    moduleClassName_i + \") doesn't have a corresponding Class Definition Usage Scenario dataset.\");\n            }\n            else {\n                // The current tag has all of the datasets required.\n                // Default the number of usage scenario matches\n                var UsageScenarioMatchCount = 0;\n                \n                // Iterate the usage scenarios for this module's class\n                for (var j = 0; j < cDef_UsageScenarios_i.UsageScenarios.length; j++){\n                    // Cache a reference to the current usage scenario to check\n                    var usageScenario_i = cDef_UsageScenarios_i.UsageScenarios[j];\n                    \n                    logDebugMessage(thisCallStackLevel, \"Usage Scenario Name = \" + usageScenario_i.UsageScenarioName + \".\");\n                    \n                    // Default the flag for all parameters match to true;\n                    // If any parameter doesn't match, it will be reset to false.\n                    var AllParametersMatch = true\n                    \n                    // Iterate the parameters in the current usage scenario\n                    for (var k = 0; k < usageScenario_i.Parameters.length; k++){\n                        // Cache a reference to the current usage scenario to check\n                        var parameter_i = usageScenario_i.Parameters[k];\n                        \n                        // Pull the commonly used data points\n                        var parameterMappingAction_i = parameter_i.ParameterMappingAction;\n                        \n                        // Debug Messages\n                        logDebugMessage(thisCallStackLevel, \"Parameter Name = \" + parameter_i.ParameterName + \".\");\n                        logDebugMessage(thisCallStackLevel, \"Parameter Mapping Action = \" + parameterMappingAction_i + \".\");\n                        \n                        // Test if the parameter mapping action is invalid\n                        // Note:  null is okay and will be interpreted as 'Ignore' in this code\n                        if (parameterMappingAction_i === undefined) {\n                            logValidationErrorMessage(thisCallStackLevel, moduleClassName_i + \"'s parameter (\" + \n                                parameter_i.ParameterName + \") doesn't have a parameter mapping action (\" + \n                                parameterMappingAction_i + \").\");\n                        }\n                        \n                        // Pull the configuration from the module data table for the current parameter\n                        moduleParamConfig = moduleData_i[parameter_i.ParameterName];\n                        if (moduleParamConfig === null) {\n                            // Blank cells in the data table show up as null or undefined depending on the implementation of the Excel to JSON data parsing routine.\n                            // *** This has been taken care of with upstream processing. --> null = empty cell, but column exists;  undefined = column missing.\n                            // Convert them to empty strings\n                            moduleParamConfig = \"\";\n                        }\n                        \n                        // Debug messages\n                        logDebugMessage(thisCallStackLevel, \"Parameter Value = \" + moduleParamConfig + \".\");\n                        \n                        // Test if the module's parameter exists\n                        // If it does, perform the comparison to the class definition\n                        // If it doesn't, log a validation error & mark it as a mismatch\n                        if ((moduleParamConfig === undefined) && ((parameterMappingAction_i !== \"Ignore\") && (parameterMappingAction_i !== null) && (parameterMappingAction_i !== undefined))) {\n                            // The module's parameter doesn't exist and it should exist\n                            // Log a validation error\n                            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \"'s data table (\" + \n                                moduleClassName_i + \") doesn't have a required class definition column (\" + \n                                parameter_i.ParameterName + \").\");\n                            \n                            // Mark this as a mismatch\n                            ParameterMatches = false;\n                        }\n                        else {\n                            // One of two case will exist\n                            // 1) The module's parameter does exist and should be validated\n                            // 2) The module's parameter doesn't exist, but the mapping action is set to ignore the parameter\n                            \n                            // Check the module's parameter config against the class definition\n                            switch(parameterMappingAction_i) {\n                                case \"Non-Blank\":\n                                    // Requires the module's parameter config to NOT be blank\n                                    ParameterMatches = (moduleParamConfig.length !== 0);\n                                    \n                                    // Debug Messages\n                                    logDebugMessage(thisCallStackLevel, \"Testing if Non-Blank.  Parameter Value Length = \" + moduleParamConfig.length + \".  ParameterMatches = \" + ParameterMatches + \".\");\n                                    break;\n                                    \n                                case \"Blank\":\n                                    // Requires the module's parameter config to be blank\n                                    ParameterMatches = (moduleParamConfig.length === 0);\n                                    \n                                    // Debug Messages\n                                    logDebugMessage(thisCallStackLevel, \"Testing if Blank.  Parameter Value Length = \" + moduleParamConfig.length + \".  ParameterMatches = \" + ParameterMatches + \".\");\n                                    break;\n                                    \n                                case null:\n                                case undefined:\n                                case \"Ignore\":\n                                    // Ignore this parameter\n                                    ParameterMatches = true;\n                                    break;\n                                    \n                                default:\n                                    // Test if the parameter mapping action fits the javascript RegExp constructor string format:  ex.  /[abc]{0,3}/img\n                                    var reRegexMappingAction = new RegExp(RegexMappingActionRegex, \"i\");\n                                    if (reRegexMappingAction.test(parameterMappingAction_i)) {\n                                        // Is a RegEx match\n                                        // Debug Messages\n                                        logDebugMessage(thisCallStackLevel, \"This is a regex match.  parameterMappingAction_i = \" + parameterMappingAction_i);\n                                        \n                                        var reIsValid = false;\n                                        var reStartPos = parameterMappingAction_i.indexOf(\"/\");\n                                        var reEndPos = parameterMappingAction_i.lastIndexOf(\"/\");\n                                        \n                                        // Test if the start and end markers were found\n                                        if ((reStartPos !== -1) && (reEndPos !== -1) && (reStartPos !== reEndPos)) {\n                                            var rePattern = parameterMappingAction_i.substring(reStartPos + 1, reEndPos);\n                                            var reFlags = parameterMappingAction_i.substring(reEndPos + 1);\n                                            \n                                            // Debug Messages\n                                            logDebugMessage(thisCallStackLevel, \"    \" + \"Pattern = \" + rePattern + \".\");\n                                            logDebugMessage(thisCallStackLevel, \"    \" + \"Flags = \" + reFlags + \".\");\n                                            \n                                            // Wrap the regex test within a try block to catch exceptions.  Exceptions fail the match wiht a validation error\n                                            try {\n                                                var reMappingAction = new RegExp(rePattern, reFlags);\n                                                ParameterMatches = reMappingAction.test(moduleParamConfig);\n                                                reIsValid = true;       // This is the only case where the regex is marked as valid\n                                            }\n                                            catch (e) {\n                                                // An error occurred when trying to make or test the mapping action regex.\n                                                // Nothing to do\n                                            }\n                                        }\n                                        \n                                        // Test if the regex wasn't valid\n                                        if (!reIsValid) {\n                                            ParameterMatches = false;\n                                            \n                                            // Log a validation error\n                                            logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \" (\" + \n                                                moduleClassName_i + \") parameter (\" + parameter_i.ParameterName + \") doesn't have a valid Regular Expression constructor.\");\n                                        }\n                                        \n                                        // Debug Messages\n                                        logDebugMessage(thisCallStackLevel, \"Testing if Value Matches (RegEx) '\" + parameterMappingAction_i + \"'.  Parameter Value = '\" + moduleParamConfig + \"'.  ParameterMatches = \" + ParameterMatches + \".\");\n                                    }\n                                    else {\n                                        // Is NOT a RegEx match --> assume literal match\n                                        // Debug Messages\n                                        logDebugMessage(thisCallStackLevel, \"This is a literal match.  parameterMappingAction_i = \" + parameterMappingAction_i);\n                                        \n                                        // Requires the module's parameter config to match the parameter mapping action (value match)\n                                        ParameterMatches = (moduleParamConfig == parameterMappingAction_i);\n                                        \n                                        // Debug Messages\n                                        logDebugMessage(thisCallStackLevel, \"Testing if Value Matches (Literal) '\" + parameterMappingAction_i + \"'.  Parameter Value = '\" + moduleParamConfig + \"'.  ParameterMatches = \" + ParameterMatches + \".\");\n                                    }\n                                    break;\n                            }\n                            \n                            \n                            //TODO: Add validation against IO List\n                        }\n                        \n                        \n                        \n                        // Combine the current match with the aggregated match for the usage scenarion\n                        AllParametersMatch = AllParametersMatch && ParameterMatches;\n                        \n                        // Quit searching this usage scenario if anything mismatches\n                        if (!AllParametersMatch){\n                            // Debug Messages\n                            logDebugMessage(thisCallStackLevel, \"Found a mismatch.  Quitting searching on this scenario.\");\n                            break;\n                        }\n                    }\n                    \n                    // Test if all parameters match.  If so, increment the match count\n                    if (AllParametersMatch) {\n                        // Capture the current usage scenario name if this is the first match\n                        if (firstMatch_UsageScenarioName === null) {\n                            // Debug Messages\n                            logDebugMessage(thisCallStackLevel, \"Found the first usage scenario match:  \" + usageScenario_i.UsageScenarioName);\n                            firstMatch_UsageScenarioName = usageScenario_i.UsageScenarioName;\n                        }\n                        else {\n                            // Debug Messages\n                            logDebugMessage(thisCallStackLevel, \"Found another usage scenario match:  \" + usageScenario_i.UsageScenarioName);\n                        }\n                        UsageScenarioMatchCount++;\n                    }\n                }\n                \n                // Test how many usage scenario matches were found\n                if (UsageScenarioMatchCount == 0){\n                    // Log a validation error\n                    logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \" (\" + \n                        moduleClassName_i + \") doesn't have a matching Usage Scenario.\");\n                }\n                else if (UsageScenarioMatchCount > 1){\n                    // Log a validation error\n                    logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s \" + moduleTagName_i + \" (\" + \n                        moduleClassName_i + \") has more than one matching Usage Scenario (match count = \" + UsageScenarioMatchCount + \").\");\n                }\n                else {\n                    // Append the matching Usage Scenario name to the current module list row\n                    module_i.UsageScenario = firstMatch_UsageScenarioName;\n                    \n                    // Append any other useful information to the current module list row\n                    module_i.Description = moduleData_i.Description;\n                }\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1980,
    "y": 400,
    "wires": [
      [
        "9870b6a7.f76cd8"
      ]
    ]
  },
  {
    "id": "389349ed.081e56",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Publish to Other Flows",
    "info": "",
    "x": 1940,
    "y": 640,
    "wires": []
  },
  {
    "id": "dec566da.186c58",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Debug: Main Flow Trigger",
    "links": [
      "675544fc.50165c",
      "5b6ecc0c.75e654"
    ],
    "x": 221.66665649414062,
    "y": 199.66666412353516,
    "wires": []
  },
  {
    "id": "fe24c45d.b23098",
    "type": "inject",
    "z": "98969df7.44714",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 126.66665649414062,
    "y": 199.66666412353516,
    "wires": [
      [
        "dec566da.186c58"
      ]
    ]
  },
  {
    "id": "6e4adf68.45182",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Main Trigger",
    "info": "",
    "x": 116.66665649414062,
    "y": 159.66666412353516,
    "wires": []
  },
  {
    "id": "99043372.0995e",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1230,
    "y": 660,
    "wires": []
  },
  {
    "id": "9870b6a7.f76cd8",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Resolve Program Structure References",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar resolveModuleNonCodeReferences = global.get(\"resolveModuleNonCodeReferences\");      //function (msg, controllerName, moduleTagName, stringToResolve)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Resolve Program Structure References\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n//Iterate the rows in the Tasks dataset to dereference the incoming values.\nfor (var i = 0; i < msg.payload.Modules.length; i++) {\n    // Cache a reference to the current row\n    var row = msg.payload.Modules[i];\n    \n    // Pull the current row's data\n    var controller_i = row.Controller;\n    var moduleTagName_i = row.ModuleTagName;\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Row = \" + controller_i + \"-\" + moduleTagName_i + \".\");\n    \n    // Resolve references in the Task, Program, & Routine\n    row.ResolvedTask = resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, row.Task);\n    row.ResolvedProgram = resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, row.Program);\n    row.ResolvedRoutine = resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, row.Routine);\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 283.6666564941406,
    "y": 599.6666641235352,
    "wires": [
      [
        "e51051db.e75ff",
        "8ae0eacf.4914c8"
      ]
    ]
  },
  {
    "id": "8ae0eacf.4914c8",
    "type": "join",
    "z": "98969df7.44714",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "7",
    "x": 1210,
    "y": 600,
    "wires": [
      [
        "442e96e4.fd1988"
      ]
    ]
  },
  {
    "id": "e51051db.e75ff",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Extract Modules List",
    "func": "// Pull down referencs to global functions\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Extract just the modules dataset\nmsg.payload = {\"Modules\":msg.payload.Modules};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 603.0997619628906,
    "y": 659.1000137329102,
    "wires": [
      [
        "ca525e4a.4cc8",
        "ab2f4026.52a5e",
        "1279128b.cec9fd",
        "c54ddd45.b6ceb",
        "26649d2f.14a352",
        "c2bfe4c5.0f9638"
      ]
    ]
  },
  {
    "id": "cd595aa3.7d9278",
    "type": "subflow:1f8d1d0a.6392f3",
    "z": "98969df7.44714",
    "x": 490,
    "y": 340,
    "wires": [
      [
        "5a46764f.9751f8",
        "c19341ac.cd35b"
      ]
    ]
  },
  {
    "id": "8b160ec6.4cf93",
    "type": "subflow:cacb891a.58e9d8",
    "z": "98969df7.44714",
    "name": "",
    "x": 480,
    "y": 100,
    "wires": [
      [
        "db02be8c.1523",
        "4a18ab65.59d8e4",
        "8d4209c4.770408"
      ]
    ]
  },
  {
    "id": "3b4da33b.08893c",
    "type": "subflow:99c1c432.c1fc88",
    "z": "98969df7.44714",
    "x": 500,
    "y": 260,
    "wires": [
      [
        "3b6a5827.454348"
      ]
    ]
  },
  {
    "id": "762ee981.c405b8",
    "type": "subflow:f0bcf6de.677618",
    "z": "98969df7.44714",
    "x": 470,
    "y": 300,
    "wires": [
      [
        "5a46764f.9751f8"
      ]
    ]
  },
  {
    "id": "e4601aa8.eaf6c8",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1230,
    "y": 720,
    "wires": []
  },
  {
    "id": "bb9b326c.ffa1f",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1230,
    "y": 780,
    "wires": []
  },
  {
    "id": "5f3d6512.ce510c",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1230,
    "y": 840,
    "wires": []
  },
  {
    "id": "93476b9e.825f08",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1910,
    "y": 760,
    "wires": []
  },
  {
    "id": "e3968920.d38e48",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Derive the Usage Scenario for Each Module Instance",
    "info": "",
    "x": 2070,
    "y": 360,
    "wires": []
  },
  {
    "id": "363201d6.ec5b7e",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "",
    "info": "",
    "x": 216.66665649414062,
    "y": 559.6666641235352,
    "wires": []
  },
  {
    "id": "61c665e8.d768cc",
    "type": "inject",
    "z": "98969df7.44714",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 1920,
    "y": 860,
    "wires": [
      [
        "29d9cd4.25b5f32"
      ]
    ]
  },
  {
    "id": "29d9cd4.25b5f32",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Debug: Main Flow Trigger",
    "links": [
      "675544fc.50165c",
      "5b6ecc0c.75e654"
    ],
    "x": 2015,
    "y": 860,
    "wires": []
  },
  {
    "id": "6f223c64.2c85e4",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Main Trigger",
    "info": "",
    "x": 1910,
    "y": 820,
    "wires": []
  },
  {
    "id": "ffd1ab2c.1fcf68",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Generate Lists of Unique Keys for Iterating",
    "info": "",
    "x": 960,
    "y": 560,
    "wires": []
  },
  {
    "id": "4420f2a4.4d3cec",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1230,
    "y": 900,
    "wires": []
  },
  {
    "id": "e85171ab.b148b",
    "type": "inject",
    "z": "98969df7.44714",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 126.66665649414062,
    "y": 239.66666412353516,
    "wires": [
      [
        "a9bedff7.9883b"
      ]
    ]
  },
  {
    "id": "a9bedff7.9883b",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Debug: Pull Log Messages",
    "links": [
      "dec8cf72.04cdc",
      "7d617be9.22d264",
      "964722e6.6e518"
    ],
    "x": 221.66665649414062,
    "y": 239.66666412353516,
    "wires": []
  },
  {
    "id": "21c412b2.ef0fbe",
    "type": "inject",
    "z": "98969df7.44714",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 1920,
    "y": 900,
    "wires": [
      [
        "87a09bda.427bd8"
      ]
    ]
  },
  {
    "id": "87a09bda.427bd8",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Debug: Pull Log Messages",
    "links": [
      "dec8cf72.04cdc",
      "7d617be9.22d264",
      "964722e6.6e518"
    ],
    "x": 2015,
    "y": 900,
    "wires": []
  },
  {
    "id": "3b6a5827.454348",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Convert Data PDef_CodeSnippets",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar parseBoolean = global.get(\"parseBoolean\");                              //function (value)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Convert PDef_CodeSnippets\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n//Iterate the rows in the PDef_CodeSnippets data set to build a pivoted data set.\nfor (var i = 0; i < msg.payload.PDef_CodeSnippets.length; i++){\n    // Cache a reference to the current row\n    var row = msg.payload.PDef_CodeSnippets[i];\n    \n    // Modify the current row's data.\n    // Clean up the multiline strings from the raw dataset\n    if ((row.Code !== null) && (row.Code !== undefined)) {\n        row.Code = row.Code.replace(/\\r\\r\\n/mg,\"\\r\\n\");             // Replace all \"\\r\\r\\n\" markers with \"\\r\\n\"\n        row.Code = row.Code.replace(/\\r$/g,\"\\r\\n\");                 // Replace all end of line \"\\r\" markers with \"\\r\\n\"\n    }\n    if ((row.Comment !== null) && (row.Comment !== undefined)) {\n        row.Comment = row.Comment.replace(/\\r\\r\\n/mg,\"\\r\\n\");       // Replace all \"\\r\\r\\n\" markers with \"\\r\\n\"\n        row.Comment = row.Comment.replace(/\\r$/g,\"\\r\\n\");           // Replace all end of line \"\\r\" markers with \"\\r\\n\"\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 820,
    "y": 260,
    "wires": [
      [
        "5a46764f.9751f8"
      ]
    ]
  },
  {
    "id": "442e96e4.fd1988",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Append Program Execution Order & Sort",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getProgramParameter = global.get(\"getProgramParameter\");                //function (msg, controllerName, taskName, programName, parameterName)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Append Program Execution Order & Sort\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*{\n    \"DistinctResolvedPrograms\":[{\n        \"Controller\":controller_i,\n        \"ResolvedTask\":resolvedTask_,\n        \"ResolvedProgram\":resolvedProgram_i,\n        \"ExecutionOrder\":executionOrder_i,\n    }]\n}*/\n\n// Map in the Execution Order\nmsg.payload.DistinctResolvedPrograms.map((element, i)=>{\n    if ((element !== undefined) && (element !== undefined)) {\n        // Pull the execution order (program and routine) and attach it to the current element\n        //getProgramParameter = function (msg, controllerName, taskName, programName, parameterName)\n        element.ExecutionOrder = getProgramParameter(msg, element.Controller, element.ResolvedTask, element.ResolvedProgram, \"ExecutionOrder\");\n    }\n\n    return element;\n});\n\n// Sort\nmsg.payload.DistinctResolvedPrograms.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) Controller then\n    //  b) Task then\n    //  c) ExecutionOrder (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if ((element1.Controller < element2.Controller)) {return -1;}\n    else if ((element1.Controller > element2.Controller)) {return +1;}\n    else if ((element1.ResolvedTask < element2.ResolvedTask)) {return -1;}\n    else if ((element1.ResolvedTask > element2.ResolvedTask)) {return +1;}\n    else if (isNaN(element1.ExecutionOrder) && !isNaN(element2.ExecutionOrder)) {return -1;}\n    else if (!isNaN(element1.ExecutionOrder) && isNaN(element2.ExecutionOrder)) {return +1;}\n    else if ((Number(element1.ExecutionOrder) < Number(element2.ExecutionOrder))) {return -1;}\n    else if ((Number(element1.ExecutionOrder) > Number(element2.ExecutionOrder))) {return +1;}\n    else {return 0;}\n});\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1560,
    "y": 600,
    "wires": [
      [
        "d83b857.9d56d78",
        "7fffa10c.0d81e"
      ]
    ]
  },
  {
    "id": "7fffa10c.0d81e",
    "type": "function",
    "z": "98969df7.44714",
    "name": "Append Routine Execution Order & Sort",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getRoutineParameter = global.get(\"getRoutineParameter\");                //function (msg, controllerName, taskName, programName, routineName, parameterName)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Append Routine Execution Order & Sort\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\nglobal.set(\"currentCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*{\n    \"DistinctResolvedRoutines\":[{\n        \"Controller\":controller_i,\n        \"ResolvedTask\":resolvedTask_,\n        \"ResolvedProgram\":resolvedProgram_i,\n        \"ResolvedRoutine\":resolvedRoutine_i,\n        \"ExecutionOrder\":executionOrder_i,\n    }]\n}*/\n\n// Map in the Execution Order\nmsg.payload.DistinctResolvedRoutines.map((element, i)=>{\n    if ((element !== undefined) && (element !== undefined)) {\n        // Pull the execution order (program and routine) and attach it to the current element\n        //getRoutineParameter = function (msg, controllerName, taskName, programName, routineName, parameterName)\n        element.ExecutionOrder = getRoutineParameter(msg, element.Controller, element.ResolvedTask, element.ResolvedProgram, element.ResolvedRoutine, \"ExecutionOrder\");\n    }\n\n    return element;\n});\n\n// Sort\nmsg.payload.DistinctResolvedRoutines.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) Controller then\n    //  b) Task then\n    //  c) Program then\n    //  d) ExecutionOrder (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if ((element1.Controller < element2.Controller)) {return -1;}\n    else if ((element1.Controller > element2.Controller)) {return +1;}\n    else if ((element1.ResolvedTask < element2.ResolvedTask)) {return -1;}\n    else if ((element1.ResolvedTask > element2.ResolvedTask)) {return +1;}\n    else if ((element1.ResolvedProgram < element2.ResolvedProgram)) {return -1;}\n    else if ((element1.ResolvedProgram > element2.ResolvedProgram)) {return +1;}\n    else if (isNaN(element1.ExecutionOrder) && !isNaN(element2.ExecutionOrder)) {return -1;}\n    else if (!isNaN(element1.ExecutionOrder) && isNaN(element2.ExecutionOrder)) {return +1;}\n    else if ((Number(element1.ExecutionOrder) < Number(element2.ExecutionOrder))) {return -1;}\n    else if ((Number(element1.ExecutionOrder) > Number(element2.ExecutionOrder))) {return +1;}\n    else {return 0;}\n});\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1560,
    "y": 680,
    "wires": [
      [
        "4c3be175.13fef",
        "8d6467e5.255fc8",
        "93476b9e.825f08",
        "1005b40d.f5c25c"
      ]
    ]
  },
  {
    "id": "d83b857.9d56d78",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1630,
    "y": 640,
    "wires": []
  },
  {
    "id": "4c3be175.13fef",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1630,
    "y": 720,
    "wires": []
  },
  {
    "id": "91a4aed2.61ccc",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Sort Lists of Unique Keys",
    "info": "",
    "x": 1553,
    "y": 560,
    "wires": []
  },
  {
    "id": "6163be73.07b9",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1230,
    "y": 960,
    "wires": []
  },
  {
    "id": "581f665a.c579a8",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "TODO: Need to refactor away",
    "info": "Usages for CDef_Parameters_Pivoted:\nLoad Data Resolver Functions\tLine 141\tvar getModuleParameter = function (msg, controllerName, moduleTagName, parameterName)\n\n\nUsages for CDef_UsageScenarios_Pivoted:\nGet Usage Scenarios\tLine 30\t***Comment***\nGet Usage Scenarios\tLine 58\tGet Usage Scenarios\tLine 30\t***Comment***\nGet Usage Scenarios\tLine 112\t***Comment***\nGet Controller Tags\tLine 38\tvar cDef_UsageScenarios = msg.payload.CDef_UsageScenarios_Pivoted;\n\t\n\nUsages for CDef_CodeSnippets_Pivoted:\nLoad Data Resolver Functions\tLine 274\tvar getModuleSnippet = function (msg, controllerName, moduleTagName, snippetName)",
    "x": 1370.333251953125,
    "y": 138.3333282470703,
    "wires": []
  },
  {
    "id": "afc23471.baf298",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Incoming Trigger",
    "info": "",
    "x": 285,
    "y": 83.66666412353516,
    "wires": []
  },
  {
    "id": "5e607e08.cce0d",
    "type": "link in",
    "z": "55ffc120.e954e",
    "name": "Consume All Datasets",
    "links": [
      "868a6fb6.f8317",
      "8d6467e5.255fc8"
    ],
    "x": 220,
    "y": 123.66666412353516,
    "wires": [
      [
        "9e81c024.f45a",
        "707327d.069f5d8",
        "94d347ab.7c5818",
        "20354c8f.ba29c4"
      ]
    ]
  },
  {
    "id": "9e81c024.f45a",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 395,
    "y": 123.66666412353516,
    "wires": []
  },
  {
    "id": "707327d.069f5d8",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Build Interlocks Code Snippets & Comments",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar resolveModuleNonCodeReferences = global.get(\"resolveModuleNonCodeReferences\");      //function (msg, controllerName, moduleTagName, stringToResolve)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Build Interlocks Code Snippets & Comments\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Set up the constants to use later\nconst branchStartString = \"[\";\nconst branchEndString = \"]\";\nconst branchDelimiterString = \",\";\nconst rungEndString = \";\";\n\n// Setup constants\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t        // Operand CANNOT include { or }\nconst ThisKeyword = \"This\";\nconst CodeKeyword = \"Code\";\nconst DerivedKeyword = \"Derived\";\n\n/*{\n    \"ModuleCodeSnippets_Interlocks\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Snippets\":[{\n            \"SnippetName\":snippetName_i,\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }],\n    \"ControllerTags_Interlocks\":[{\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    }]\n}*/\nvar returnDataSet_CodeSnippets = [];\nvar returnDataSet_Tags = [];\n\n// Pull the global options\nvar interlockOptions = msg.payload.InterlockOptions;\n\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling Global snippets object.\");\n\n/************************************\n * Pull Defs for Tags to Create     *\n ************************************/\n // Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling Interlocks usage scenario & its tags collection.\");\n\n// Attempt to pull the global definition for the Interlock TagName from the CDef_UsageScenarios dataset\nvar global_Interlocks_TagName = null;\nvar tempFilterArray = msg.payload.CDef_UsageScenarios.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Interlocks\") && \n            (element.ParameterName == \"TagName\") &&\n            (element.CreateTag === true));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_Interlocks_TagName = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Interlock Delay Timer TagName from the CDef_UsageScenarios dataset\nvar global_Interlocks_DelayTimerTagName = null;\nvar tempFilterArray = msg.payload.CDef_UsageScenarios.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Interlocks\") && \n            (element.ParameterName == \"DelayTimerTagName\") &&\n            (element.CreateTag === true));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_Interlocks_DelayTimerTagName = tempFilterArray[0];\n}\n\n/************************************\n * Pull Defs for Code to Create     *\n ************************************/\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling Interlocks usage scenario & its snippets collection.\");\n\n// Attempt to pull the global definition for the Interlock Main Snippet from the CDef_CodeSnippets dataset\nvar global_InterlockSnippets_Main = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Interlocks\") && \n            (element.SnippetName == \"Main\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_InterlockSnippets_Main = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Interlock Branch Snippet from the CDef_CodeSnippets dataset\nvar global_InterlockSnippets_Branch = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Interlocks\") && \n            (element.SnippetName == \"Branch\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_InterlockSnippets_Branch = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Interlock BranchDelayed Snippet from the CDef_CodeSnippets dataset\nvar global_InterlockSnippets_BranchDelayed = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Interlocks\") && \n            (element.SnippetName == \"BranchDelayed\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_InterlockSnippets_BranchDelayed = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Interlock ConditionCodePlaceholder Snippet from the CDef_CodeSnippets dataset\nvar global_InterlockSnippets_ConditionCodePlaceholder = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Interlocks\") && \n            (element.SnippetName == \"ConditionCodePlaceholder\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_InterlockSnippets_ConditionCodePlaceholder = tempFilterArray[0];\n}\n\n// Test if the required snippets exist\nif ((global_InterlockSnippets_Main === null) || (global_InterlockSnippets_Main === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'Main' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\");\n}\nelse if ((global_InterlockSnippets_Branch === null) || (global_InterlockSnippets_Branch === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'Branch' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\");\n}\nelse if ((global_InterlockSnippets_BranchDelayed === null) || (global_InterlockSnippets_BranchDelayed === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'BranchDelayed' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\");\n}\nelse if ((global_InterlockSnippets_ConditionCodePlaceholder === null) || (global_InterlockSnippets_ConditionCodePlaceholder === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'ConditionCodePlaceholder' snippet for the Interlocks usage scenario for the Global class in the code snippets definition.\");\n}\nelse {\n    // All required global elements have been found\n    //Iterate the modules in the Interlocks_pivoted data set to build the code-comment pair for the interlocks\n    for (var i = 0; i < msg.payload.Interlocks_Pivoted.length; i++){\n        // Cache a reference to the current module\n        var module_i = msg.payload.Interlocks_Pivoted[i];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var moduleTagName_i = module_i.ModuleTagName;\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Item = \" + controller_i + \"-\" + moduleTagName_i + \".\");\n        \n        // Attempt to find the current module in the Modules List dataset\n        var tempFilterArray = msg.payload.Modules.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return ((element.Controller == controller_i) && \n                    (element.ModuleTagName == moduleTagName_i));\n            }\n        });\n        \n        // Test if the filtered list has anything in it\n        if (tempFilterArray.length <= 0) {\n            // Log a validation error\n            logValidationErrorMessage(thisCallStackLevel, \"Interlocks exist for \" + controller_i + \"'s \" + moduleTagName_i + \n                \" but it doesn't exist in the modules list.\");\n        }\n        else {\n            // Default the AllConditionsCode value, which will later be referenced by the {Derived[~~]} find & replace code\n            var allConditionsCode_i = \"\";\n            \n            /********************************************\n            * Build Interlock Conditions Code & Tags    *\n            *********************************************/\n            // Iterate the interlocks in the collection\n            for (var j = 0; j < module_i.Interlocks.length; j++){\n                // Cache a reference to the current interlock\n                var interlock_i = module_i.Interlocks[j];\n                \n                // Pull the current interlock's data\n                var index_i = interlock_i.Index;\n                var conditionCode_i = interlock_i.ConditionCode;\n                var conditionDescription_i = interlock_i.ConditionDescription;\n                var isDebounced_i = interlock_i.IsDebounced;\n                var debounceTime_i = interlock_i.DebounceTime;\n                var okayState_i = interlock_i.OkayState;\n                var isBypassable_i = interlock_i.IsBypassable;\n                var canNavigate_i = interlock_i.CanNavigate;\n                var associatedTag = interlock_i.AssociatedTag;\n                \n                // Debug Messages\n                logTraceMessage(thisCallStackLevel, \"index_i = \" + index_i);\n                logTraceMessage(thisCallStackLevel, \"conditionCode_i = \" + conditionCode_i);\n                logTraceMessage(thisCallStackLevel, \"conditionDescription_i = \" + conditionDescription_i);\n                logTraceMessage(thisCallStackLevel, \"isDebounced_i = \" + isDebounced_i);\n                logTraceMessage(thisCallStackLevel, \"debounceTime_i = \" + debounceTime_i);\n                logTraceMessage(thisCallStackLevel, \"okayState_i = \" + okayState_i);\n                logTraceMessage(thisCallStackLevel, \"isBypassable_i = \" + isBypassable_i);\n                logTraceMessage(thisCallStackLevel, \"canNavigate_i = \" + canNavigate_i);\n                logTraceMessage(thisCallStackLevel, \"associatedTag = \" + associatedTag);\n                \n                // Derive the ConditionCode value, which will later be referenced by the {Derived[~~]} find & replace code\n                // If the incoming condition code is null or undefined, use the placeholder snippet\n                if ((conditionCode_i === null) || (conditionCode_i === undefined)) {\n                    // Use the placeholder snippet\n                    // FUTURE: Use natural language instead of code.  Will need parsing.\n                    conditionCode_i = global_InterlockSnippets_ConditionCodePlaceholder.Code;\n                }\n                \n                // Derive the Description value, which will later be referenced by the {Derived[~~]} find & replace code\n                // If the incoming descriptionse is null or undefined, use an empty string\n                if ((conditionDescription_i === null) || (conditionDescription_i === undefined)) {\n                    conditionDescription_i = \"\";\n                }\n                \n                // Derive the FormattedIndex value, which will later be referenced by the {Derived[~~]} find & replace code\n                var formattedIndex_i = Number(index_i).toLocaleString(undefined, {\"minimumIntegerDigits\": interlockOptions.MinimumIntegerDigits});\n                \n                /********************************************\n                * Build Dictionary                          *\n                *********************************************/\n                // Create dictionary, populate it, and push it to the local context\n                var derivedItemsDictionary = {};\n                derivedItemsDictionary.AllConditionsCode = allConditionsCode_i;\n                derivedItemsDictionary.Index = index_i;\n                derivedItemsDictionary.FormattedIndex = formattedIndex_i;\n                derivedItemsDictionary.ConditionCode = conditionCode_i;\n                derivedItemsDictionary.ConditionDescription = conditionDescription_i;\n                context.set('derivedItemsDictionary', derivedItemsDictionary);\n                \n                // Debug Messages\n                logTraceMessage(thisCallStackLevel, \"Derived Index = \" + derivedItemsDictionary.Index);\n                logTraceMessage(thisCallStackLevel, \"Derived FormattedIndex = \" + derivedItemsDictionary.FormattedIndex);\n                logTraceMessage(thisCallStackLevel, \"Derived ConditionCode = \" + derivedItemsDictionary.ConditionCode);\n                logTraceMessage(thisCallStackLevel, \"Derived ConditionDescription = \" + derivedItemsDictionary.ConditionDescription);\n                \n                /********************************************\n                * Build Interlock Conditions Code           *\n                *********************************************/\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"Building branch code.\");\n                \n                // Pull the normal or delayed branch code based on the interlock's configuration\n                var branchCode_i = null;\n                if (isDebounced_i) {\n                    // Pull the delayed branch code\n                    branchCode_i = global_InterlockSnippets_BranchDelayed.Code;\n                }\n                else {\n                    // Pull the normal branch code\n                    branchCode_i = global_InterlockSnippets_Branch.Code;\n                }\n                \n                // Test if the returned branch code is valid or not\n                // If invalid, replace it with an empty string\n                if ((branchCode_i === null) || (branchCode_i === undefined)) {\n                    branchCode_i = \"\";\n                }\n                \n                // Resolve all references\n                branchCode_i = resolveReferences(controller_i, moduleTagName_i, branchCode_i);\n                \n                // Append the current branch to the combined set of all branches\n                if (allConditionsCode_i.length <= 0) {\n                    // First thing to add\n                    allConditionsCode_i = branchCode_i;\n                }\n                else {\n                    // All subsequent additions.  Append a delimiter and the \n                    allConditionsCode_i = allConditionsCode_i + branchDelimiterString + branchCode_i;\n                }\n                \n                /********************************************\n                * Build Interlock Conditions Tags           *\n                *********************************************/\n                if (isDebounced_i) {\n                    // Test if there is a tag pattern to use\n                    if ((global_Interlocks_DelayTimerTagName !== null) && (global_Interlocks_DelayTimerTagName !== undefined)){\n                        // Debug messages\n                        logDebugMessage(thisCallStackLevel, \"Adding DelayTimerTagName to return dataset.\");\n                        \n                        // Build tag pieces\n                        var tempTagName = resolveReferences(controller_i, moduleTagName_i, global_Interlocks_DelayTimerTagName.TagName);\n                        var tempDataType = global_Interlocks_DelayTimerTagName.DataType;\n                        var tempDescription = resolveReferences(controller_i, moduleTagName_i, global_Interlocks_DelayTimerTagName.TagDescription);\n                        var tempAttributes = GetAttributes(global_Interlocks_DelayTimerTagName.DataType);\n                        \n                        // Debug messages\n                        logTraceMessage(thisCallStackLevel, \"    Template TagName = \" + global_Interlocks_DelayTimerTagName.TagName);\n                        logTraceMessage(thisCallStackLevel, \"    Template TagDescription = \" + global_Interlocks_DelayTimerTagName.TagDescription);\n                        logDebugMessage(thisCallStackLevel, \"    TagName = \"+  tempTagName);\n                        logDebugMessage(thisCallStackLevel, \"    DataType = \"+  tempDataType);\n                        logDebugMessage(thisCallStackLevel, \"    Description = \"+  tempDescription);\n                        logDebugMessage(thisCallStackLevel, \"    Attributes = \"+  tempAttributes);\n                        \n                        // Add this tag to the return dataset\n                        // Pull the tag name & tag description syntax & resolve all parameter references\n                        returnDataSet_Tags.push({\n                            \"Controller\": controller_i,\n                            \"Scope\": \"\",\n                            \"TagName\": tempTagName,\n                            \"DataType\": tempDataType,\n                            \"Description\": tempDescription,\n                            \"Specifier\": \"\",\n                            \"Attributes\": tempAttributes\n                        });\n                    }\n                }\n            }\n            \n            // Debug messages\n            logDebugMessage(thisCallStackLevel, \"allConditionsCode_i = \" + allConditionsCode_i);\n            \n            /********************************************\n            * Build Dictionary                          *\n            *********************************************/\n            // Create dictionary, populate it, and push it to the local context\n            var derivedItemsDictionary = {};\n            derivedItemsDictionary.AllConditionsCode = allConditionsCode_i;\n            context.set('derivedItemsDictionary', derivedItemsDictionary);\n            \n            // Debug Messages\n            logTraceMessage(thisCallStackLevel, \"Derived AllConditionsCode = \" + derivedItemsDictionary.AllConditionsCode);\n            \n            /********************************************\n            * Build Composite Interlock Code            *\n            *********************************************/\n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"Building all branches code.\");\n            \n            // Pull the Main interlock snippet\n            var mainCode_i = global_InterlockSnippets_Main.Code;\n            var mainComment_i = global_InterlockSnippets_Main.Comment;\n            \n            // Resolve all references\n            mainCode_i = resolveReferences(controller_i, moduleTagName_i, mainCode_i);\n            mainComment_i = resolveReferences(controller_i, moduleTagName_i, mainComment_i);\n            \n            // Push the derived code out to the return dataset\n            returnDataSet_CodeSnippets.push({\n                    \"Controller\":controller_i,\n                    \"ModuleTagName\":moduleTagName_i,\n                    \"Snippets\":[{\n                        \"SnippetName\":\"AllInterlocksCode\",\n                        \"Code\":mainCode_i,\n                        \"Comment\":mainComment_i\n                    }]\n            });\n            \n            /********************************************\n            * Build Composite Interlock Tag             *\n            *********************************************/\n            // Test if there is a tag pattern to use\n            if ((global_Interlocks_TagName !== null) && (global_Interlocks_TagName !== undefined)){\n                // Debug messages\n                logDebugMessage(thisCallStackLevel, \"Adding TagName to return dataset.\");\n                \n                // Build tag pieces\n                var tempTagName = resolveReferences(controller_i, moduleTagName_i, global_Interlocks_TagName.TagName);\n                var tempDataType = global_Interlocks_TagName.DataType;\n                var tempDescription = resolveReferences(controller_i, moduleTagName_i, global_Interlocks_TagName.TagDescription);\n                var tempAttributes = GetAttributes(global_Interlocks_TagName.DataType);\n                \n                // Debug messages\n                logTraceMessage(thisCallStackLevel, \"    Template TagName = \" + global_Interlocks_TagName.TagName);\n                logTraceMessage(thisCallStackLevel, \"    Template TagDescription = \" + global_Interlocks_TagName.TagDescription);\n                logDebugMessage(thisCallStackLevel, \"    TagName = \"+  tempTagName);\n                logDebugMessage(thisCallStackLevel, \"    DataType = \"+  tempDataType);\n                logDebugMessage(thisCallStackLevel, \"    Description = \"+  tempDescription);\n                logDebugMessage(thisCallStackLevel, \"    Attributes = \"+  tempAttributes);\n                \n                // Add this tag to the return dataset\n                // Pull the tag name & tag description syntax & resolve all parameter references\n                returnDataSet_Tags.push({\n                    \"Controller\": controller_i,\n                    \"Scope\": \"\",\n                    \"TagName\": tempTagName,\n                    \"DataType\": tempDataType,\n                    \"Description\": tempDescription,\n                    \"Specifier\": \"\",\n                    \"Attributes\": tempAttributes\n                });\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload = {\n    \"ModuleCodeSnippets_Interlocks\": returnDataSet_CodeSnippets,\n    \"ModuleControllerTags_Interlocks\": returnDataSet_Tags\n};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction GetAttributes(dataType) {\n    var returnValue = null;\n    \n    // Strip off array brackets\n    var dataTypeWithoutArray = dataType.replace(/\\[(?:\\d|,)+\\]/img, \"\");\n    \n    // Return the Attributes based on the base data type\n    switch (dataTypeWithoutArray) {\n        case \"BOOL\":\n        case \"SINT\":\n        case \"INT\":\n        case \"DINT\":\n        case \"LINT\":\n            returnValue = \"(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n            \n        case \"REAL\":\n            returnValue = \"(RADIX := Float, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n        \n        case \"MESSAGE\":\n            returnValue = \"(ExternalAccess := Read/Write, MessageType := Unconfigured, RequestedLength := 1, CommTypeCode := 0, LocalIndex := 0)\";\n            break;\n        \n        default:\n            returnValue = \"(Constant := false, ExternalAccess := Read/Write)\";\n            break;\n    }\n    return returnValue;\n}\n\nfunction resolveReferences(controllerName, moduleTagName, stringToResolve) {\n    // Reduce the string to resolve down as much as possible\n    // Set variables for logging\n    var localCallStackLevel = \"resolveReferences\";\n    \n    // Debug Messages\n    logVerboseMessage(localCallStackLevel, \"-->resolveReferences(\" + controllerName + \", \" + moduleTagName + \", \" + stringToResolve + \")\");\n    \n    // Setup the RegExp object\n    var reCode = new RegExp(CodeDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    \n    // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reCode.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Resolve all non-code references before resolving code ones\n        stringToResolve = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, stringToResolve);\n        \n        // Pull the next match\n        match = reCode.exec(stringToResolve);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Debug Messages\n            logVerboseMessage(localCallStackLevel, \"wholeMatch = \" + wholeMatch);\n            logVerboseMessage(localCallStackLevel, \"operator = \" + wholeMatch);\n            logVerboseMessage(localCallStackLevel, \"operand = \" + wholeMatch);\n            \n            // Perform find & replace based on the operator type\n            var replaceText = null;\n            switch(operator) {\n                case CodeKeyword:\n                    // Do a snippet lookup.\n                    // ***This loopup is limited in scope to the global interlocks snippet set.***\n                    // ***Exclude all required snippets from the lookup to prevent circular references.***\n                    var global_InterlockSnippets_Temp = null;\n                    var tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.ClassName == \"Global\") && \n                                (element.UsageScenario == \"Interlocks\") && \n                                (element.SnippetName === operand) &&\n                                (element.SnippetName !== \"Main\") &&\n                                (element.SnippetName !== \"Branch\") &&\n                                (element.SnippetName !== \"BranchDelayed\") &&\n                                (element.SnippetName !== \"ConditionCodePlaceholder\"));\n                        }\n                    });\n                    \n                    // Test if the filtered list has anything in it\n                    if (tempFilterArray.length > 0) {\n                        global_InterlockSnippets_Temp = tempFilterArray[0];\n                    }\n                    \n                    // Test if snippet was found\n                    if ((global_InterlockSnippets_Temp !== null) && (global_InterlockSnippets_Temp !== undefined)) {\n                        // Debug messages\n                        logVerboseMessage(localCallStackLevel, \">>>Found Code<<<\");\n                        \n                        // Snippet was found.  Use snippet code\n                        replaceText = global_InterlockSnippets_Temp.Code;\n                    }\n                    break;\n                    \n                case DerivedKeyword:\n                    // Do a lookup of the derived calculations within this routine.\n                    // Pull the derived items dictionary from the local context\n                    var derivedItemsDictionary = context.get('derivedItemsDictionary');\n                    \n                    // Test if it exists\n                    if ((derivedItemsDictionary !== null) && (derivedItemsDictionary !== undefined)) {\n                        // Test if it has the requested item or not\n                        if (derivedItemsDictionary.hasOwnProperty(operand)) {\n                            // Debug messages\n                            logVerboseMessage(localCallStackLevel, \">>>Found Derived<<<\");\n                            \n                            // Derived item found in the dictionary.  Pull it to use.\n                            replaceText = derivedItemsDictionary[operand];\n                        }\n                    }\n                    break;\n            }\n            \n            // Test if there is a replacement string\n            if ((replaceText !== null) && (replaceText !== undefined)) {\n                // Debug messages\n                logVerboseMessage(localCallStackLevel, \"replaceText = \" + replaceText);\n                \n                // Perform the replacement\n                stringToResolve = stringToResolve.substring(0, match.index) + replaceText + stringToResolve.substring(reCode.lastIndex)\n                \n                // Start the RegExp's pointer to start scanning at the beginning of the last match\n                // This is done in case the replacement also contains matches that need replacing\n                reCode.lastIndex = match.index;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Debug Messages\n    logVerboseMessage(localCallStackLevel,  \"<-- returnValue = (\" + stringToResolve + \")\");\n    \n    // Return the result\n    return stringToResolve;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 495,
    "y": 203.66666412353516,
    "wires": [
      [
        "60b0f619.c47488"
      ]
    ]
  },
  {
    "id": "94d347ab.7c5818",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Build Permissives Code Snippets & Comments",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar resolveModuleNonCodeReferences = global.get(\"resolveModuleNonCodeReferences\");      //function (msg, controllerName, moduleTagName, stringToResolve)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Build Permissives Code Snippets & Comments\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Set up the constants to use later\nconst branchStartString = \"[\";\nconst branchEndString = \"]\";\nconst branchDelimiterString = \",\";\nconst rungEndString = \";\";\n\n// Setup constants\nconst CodeDynamicRefsRegex = \"{((?:Code)|(?:Derived))\\\\[([^{}]+?)\\\\]}\";\t        // Operand CANNOT include { or }\nconst ThisKeyword = \"This\";\nconst CodeKeyword = \"Code\";\nconst DerivedKeyword = \"Derived\";\n\n/*{\n    \"ModuleCodeSnippets_Permissives\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Snippets\":[{\n            \"SnippetName\":snippetName_i,\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }],\n    \"ControllerTags_Permissives\":[{\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    }]\n}*/\nvar returnDataSet_CodeSnippets = [];\nvar returnDataSet_Tags = [];\n\n// Pull the global options\nvar permissiveOptions = msg.payload.PermissiveOptions;\n\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling Global snippets object.\");\n\n/************************************\n * Pull Defs for Tags to Create     *\n ************************************/\n // Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling Permissives usage scenario & its tags collection.\");\n\n// Attempt to pull the global definition for the Permissive TagName from the CDef_UsageScenarios dataset\nvar global_Permissives_TagName = null;\nvar tempFilterArray = msg.payload.CDef_UsageScenarios.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Permissives\") && \n            (element.ParameterName == \"TagName\") &&\n            (element.CreateTag === true));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_Permissives_TagName = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Permissive Delay Timer TagName from the CDef_UsageScenarios dataset\nvar global_Permissives_DelayTimerTagName = null;\nvar tempFilterArray = msg.payload.CDef_UsageScenarios.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Permissives\") && \n            (element.ParameterName == \"DelayTimerTagName\") &&\n            (element.CreateTag === true));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_Permissives_DelayTimerTagName = tempFilterArray[0];\n}\n\n/************************************\n * Pull Defs for Code to Create     *\n ************************************/\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling Permissives usage scenario & its snippets collection.\");\n\n// Attempt to pull the global definition for the Permissive Main Snippet from the CDef_CodeSnippets dataset\nvar global_PermissiveSnippets_Main = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Permissives\") && \n            (element.SnippetName == \"Main\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_PermissiveSnippets_Main = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Permissive Branch Snippet from the CDef_CodeSnippets dataset\nvar global_PermissiveSnippets_Branch = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Permissives\") && \n            (element.SnippetName == \"Branch\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_PermissiveSnippets_Branch = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Permissive BranchDelayed Snippet from the CDef_CodeSnippets dataset\nvar global_PermissiveSnippets_BranchDelayed = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Permissives\") && \n            (element.SnippetName == \"BranchDelayed\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_PermissiveSnippets_BranchDelayed = tempFilterArray[0];\n}\n\n// Attempt to pull the global definition for the Permissive ConditionCodePlaceholder Snippet from the CDef_CodeSnippets dataset\nvar global_PermissiveSnippets_ConditionCodePlaceholder = null;\nvar tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.ClassName == \"Global\") && \n            (element.UsageScenario == \"Permissives\") && \n            (element.SnippetName == \"ConditionCodePlaceholder\"));\n    }\n});\n\n// Test if the filtered list has anything in it\nif (tempFilterArray.length > 0) {\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \">>>Found<<<\");\n    global_PermissiveSnippets_ConditionCodePlaceholder = tempFilterArray[0];\n}\n\n// Test if the required snippets exist\nif ((global_PermissiveSnippets_Main === null) || (global_PermissiveSnippets_Main === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'Main' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\");\n}\nelse if ((global_PermissiveSnippets_Branch === null) || (global_PermissiveSnippets_Branch === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'Branch' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\");\n}\nelse if ((global_PermissiveSnippets_BranchDelayed === null) || (global_PermissiveSnippets_BranchDelayed === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'BranchDelayed' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\");\n}\nelse if ((global_PermissiveSnippets_ConditionCodePlaceholder === null) || (global_PermissiveSnippets_ConditionCodePlaceholder === undefined)) {\n    // Log a validation error\n    logValidationErrorMessage(thisCallStackLevel, \"Cannot find the 'ConditionCodePlaceholder' snippet for the Permissives usage scenario for the Global class in the code snippets definition.\");\n}\nelse {\n    // All required global elements have been found\n    //Iterate the modules in the Permissives_pivoted data set to build the code-comment pair for the permissives\n    for (var i = 0; i < msg.payload.Permissives_Pivoted.length; i++){\n        // Cache a reference to the current module\n        var module_i = msg.payload.Permissives_Pivoted[i];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var moduleTagName_i = module_i.ModuleTagName;\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Item = \" + controller_i + \"-\" + moduleTagName_i + \".\");\n        \n        // Attempt to find the current module in the Modules List dataset\n        var tempFilterArray = msg.payload.Modules.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return ((element.Controller == controller_i) && \n                    (element.ModuleTagName == moduleTagName_i));\n            }\n        });\n        \n        // Test if the filtered list has anything in it\n        if (tempFilterArray.length <= 0) {\n            // Log a validation error\n            logValidationErrorMessage(thisCallStackLevel, \"Permissives exist for \" + controller_i + \"'s \" + moduleTagName_i + \n                \" but it doesn't exist in the modules list.\");\n        }\n        else {\n            // Default the AllConditionsCode value, which will later be referenced by the {Derived[~~]} find & replace code\n            var allConditionsCode_i = \"\";\n            \n            /********************************************\n            * Build Permissive Conditions Code & Tags    *\n            *********************************************/\n            // Iterate the permissives in the collection\n            for (var j = 0; j < module_i.Permissives.length; j++){\n                // Cache a reference to the current permissive\n                var permissive_i = module_i.Permissives[j];\n                \n                // Pull the current permissive's data\n                var index_i = permissive_i.Index;\n                var conditionCode_i = permissive_i.ConditionCode;\n                var conditionDescription_i = permissive_i.ConditionDescription;\n                var isDebounced_i = permissive_i.IsDebounced;\n                var debounceTime_i = permissive_i.DebounceTime;\n                var okayState_i = permissive_i.OkayState;\n                var isBypassable_i = permissive_i.IsBypassable;\n                var canNavigate_i = permissive_i.CanNavigate;\n                var associatedTag = permissive_i.AssociatedTag;\n                \n                // Debug Messages\n                logTraceMessage(thisCallStackLevel, \"index_i = \" + index_i);\n                logTraceMessage(thisCallStackLevel, \"conditionCode_i = \" + conditionCode_i);\n                logTraceMessage(thisCallStackLevel, \"conditionDescription_i = \" + conditionDescription_i);\n                logTraceMessage(thisCallStackLevel, \"isDebounced_i = \" + isDebounced_i);\n                logTraceMessage(thisCallStackLevel, \"debounceTime_i = \" + debounceTime_i);\n                logTraceMessage(thisCallStackLevel, \"okayState_i = \" + okayState_i);\n                logTraceMessage(thisCallStackLevel, \"isBypassable_i = \" + isBypassable_i);\n                logTraceMessage(thisCallStackLevel, \"canNavigate_i = \" + canNavigate_i);\n                logTraceMessage(thisCallStackLevel, \"associatedTag = \" + associatedTag);\n                \n                // Derive the ConditionCode value, which will later be referenced by the {Derived[~~]} find & replace code\n                // If the incoming condition code is null or undefined, use the placeholder snippet\n                if ((conditionCode_i === null) || (conditionCode_i === undefined)) {\n                    // Use the placeholder snippet\n                    // FUTURE: Use natural language instead of code.  Will need parsing.\n                    conditionCode_i = global_PermissiveSnippets_ConditionCodePlaceholder.Code;\n                }\n                \n                // Derive the Description value, which will later be referenced by the {Derived[~~]} find & replace code\n                // If the incoming descriptionse is null or undefined, use an empty string\n                if ((conditionDescription_i === null) || (conditionDescription_i === undefined)) {\n                    conditionDescription_i = \"\";\n                }\n                \n                // Derive the FormattedIndex value, which will later be referenced by the {Derived[~~]} find & replace code\n                var formattedIndex_i = Number(index_i).toLocaleString(undefined, {\"minimumIntegerDigits\": permissiveOptions.MinimumIntegerDigits});\n                \n                /********************************************\n                * Build Dictionary                          *\n                *********************************************/\n                // Create dictionary, populate it, and push it to the local context\n                var derivedItemsDictionary = {};\n                derivedItemsDictionary.AllConditionsCode = allConditionsCode_i;\n                derivedItemsDictionary.Index = index_i;\n                derivedItemsDictionary.FormattedIndex = formattedIndex_i;\n                derivedItemsDictionary.ConditionCode = conditionCode_i;\n                derivedItemsDictionary.ConditionDescription = conditionDescription_i;\n                context.set('derivedItemsDictionary', derivedItemsDictionary);\n                \n                // Debug Messages\n                logTraceMessage(thisCallStackLevel, \"Derived Index = \" + derivedItemsDictionary.Index);\n                logTraceMessage(thisCallStackLevel, \"Derived FormattedIndex = \" + derivedItemsDictionary.FormattedIndex);\n                logTraceMessage(thisCallStackLevel, \"Derived ConditionCode = \" + derivedItemsDictionary.ConditionCode);\n                logTraceMessage(thisCallStackLevel, \"Derived ConditionDescription = \" + derivedItemsDictionary.ConditionDescription);\n                \n                /********************************************\n                * Build Permissive Conditions Code           *\n                *********************************************/\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"Building branch code.\");\n                \n                // Pull the normal or delayed branch code based on the permissive's configuration\n                var branchCode_i = null;\n                if (isDebounced_i) {\n                    // Pull the delayed branch code\n                    branchCode_i = global_PermissiveSnippets_BranchDelayed.Code;\n                }\n                else {\n                    // Pull the normal branch code\n                    branchCode_i = global_PermissiveSnippets_Branch.Code;\n                }\n                \n                // Test if the returned branch code is valid or not\n                // If invalid, replace it with an empty string\n                if ((branchCode_i === null) || (branchCode_i === undefined)) {\n                    branchCode_i = \"\";\n                }\n                \n                // Resolve all references\n                branchCode_i = resolveReferences(controller_i, moduleTagName_i, branchCode_i);\n                \n                // Append the current branch to the combined set of all branches\n                if (allConditionsCode_i.length <= 0) {\n                    // First thing to add\n                    allConditionsCode_i = branchCode_i;\n                }\n                else {\n                    // All subsequent additions.  Append a delimiter and the \n                    allConditionsCode_i = allConditionsCode_i + branchDelimiterString + branchCode_i;\n                }\n                \n                /********************************************\n                * Build Permissive Conditions Tags           *\n                *********************************************/\n                if (isDebounced_i) {\n                    // Test if there is a tag pattern to use\n                    if ((global_Permissives_DelayTimerTagName !== null) && (global_Permissives_DelayTimerTagName !== undefined)){\n                        // Debug messages\n                        logDebugMessage(thisCallStackLevel, \"Adding DelayTimerTagName to return dataset.\");\n                        \n                        // Build tag pieces\n                        var tempTagName = resolveReferences(controller_i, moduleTagName_i, global_Permissives_DelayTimerTagName.TagName);\n                        var tempDataType = global_Permissives_DelayTimerTagName.DataType;\n                        var tempDescription = resolveReferences(controller_i, moduleTagName_i, global_Permissives_DelayTimerTagName.TagDescription);\n                        var tempAttributes = GetAttributes(global_Permissives_DelayTimerTagName.DataType);\n                        \n                        // Debug messages\n                        logTraceMessage(thisCallStackLevel, \"    Template TagName = \" + global_Permissives_DelayTimerTagName.TagName);\n                        logTraceMessage(thisCallStackLevel, \"    Template TagDescription = \" + global_Permissives_DelayTimerTagName.TagDescription);\n                        logDebugMessage(thisCallStackLevel, \"    TagName = \"+  tempTagName);\n                        logDebugMessage(thisCallStackLevel, \"    DataType = \"+  tempDataType);\n                        logDebugMessage(thisCallStackLevel, \"    Description = \"+  tempDescription);\n                        logDebugMessage(thisCallStackLevel, \"    Attributes = \"+  tempAttributes);\n                        \n                        // Add this tag to the return dataset\n                        // Pull the tag name & tag description syntax & resolve all parameter references\n                        returnDataSet_Tags.push({\n                            \"Controller\": controller_i,\n                            \"Scope\": \"\",\n                            \"TagName\": tempTagName,\n                            \"DataType\": tempDataType,\n                            \"Description\": tempDescription,\n                            \"Specifier\": \"\",\n                            \"Attributes\": tempAttributes\n                        });\n                    }\n                }\n            }\n            \n            // Debug messages\n            logDebugMessage(thisCallStackLevel, \"allConditionsCode_i = \" + allConditionsCode_i);\n            \n            /********************************************\n            * Build Dictionary                          *\n            *********************************************/\n            // Create dictionary, populate it, and push it to the local context\n            var derivedItemsDictionary = {};\n            derivedItemsDictionary.AllConditionsCode = allConditionsCode_i;\n            context.set('derivedItemsDictionary', derivedItemsDictionary);\n            \n            // Debug Messages\n            logTraceMessage(thisCallStackLevel, \"Derived AllConditionsCode = \" + derivedItemsDictionary.AllConditionsCode);\n            \n            /********************************************\n            * Build Composite Permissive Code            *\n            *********************************************/\n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"Building all branches code.\");\n            \n            // Pull the Main permissive snippet\n            var mainCode_i = global_PermissiveSnippets_Main.Code;\n            var mainComment_i = global_PermissiveSnippets_Main.Comment;\n            \n            // Resolve all references\n            mainCode_i = resolveReferences(controller_i, moduleTagName_i, mainCode_i);\n            mainComment_i = resolveReferences(controller_i, moduleTagName_i, mainComment_i);\n            \n            // Push the derived code out to the return dataset\n            returnDataSet_CodeSnippets.push({\n                    \"Controller\":controller_i,\n                    \"ModuleTagName\":moduleTagName_i,\n                    \"Snippets\":[{\n                        \"SnippetName\":\"AllPermissivesCode\",\n                        \"Code\":mainCode_i,\n                        \"Comment\":mainComment_i\n                    }]\n            });\n            \n            /********************************************\n            * Build Composite Permissive Tag             *\n            *********************************************/\n            // Test if there is a tag pattern to use\n            if ((global_Permissives_TagName !== null) && (global_Permissives_TagName !== undefined)){\n                // Debug messages\n                logDebugMessage(thisCallStackLevel, \"Adding TagName to return dataset.\");\n                \n                // Build tag pieces\n                var tempTagName = resolveReferences(controller_i, moduleTagName_i, global_Permissives_TagName.TagName);\n                var tempDataType = global_Permissives_TagName.DataType;\n                var tempDescription = resolveReferences(controller_i, moduleTagName_i, global_Permissives_TagName.TagDescription);\n                var tempAttributes = GetAttributes(global_Permissives_TagName.DataType);\n                \n                // Debug messages\n                logTraceMessage(thisCallStackLevel, \"    Template TagName = \" + global_Permissives_TagName.TagName);\n                logTraceMessage(thisCallStackLevel, \"    Template TagDescription = \" + global_Permissives_TagName.TagDescription);\n                logDebugMessage(thisCallStackLevel, \"    TagName = \"+  tempTagName);\n                logDebugMessage(thisCallStackLevel, \"    DataType = \"+  tempDataType);\n                logDebugMessage(thisCallStackLevel, \"    Description = \"+  tempDescription);\n                logDebugMessage(thisCallStackLevel, \"    Attributes = \"+  tempAttributes);\n                \n                // Add this tag to the return dataset\n                // Pull the tag name & tag description syntax & resolve all parameter references\n                returnDataSet_Tags.push({\n                    \"Controller\": controller_i,\n                    \"Scope\": \"\",\n                    \"TagName\": tempTagName,\n                    \"DataType\": tempDataType,\n                    \"Description\": tempDescription,\n                    \"Specifier\": \"\",\n                    \"Attributes\": tempAttributes\n                });\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload = {\n    \"ModuleCodeSnippets_Permissives\": returnDataSet_CodeSnippets,\n    \"ModuleControllerTags_Permissives\": returnDataSet_Tags\n};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction GetAttributes(dataType) {\n    var returnValue = null;\n    \n    // Strip off array brackets\n    var dataTypeWithoutArray = dataType.replace(/\\[(?:\\d|,)+\\]/img, \"\");\n    \n    // Return the Attributes based on the base data type\n    switch (dataTypeWithoutArray) {\n        case \"BOOL\":\n        case \"SINT\":\n        case \"INT\":\n        case \"DINT\":\n        case \"LINT\":\n            returnValue = \"(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n            \n        case \"REAL\":\n            returnValue = \"(RADIX := Float, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n        \n        case \"MESSAGE\":\n            returnValue = \"(ExternalAccess := Read/Write, MessageType := Unconfigured, RequestedLength := 1, CommTypeCode := 0, LocalIndex := 0)\";\n            break;\n        \n        default:\n            returnValue = \"(Constant := false, ExternalAccess := Read/Write)\";\n            break;\n    }\n    return returnValue;\n}\n\nfunction resolveReferences(controllerName, moduleTagName, stringToResolve) {\n    // Reduce the string to resolve down as much as possible\n    // Set variables for logging\n    var localCallStackLevel = \"resolveReferences\";\n    \n    // Debug Messages\n    logVerboseMessage(localCallStackLevel, \"-->resolveReferences(\" + controllerName + \", \" + moduleTagName + \", \" + stringToResolve + \")\");\n    \n    // Setup the RegExp object\n    var reCode = new RegExp(CodeDynamicRefsRegex, \"mg\");     //NOTE:  add an 'i' as a flag if this is ever swapped to a case-insensitive match routine\n    \n    // Find and replace all {Derived[~~]} & {Code[~~]} references that will resolve correctly\n    var doneSearching = false;\n    var iterations = 0;\n    var maxIterations = 5000;\n    reCode.lastIndex = 0;    // Start the regex out at the beginning of the string\n    while (!doneSearching && (iterations < maxIterations)) {\n        // Resolve all non-code references before resolving code ones\n        stringToResolve = resolveModuleNonCodeReferences(msg, controllerName, moduleTagName, stringToResolve);\n        \n        // Pull the next match\n        match = reCode.exec(stringToResolve);\n        \n        // Test if there was a match found or not.\n        if ((match === null) || (match === undefined)) {\n            // Nothing was found.  Quit searching.\n            doneSearching = true;\n        }\n        else {\n            // A match was found.\n            // Pull the match information\n            var wholeMatch = match[0];\n            var operator = match[1];\n            var operand = match[2];\n            \n            // Debug Messages\n            logVerboseMessage(localCallStackLevel, \"wholeMatch = \" + wholeMatch);\n            logVerboseMessage(localCallStackLevel, \"operator = \" + wholeMatch);\n            logVerboseMessage(localCallStackLevel, \"operand = \" + wholeMatch);\n            \n            // Perform find & replace based on the operator type\n            var replaceText = null;\n            switch(operator) {\n                case CodeKeyword:\n                    // Do a snippet lookup.\n                    // ***This loopup is limited in scope to the global permissives snippet set.***\n                    // ***Exclude all required snippets from the lookup to prevent circular references.***\n                    var global_PermissiveSnippets_Temp = null;\n                    var tempFilterArray = msg.payload.CDef_CodeSnippets.filter((element)=>{\n                        if ((element !== null) && (element !== undefined)){\n                            return ((element.ClassName == \"Global\") && \n                                (element.UsageScenario == \"Permissives\") && \n                                (element.SnippetName === operand) &&\n                                (element.SnippetName !== \"Main\") &&\n                                (element.SnippetName !== \"Branch\") &&\n                                (element.SnippetName !== \"BranchDelayed\") &&\n                                (element.SnippetName !== \"ConditionCodePlaceholder\"));\n                        }\n                    });\n                    \n                    // Test if the filtered list has anything in it\n                    if (tempFilterArray.length > 0) {\n                        global_PermissiveSnippets_Temp = tempFilterArray[0];\n                    }\n                    \n                    // Test if snippet was found\n                    if ((global_PermissiveSnippets_Temp !== null) && (global_PermissiveSnippets_Temp !== undefined)) {\n                        // Debug messages\n                        logVerboseMessage(localCallStackLevel, \">>>Found Code<<<\");\n                        \n                        // Snippet was found.  Use snippet code\n                        replaceText = global_PermissiveSnippets_Temp.Code;\n                    }\n                    break;\n                    \n                case DerivedKeyword:\n                    // Do a lookup of the derived calculations within this routine.\n                    // Pull the derived items dictionary from the local context\n                    var derivedItemsDictionary = context.get('derivedItemsDictionary');\n                    \n                    // Test if it exists\n                    if ((derivedItemsDictionary !== null) && (derivedItemsDictionary !== undefined)) {\n                        // Test if it has the requested item or not\n                        if (derivedItemsDictionary.hasOwnProperty(operand)) {\n                            // Debug messages\n                            logVerboseMessage(localCallStackLevel, \">>>Found Derived<<<\");\n                            \n                            // Derived item found in the dictionary.  Pull it to use.\n                            replaceText = derivedItemsDictionary[operand];\n                        }\n                    }\n                    break;\n            }\n            \n            // Test if there is a replacement string\n            if ((replaceText !== null) && (replaceText !== undefined)) {\n                // Debug messages\n                logVerboseMessage(localCallStackLevel, \"replaceText = \" + replaceText);\n                \n                // Perform the replacement\n                stringToResolve = stringToResolve.substring(0, match.index) + replaceText + stringToResolve.substring(reCode.lastIndex)\n                \n                // Start the RegExp's pointer to start scanning at the beginning of the last match\n                // This is done in case the replacement also contains matches that need replacing\n                reCode.lastIndex = match.index;\n            }\n        }\n        \n        // Increment the iterations count\n        iterations++;\n    }\n    \n    // Debug Messages\n    logVerboseMessage(localCallStackLevel,  \"<-- returnValue = (\" + stringToResolve + \")\");\n    \n    // Return the result\n    return stringToResolve;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 495,
    "y": 263.66666412353516,
    "wires": [
      [
        "60b0f619.c47488"
      ]
    ]
  },
  {
    "id": "60b0f619.c47488",
    "type": "join",
    "z": "55ffc120.e954e",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 855,
    "y": 203.66666412353516,
    "wires": [
      [
        "2cd2fcbb.fd8ef4"
      ]
    ]
  },
  {
    "id": "2cd2fcbb.fd8ef4",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Merge Custom Datasets",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Merge Custom Datasets\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*{\n    \"ModuleCodeSnippets\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"Snippets\":[{\n            \"SnippetName\":snippetName_i,\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }],\n    \"ModuleControllerTags\":[{\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    }]\n}*/\nvar returnDataSet_CodeSnippets = [];\nvar returnDataSet_Tags = [];\n\n/****************************************\n* Merge Incoming Custom Code Datasets   *\n*****************************************/\n// Setup the list of datasets of module snippet collections to merge\nvar payloadsToMerge = [\n    \"ModuleCodeSnippets_Interlocks\",\n    \"ModuleCodeSnippets_Permissives\"\n];\n\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Number of snippet datasets = \" + payloadsToMerge.length);\n\n//Iterate the list of datasets to merge\nfor (var i = 0; i < payloadsToMerge.length; i++){\n    // Cache a reference to the current dataset\n    var dataset_i = msg.payload[payloadsToMerge[i]];\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset = \" + payloadsToMerge[i] + \".\");\n    \n    // Iterate the modules in the current dataset\n    for (var j = 0; j < dataset_i.length; j++){\n        // Cache a reference to the current module\n        var module_i = dataset_i[j];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var moduleTagName_i = module_i.ModuleTagName;\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Item = \" + controller_i + \"-\" + moduleTagName_i + \".\");\n        \n        // Attempt to pull the module from the return dataset\n        var returnModule_i = null;\n        var matchingReturnModulesArray = returnDataSet_CodeSnippets.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return ((element.Controller == controller_i) &&\n                    (element.ModuleTagName == moduleTagName_i));\n            }\n        });\n        \n        // Test if the array is empty or not\n        if (matchingReturnModulesArray.length > 0) {\n            // Module already exists in the return set\n            // Pull it for modification\n            returnModule_i = matchingReturnModulesArray[0];\n        }\n        \n        // Test if the current module was found or not\n        if ((returnModule_i === null) || (returnModule_i === undefined)) {\n            // Module does not exist in the return set\n            // Create it & push it in\n            returnModule_i = {\n                \"Controller\":controller_i,\n                \"ModuleTagName\":moduleTagName_i,\n                \"Snippets\":[]\n            };\n            returnDataSet_CodeSnippets.push(returnModule_i);\n        }\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Incoming item's snippet count = \" + module_i.Snippets.length + \".\");\n        logDebugMessage(thisCallStackLevel, \"Return item's snippet count = \" + returnModule_i.Snippets.length + \".\");\n        \n        // Iterate the snippets in the current nodule\n        for (var k = 0; k < module_i.Snippets.length; k++){\n            // Cache a reference to the current snippet\n            var snippet_i = module_i.Snippets[k];\n            \n            // Pull the current snippets's data\n            var snippetName_i = snippet_i.SnippetName;\n            var code_i = snippet_i.Code;\n            var comment_i = snippet_i.Comment;\n            \n            // Attempt to pull the snippet from the return dataset\n            var matchingReturnSnippetsArray = returnModule_i.Snippets.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.SnippetName == snippetName_i);\n                }\n            });\n            \n            // Test if the array is empty or not\n            if (matchingReturnSnippetsArray.length > 0) {\n                // Snippet already exists in the return set\n                // Log a validation error\n                logValidationErrorMessage(thisCallStackLevel, controller_i + \"'s '\" + moduleTagName_i + \" cannot merge snippet \" + \n                    snippetName_i + \" because it is already in the merged dataset.\");\n            }\n            else {\n                // Snippet does not exist in the return set\n                // Create it & push it in\n                returnModule_i.Snippets.push({\n                    \"SnippetName\":snippetName_i,\n                    \"Code\":code_i,\n                    \"Comment\":comment_i\n                });\n            }\n        }\n    }\n}\n\n/****************************************\n* Merge Incoming Custom Tag Datasets    *\n*****************************************/\n// Setup the list of datasets of module snippet collections to merge\nvar payloadsToMerge = [\n    \"ModuleControllerTags_Interlocks\",\n    \"ModuleControllerTags_Permissives\"\n];\n\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Number of tag datasets = \" + payloadsToMerge.length);\n\n//Iterate the list of datasets to merge\nfor (var i = 0; i < payloadsToMerge.length; i++){\n    // Cache a reference to the current dataset\n    var dataset_i = msg.payload[payloadsToMerge[i]];\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset = \" + payloadsToMerge[i] + \".\");\n    \n    // Iterate the modules in the current dataset\n    for (var j = 0; j < dataset_i.length; j++){\n        // Cache a reference to the current module\n        var module_i = dataset_i[j];\n        \n        // Pull the current modules's data\n        var controller_i = module_i.Controller;\n        var tagName_i = module_i.TagName;\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Item = \" + controller_i + \"-\" + tagName_i + \".\");\n        \n        // Attempt to pull the module from the return dataset\n        var returnModule_i = null;\n        var matchingReturnModulesArray = returnDataSet_Tags.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return ((element.Controller == controller_i) &&\n                    (element.TagName == tagName_i));\n            }\n        });\n        \n        // Test if the array is empty or not\n        if (matchingReturnModulesArray.length > 0) {\n            // Module already exists in the return set\n            // Pull it for modification\n            returnModule_i = matchingReturnModulesArray[0];\n        }\n        \n        // Test if the current module was found or not\n        if ((returnModule_i === null) || (returnModule_i === undefined)) {\n            // Module does not exist in the return set\n            returnDataSet_Tags.push(module_i);\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload = {\n    \"ModuleCodeSnippets\": returnDataSet_CodeSnippets,\n    \"ModuleControllerTags\": returnDataSet_Tags\n};\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1105,
    "y": 203.66666412353516,
    "wires": [
      [
        "20354c8f.ba29c4"
      ]
    ]
  },
  {
    "id": "da9ae421.7e87a8",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Resolve Snippets to Commented Rungs",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getModuleResolvedMainCodeSegments = global.get(\"getModuleResolvedMainCodeSegments\");        //function (msg, controllerName, moduleTagName)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Resolve Snippets to Commented Rungs\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*{\n    \"ResolvedCodeSegments\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"ClassName\":module_i.ClassName,\n        \"Task\":module_i.Task,\n        \"Program\":module_i.Program,\n        \"Routine\":module_i.Routine,\n        \"ResolvedTask\":module_i.ResolvedTask,\n        \"ResolvedProgram\":module_i.ResolvedProgram,\n        \"ResolvedRoutine\":module_i.ResolvedRoutine,\n        \"ExecutionOrder\":module_i.ExecutionOrder,\n        \"CodeSegments\":[{\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\nvar returnDataSet = [];\n\n// Cache a reference to the relevant data sets that need to be used\nvar modulesList = msg.payload.Modules;\n\n// Iterate the tags in the Modules list dataset\nfor (var i = 0; i < modulesList.length; i++){\n    // Cache a reference to the current module's list data\n    var module_i = modulesList[i];\n    \n    // Cache off the common paramaters from the current module\n    var controller_i = module_i.Controller;\n    var moduleTagName_i = module_i.ModuleTagName;\n    \n    // Pull the resolved code segments (rungs) for thie current module\n    var resolvedCodeSegments_i = getModuleResolvedMainCodeSegments(msg, controller_i, moduleTagName_i);\n    \n    // Test if there was anything returned\n    if ((resolvedCodeSegments_i !== null) && (resolvedCodeSegments_i !== undefined)) {\n        // Module has code to deploy\n        // Create the base object for this module\n        var returnModule_i = {\n            \"Controller\":controller_i,\n            \"ModuleTagName\":moduleTagName_i,\n            \"ClassName\":module_i.ClassName,\n            \"Task\":module_i.Task,\n            \"Program\":module_i.Program,\n            \"Routine\":module_i.Routine,\n            \"ResolvedTask\":module_i.ResolvedTask,\n            \"ResolvedProgram\":module_i.ResolvedProgram,\n            \"ResolvedRoutine\":module_i.ResolvedRoutine,\n            \"ExecutionOrder\":module_i.ExecutionOrder,\n            \"CodeSegments\":[]\n        };\n        \n        // Iterate the tags in the Modules list dataset\n        for (var j = 0; j < resolvedCodeSegments_i.length; j++){\n            // Cache a reference to the current resolved code segment\n            var resolvedCodeSegment_i = resolvedCodeSegments_i[j];\n            \n            // Push the current code segment to the current module's return set.\n            returnModule_i.CodeSegments.push({\n                \"Code\":resolvedCodeSegment_i.Code,\n                \"Comment\":resolvedCodeSegment_i.Comment\n            });\n        }\n        \n        // Push the module to the return dataset\n        returnDataSet.push(returnModule_i);\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.  Number of resolved segments = \" + returnDataSet.length);\n\n// Return the result\nmsg.payload.ResolvedCodeSegments = returnDataSet;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1005,
    "y": 723.6666641235352,
    "wires": [
      [
        "90dca555.817ef8",
        "1c9acf76.960d01"
      ]
    ]
  },
  {
    "id": "6225f499.467d5c",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Get Controller Tags",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getModuleParameter = global.get(\"getModuleParameter\");                  //function (msg, controllerName, moduleTagName, parameterName)\nvar resolveModuleNonCodeReferences = global.get(\"resolveModuleNonCodeReferences\");      //function (msg, controllerName, moduleTagName, stringToResolve)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Controller Tags\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// This function's purpose is to iterate the module tag names in the modules list\n// and generate a collection of controller tags to create.\n/*{\n    \"ControllerTags\":[\n        \"Controller\":controller_i,\n        \"Scope\":scope_i,\n        \"TagName\":moduleTagName_i,\n        \"DataType\":dataType_i,\n        \"Description\":description_i,\n        \"Specifier\":specifier_i,\n        \"Attributes\":attributes_i\n    ]\n}*/\nvar returnDataSet = [];\n\n// Cache a reference to the relevant data sets that need to be used\nvar cDef_UsageScenarios = msg.payload.CDef_UsageScenarios_Pivoted;\nvar modulesList = msg.payload.Modules;\n\n// Test if there were any special tags created in upstream nodes or flows that are being passed into this node\nvar moduleControllerTags = msg.payload.ModuleControllerTags;\nif ((moduleControllerTags !== null) && (moduleControllerTags !== undefined)) {\n    // Special pre-generated tags exist.  Map them into the return data set.\n    returnDataSet = msg.payload.ModuleControllerTags.slice(0);\n}\n\n// Iterate the tags in the Modules list dataset\nfor (var i = 0; i < modulesList.length; i++){\n    // Cache a reference to the current module's list data\n    var module_i = modulesList[i];\n    \n    // Cache off the common paramaters from the current module\n    var controller_i = module_i.Controller;\n    var moduleTagName_i = module_i.ModuleTagName;\n    var moduleClassName_i = module_i.ClassName;\n    var moduleClassNameOverride_i = getModuleParameter(msg, controller_i, moduleTagName_i, \"ClassNameOverride\");    //function (msg, controllerName, moduleTagName, parameterName)\n    var usageScenario_i = module_i.UsageScenario;\n    var description_i = module_i.Description;\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Controller = \" + controller_i + \".\");\n    logDebugMessage(thisCallStackLevel, \"Module Tag Name = \" + moduleTagName_i + \".\");\n    logDebugMessage(thisCallStackLevel, \"Class Name = \" + moduleClassName_i + \".\");\n    logDebugMessage(thisCallStackLevel, \"Class Name Override = \" + moduleClassNameOverride_i + \".\");\n    logDebugMessage(thisCallStackLevel, \"Usage Scenario = \" + usageScenario_i + \".\");\n    \n    // If the module has a class name override column in the data table, then use as the class name for adding the base tag ONLY!!\n    // *** Subsequent logic relies on the main class name for pulling the usage scenario tags, etc ***\n    if (moduleClassNameOverride_i === undefined) {\n        // The module does NOT have a class name override specified (can be null or non-null)\n        // *** This is the typical scenario ***\n        \n        // Only add the tag for the module if the class name is exists and is non-null\n        if ((moduleClassName_i !== null) && (moduleClassName_i !== undefined)) {\n            // Add this module to the return dataset\n            returnDataSet.push({\n                \"Controller\": controller_i,\n                \"Scope\": \"\",\n                \"TagName\": moduleTagName_i,\n                \"DataType\": moduleClassName_i,\n                \"Description\": EscapeForRSLogix5000(description_i),\n                \"Specifier\": \"\",\n                \"Attributes\": GetAttributes(moduleClassName_i)\n            });\n            \n            // Debug messages\n            logDebugMessage(thisCallStackLevel, \"Added class tag to list (\" + moduleTagName_i + \")\");\n        }\n        \n        \n    }\n    else {\n        // The module does have a class name override specified (can be null or non-null)\n        // Only add the tag for the module if the class name is non-null\n        if (moduleClassNameOverride_i !== null) {\n            // Add this module to the return dataset\n            returnDataSet.push({\n                \"Controller\": controller_i,\n                \"Scope\": \"\",\n                \"TagName\": moduleTagName_i,\n                \"DataType\": moduleClassNameOverride_i,\n                \"Description\": EscapeForRSLogix5000(description_i),\n                \"Specifier\": \"\",\n                \"Attributes\": GetAttributes(moduleClassNameOverride_i)\n            });\n            \n            // Debug messages\n            logDebugMessage(thisCallStackLevel, \"Added class tag to list (\" + moduleTagName_i + \")\");\n        }\n    }\n    \n    // Attempt to pull the module's data table information\n    var cDef_Module_i = null;\n    var tempFilterArray = cDef_UsageScenarios.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.ClassName === moduleClassName_i);\n            }\n        });\n    \n    // Check is anything was returned\n    if(tempFilterArray.length > 0) {\n        // Module exists\n        // Cache a reference to the current module's master list row\n        cDef_Module_i = tempFilterArray[0];\n    }\n    \n    // Test if the class def exists or not\n    if ((cDef_Module_i !== null) && (cDef_Module_i !== undefined)){\n        // Class def exists.  Pull the current usage scenario\n        var cDef_ModuleUsageScenario_i = null;\n        var tempFilterArray = cDef_Module_i.UsageScenarios.filter((element)=>{\n                if ((element !== null) && (element !== undefined)){\n                    return (element.UsageScenarioName === usageScenario_i);\n                }\n            });\n        \n        // Check is anything was returned\n        if(tempFilterArray.length > 0) {\n            // Module exists\n            // Cache a reference to the current module's master list row\n            cDef_ModuleUsageScenario_i = tempFilterArray[0];\n        }\n        \n        // Test if the class def usage scenario exists or not\n        if ((cDef_ModuleUsageScenario_i !== null) && (cDef_ModuleUsageScenario_i !== undefined)){\n            // Class def exists.  Iterate\n            // Iterate parameters in the current module's current class def usage scenario\n            for (var j = 0; j < cDef_ModuleUsageScenario_i.Parameters.length; j++){\n                // Cache a reference to the current parameter\n                var cDef_Parameter_i = cDef_ModuleUsageScenario_i.Parameters[j];\n                \n                // If the parameter is flagged as needing a tag to be created.\n                if (cDef_Parameter_i.CreateTag) {\n                    // Tag need to be created.\n                    \n                    // Debug messages\n                    logDebugMessage(thisCallStackLevel, \"Preparing to add sidecar tag to list for \" + cDef_Parameter_i.ParameterName + \"\");\n                    \n                    // Add this module to the return dataset\n                    // Pull the tag name & tag description syntax & resolve all parameter references\n                    returnDataSet.push({\n                        \"Controller\": controller_i,\n                        \"Scope\": \"\",\n                        \"TagName\": resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, cDef_Parameter_i.TagName),\n                        \"DataType\": cDef_Parameter_i.DataType,\n                        \"Description\": EscapeForRSLogix5000(resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, cDef_Parameter_i.TagDescription)),\n                        \"Specifier\": \"\",\n                        \"Attributes\": GetAttributes(cDef_Parameter_i.DataType)\n                    });\n                    \n                    // Debug messages\n                    logDebugMessage(thisCallStackLevel, \"Added sidecar tag to list for \" + cDef_Parameter_i.ParameterName + \"\");\n                }\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nmsg.payload = {\n    \"ControllerTags\": returnDataSet,\n    \"DistinctControllers\": msg.payload.DistinctControllers\n};\nreturn msg;\n\n/****************************\n*                           *\n* Helper Functions Section  *\n*                           *\n*****************************/\nfunction GetAttributes(dataType) {\n    var returnValue = null;\n    \n    // Strip off array brackets\n    var dataTypeWithoutArray = null;\n    if ((dataType !== null) && (dataType !== undefined)) {\n        dataTypeWithoutArray = dataType.replace(/\\[(?:\\d|,)+\\]/img, \"\");\n    }\n    \n    // Return the Attributes based on the base data type\n    switch (dataTypeWithoutArray) {\n        case \"BOOL\":\n        case \"SINT\":\n        case \"INT\":\n        case \"DINT\":\n        case \"LINT\":\n            returnValue = \"(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n            \n        case \"REAL\":\n            returnValue = \"(RADIX := Float, Constant := false, ExternalAccess := Read/Write)\";\n            break;\n        \n        case \"MESSAGE\":\n            returnValue = \"(ExternalAccess := Read/Write, MessageType := Unconfigured, RequestedLength := 1, CommTypeCode := 0, LocalIndex := 0)\";\n            break;\n        \n        default:\n            returnValue = \"(Constant := false, ExternalAccess := Read/Write)\";\n            break;\n    }\n    return returnValue;\n}\n\nfunction EscapeForRSLogix5000(stringToEscape) {\n    var returnValue = stringToEscape;\n    /*\n    Find        Replace     Description    \n    $           $$          Dollar sign\n    '           $'          Single quote\n    \"           $Q          Double quote\n    \\r\\n        $N or $n    New line\n    \\r          $R or $r    Carriage return\n    \\n          $L or $l    Line feed\n    \\f          $P or $p    Form feed\n    \\t          $T or $t    Tab\n    xxxx        $xxxx       4-digit character code that represents a hexadecimal value\n    */\n    if ((returnValue !== null) && (returnValue !== undefined)) {\n        returnValue = returnValue.replace(new RegExp(\"'\", 'g'), \"$'\");        // Replace the escape marker first!\n        returnValue = returnValue.replace(new RegExp(\"\\\"\", 'g'), \"$Q\");\n        returnValue = returnValue.replace(new RegExp(\"\\r\\n\", 'g'), \"$N\");\n        returnValue = returnValue.replace(new RegExp(\"\\r\", 'g'), \"$R\");\n        returnValue = returnValue.replace(new RegExp(\"\\n\", 'g'), \"$L\");\n        returnValue = returnValue.replace(new RegExp(\"\\f\", 'g'), \"$P\");\n        returnValue = returnValue.replace(new RegExp(\"\\t\", 'g'), \"$T\");\n        // FUTURE: Add hexadecimal support\n    }\n    return returnValue;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 975,
    "y": 463.66666412353516,
    "wires": [
      [
        "c1c20b88.f7cfc8",
        "5c00ac36.e75ae4"
      ]
    ]
  },
  {
    "id": "c52d9588.fc8be8",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Controller Tags Next Index",
    "func": "// This function pulls the next unique item from the incoming DistinctControllers dataset\n//  to use to filter the incoming main dataset\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar now = global.get(\"now\");                                                //function ()\nvar formatDate = global.get(\"formatDate\");                                  //function (date, format, useUtc)\nvar replaceInvalidCharactersInFileName = global.get(\"replaceInvalidCharactersInFileName\");   //function (filename, replacementString)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Controller Tags Next Index\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Pass special values on for the renderer.\nmsg.tab = \"\\t\";\nmsg.carriageReturn = \"\\r\";\nmsg.lineFeed = \"\\n\";\nmsg.newLine = \"\\r\\n\";\nmsg.timestamp = formatDate(now(), \"ddd MMM dd HH:mm:ss yyyy\");  //Thu Nov 03 21:57:14 2016\n\n// Test if this is the first execution\n// Note:  Don't use ===.  msg.i === 0 fails to execute\nif (msg.i == 0) {\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Pulling the first index.\");\n    \n    // First execution.  Push the incoming payload to this node's context\n    context.originalPayload = msg.payload;\n}\n\n// Cache off the length to the message for the downstream switch node\nmsg.length = context.originalPayload.DistinctControllers.length;\n\n// Test if the index is still within the bounds of the array.\nif (msg.i < context.originalPayload.DistinctControllers.length) {\n    // There are still items to iterate.\n\nnode.log(\"Index = \" + msg.i + \"; Count = \" + msg.length);\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Index = \" + msg.i + \"; Count = \" + msg.length);\n    \n    // Cache a reference to the current distinct item\n    var distinctItem_i = context.originalPayload.DistinctControllers[msg.i];\n    \n    // Filter the original main dataset down to just the items matching the current distinct item.\n    var tempFilterArray = context.originalPayload.ControllerTags.filter((element)=>{\n            if ((element !== null) && (element !== undefined)){\n                return (element.Controller == distinctItem_i.Controller);\n            }\n        });\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Filtered list for controller (\" + distinctItem_i.Controller + \n        \") has \" + tempFilterArray.length + \" items.\");\n\n    // Set this node's status\n    node.log(\"Filtered list for controller (\" + distinctItem_i.Controller + \") has \" + tempFilterArray.length + \" items.\");\n    \n    // Set the return payload to an empty value\n    msg.payload = {\"ControllerTags\": tempFilterArray};\n\n    // Set the filename to use.\n    msg.filename = \"ControllerTags-\" + distinctItem_i.Controller + \".csv\";\n    \n    // Remove invalid filename characters\n    msg.filename = replaceInvalidCharactersInFileName(msg.filename, \"-\");\n    \n    // Set this node's status\n    setNodeStatus(node, \"blue\", \"dot\", msg.filename);\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Filename to use is(\" + msg.filename + \")\");\n}\nelse{\n    // There are no more items to iterate.\n    // Set this node's status\n    setNodeStatus(node, \"green\", \"dot\", \"Done\");\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Done iterating.\");\n    \n    // Set the return payload to an empty value.\n    msg.payload = null;\n    \n    // Set the filename to use.\n    msg.filename = null;\n}\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2065,
    "y": 463.66666412353516,
    "wires": [
      [
        "a2f9c4a2.303978",
        "2fd75541.7d6f3a"
      ]
    ]
  },
  {
    "id": "5c00ac36.e75ae4",
    "type": "template",
    "z": "55ffc120.e954e",
    "name": "i=0",
    "field": "i",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "0",
    "x": 1815,
    "y": 463.66666412353516,
    "wires": [
      [
        "c52d9588.fc8be8"
      ]
    ]
  },
  {
    "id": "a2f9c4a2.303978",
    "type": "switch",
    "z": "55ffc120.e954e",
    "name": "i<length",
    "property": "i",
    "propertyType": "msg",
    "rules": [
      {
        "t": "lt",
        "v": "length",
        "vt": "msg"
      },
      {
        "t": "else"
      }
    ],
    "checkall": "false",
    "outputs": 2,
    "x": 2325,
    "y": 463.66666412353516,
    "wires": [
      [
        "89848a24.972828"
      ],
      [
        "8255b818.7d7638"
      ]
    ]
  },
  {
    "id": "ba1ab74.d8cb048",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "i++",
    "func": "msg.i++;\nmsg.payload = null;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 2495,
    "y": 423.66666412353516,
    "wires": [
      [
        "c52d9588.fc8be8"
      ]
    ]
  },
  {
    "id": "8255b818.7d7638",
    "type": "template",
    "z": "55ffc120.e954e",
    "name": "Loop Finished",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "PLC Controller Tags Loop Finished",
    "x": 2525,
    "y": 543.6666641235352,
    "wires": [
      [
        "29bbbfa7.19982"
      ]
    ]
  },
  {
    "id": "20354c8f.ba29c4",
    "type": "join",
    "z": "55ffc120.e954e",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 375,
    "y": 383.66666412353516,
    "wires": [
      [
        "6225f499.467d5c",
        "da9ae421.7e87a8"
      ]
    ]
  },
  {
    "id": "89848a24.972828",
    "type": "template",
    "z": "55ffc120.e954e",
    "name": "Render Tags CSV",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "remark,\"CSV-Import-Export\"{{{carriageReturn}}}\nremark,\"Date = {{timestamp}}\"{{{carriageReturn}}}\nremark,\"Version = RSLogix 5000 v20.01\"{{{carriageReturn}}}\nremark,\"Owner = Avid\"{{{carriageReturn}}}\nremark,\"Company = Avid Solutions\"{{{carriageReturn}}}\n0.3{{{carriageReturn}}}\nTYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES{{{carriageReturn}}}\n{{#payload.ControllerTags}}\nTAG,{{{Scope}}},{{{TagName}}},\"{{{Description}}}\",\"{{{DataType}}}\",\"{{{Specifier}}}\",\"{{{Attributes}}}\"{{{carriageReturn}}}\n{{/payload.ControllerTags}}",
    "x": 2535,
    "y": 463.66666412353516,
    "wires": [
      [
        "90d3c654.d65f68",
        "e7f1b5fc.f89028"
      ]
    ]
  },
  {
    "id": "90d3c654.d65f68",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 2555,
    "y": 503.66666412353516,
    "wires": []
  },
  {
    "id": "f3f8832.7a9808",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Main Trigger",
    "info": "",
    "x": 110,
    "y": 180,
    "wires": []
  },
  {
    "id": "8feece29.d2481",
    "type": "inject",
    "z": "55ffc120.e954e",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 120,
    "y": 220,
    "wires": [
      [
        "22b75549.ffe93a"
      ]
    ]
  },
  {
    "id": "22b75549.ffe93a",
    "type": "link out",
    "z": "55ffc120.e954e",
    "name": "Debug: Main Flow Trigger",
    "links": [
      "675544fc.50165c",
      "5b6ecc0c.75e654"
    ],
    "x": 215,
    "y": 220,
    "wires": []
  },
  {
    "id": "2fd75541.7d6f3a",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 2115,
    "y": 523.6666641235352,
    "wires": []
  },
  {
    "id": "2398be1d.a62a32",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Upload File",
    "info": "",
    "x": 3095,
    "y": 423.66666412353516,
    "wires": []
  },
  {
    "id": "ad594c96.c6ec9",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Build Specialty Code",
    "info": "",
    "x": 415,
    "y": 163.66666412353516,
    "wires": []
  },
  {
    "id": "270d035c.74708c",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Merge Datasets",
    "info": "",
    "x": 1065,
    "y": 163.66666412353516,
    "wires": []
  },
  {
    "id": "8820e0f0.58db9",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Build Controller Tags JSON",
    "info": "",
    "x": 1005,
    "y": 423.66666412353516,
    "wires": []
  },
  {
    "id": "1cc62cae.8e13a3",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Build Controller Code JSON",
    "info": "",
    "x": 965,
    "y": 683.6666641235352,
    "wires": []
  },
  {
    "id": "63b6c420.edc5ac",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Iterate Controllers",
    "info": "",
    "x": 1855,
    "y": 423.66666412353516,
    "wires": []
  },
  {
    "id": "cc8778f9.01e1d8",
    "type": "template",
    "z": "55ffc120.e954e",
    "name": "i=0",
    "field": "i",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "0",
    "x": 895,
    "y": 943.6666641235352,
    "wires": [
      [
        "e4d237d9.6a9098"
      ]
    ]
  },
  {
    "id": "df248cd7.9a2b9",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Iterate Controllers",
    "info": "",
    "x": 935,
    "y": 903.6666641235352,
    "wires": []
  },
  {
    "id": "e4d237d9.6a9098",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Controller Code Next Index",
    "func": "// This function pulls the next unique item from the incoming DistinctResolvedPrograms, DistinctResolvedRoutines, or DistinctModules dataset\n//  to use to filter the incoming main dataset\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar now = global.get(\"now\");                                                //function ()\nvar formatDate = global.get(\"formatDate\");                                  //function (date, format, useUtc)\nvar replaceInvalidCharactersInFileName = global.get(\"replaceInvalidCharactersInFileName\");   //function (filename, replacementString)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Controller Code Next Index\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Pass special values on for the renderer.\nmsg.timestamp = formatDate(now(), \"ddd MMM dd HH:mm:ss yyyy\");  //Thu Nov 03 21:57:14 2016\n\n// Test if this is the first execution\n// Note:  Don't use ===.  msg.i === 0 fails to execute\nif (msg.i == 0) {\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Caching the original payload.\");\n    \n    // First execution.  Push the incoming message's payload to this node's context\n    context.originalPayload = msg.payload;\n}\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"L5X Format = \" + context.originalPayload.l5xFormat);\n\n// Cache off the length & L5X format to the message for the downstream switch node\nswitch (context.originalPayload.l5xFormat) {\n    case \"Rung\":\n        msg.length = context.originalPayload.DistinctModules.length;\n        msg.l5xFormat = context.originalPayload.l5xFormat;\n        break;\n    \n    case \"Routine\":\n        msg.length = context.originalPayload.DistinctResolvedRoutines.length;\n        msg.l5xFormat = context.originalPayload.l5xFormat;\n        break;\n    \n    case \"Program\":\n        msg.length = context.originalPayload.DistinctResolvedPrograms.length;\n        msg.l5xFormat = context.originalPayload.l5xFormat;\n        break;\n        \n    default:\n        // Use the program-level output as the default\n        msg.length = context.originalPayload.DistinctResolvedPrograms.length;\n        msg.l5xFormat = \"Program\";\n        break;\n}\n\n// Load the original payload back in in case the downsteam code needs to do reference resolving.\n// Default the resolved code segments to iterate and render as an empty array.\nmsg.payload = context.originalPayload;\nmsg.payload.ItemsToRender = [];\n\n// Test if the index is still within the bounds of the array.\nif (msg.i < msg.length) {\n    // There are still items to iterate.\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Index = \" + msg.i + \"; Count = \" + msg.length);\n    \n    // Filter the data and build the output filename based on the output format\n    switch (msg.l5xFormat) {\n        case \"Rung\":\n            // Cache a reference to the current distinct item\n            var distinctItem_i = context.originalPayload.DistinctModules[msg.i];\n            \n            // Filter the original main dataset down to just the items matching the current distinct item.\n            var tempFilterArray = context.originalPayload.ResolvedCodeSegments.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.Controller == distinctItem_i.Controller) &&\n                        (element.ModuleTagName == distinctItem_i.ModuleTagName);\n                    }\n                });\n            \n            // Debug Messages\n           logDebugMessage(thisCallStackLevel, \"Filtered list for module (\" + distinctItem_i.Controller + \n                \") & Module (\" + distinctItem_i.ModuleTagName + \") has \" + tempFilterArray.length + \" items.\");\n            \n            // Set the return payload\n            msg.payload.ItemsToRender = tempFilterArray;\n            \n            // Set the filename to use.\n            msg.filename = \"PlcCode-RungImport-\" + distinctItem_i.Controller + \"-\" + distinctItem_i.ModuleTagName + \".L5X\";\n            break;\n        \n        case \"Routine\":\n            // Cache a reference to the current distinct item\n            var distinctItem_i = context.originalPayload.DistinctResolvedRoutines[msg.i];\n            \n            // Filter the original main dataset down to just the items matching the current distinct item.\n            var tempFilterArray = context.originalPayload.ResolvedCodeSegments.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.Controller == distinctItem_i.Controller) &&\n                        (element.ResolvedTask == distinctItem_i.ResolvedTask) &&\n                        (element.ResolvedProgram == distinctItem_i.ResolvedProgram) && \n                        (element.ResolvedRoutine == distinctItem_i.ResolvedRoutine);\n                    }\n                });\n            \n            // Debug Messages\n           logDebugMessage(thisCallStackLevel, \"Filtered list for controller (\" + distinctItem_i.Controller + \n                \"), Task (\" + distinctItem_i.ResolvedTask + \"), Program (\" + distinctItem_i.ResolvedProgram + \n                \") & Routine (\" + distinctItem_i.ResolvedRoutine + \") has \" + tempFilterArray.length + \" items.\");\n            \n            // Set the return payload\n            msg.payload.ItemsToRender = tempFilterArray;\n            \n            // Set the filename to use.\n            msg.filename = \"PlcCode-RoutineImport-\" + distinctItem_i.Controller + \"-\" + distinctItem_i.ResolvedTask + \"-\" + \n                distinctItem_i.ResolvedProgram + \"-\" + distinctItem_i.ResolvedRoutine + \".L5X\";\n            break;\n        \n        case \"Program\":\n            // Cache a reference to the current distinct item\n            var distinctItem_i = context.originalPayload.DistinctResolvedPrograms[msg.i];\n            \n            // Filter the original main dataset down to just the items matching the current distinct item.\n            var tempFilterArray = context.originalPayload.ResolvedCodeSegments.filter((element)=>{\n                    if ((element !== null) && (element !== undefined)){\n                        return (element.Controller == distinctItem_i.Controller) &&\n                        (element.ResolvedTask == distinctItem_i.ResolvedTask) &&\n                        (element.ResolvedProgram == distinctItem_i.ResolvedProgram);\n                    }\n                });\n            \n            // Debug Messages\n           logDebugMessage(thisCallStackLevel, \"Filtered list for controller (\" + distinctItem_i.Controller + \n                \"), Task (\" + distinctItem_i.ResolvedTask + \"), & Program (\" + distinctItem_i.ResolvedProgram + \n                \") has \" + tempFilterArray.length + \" items.\");\n            \n            // Set the return payload\n            msg.payload.ItemsToRender = tempFilterArray;\n            \n            // Set the filename to use.\n            msg.filename = \"PlcCode-ProgramImport-\" + distinctItem_i.Controller + \"-\" + distinctItem_i.ResolvedTask + \"-\" + \n                distinctItem_i.ResolvedProgram + \".L5X\";\n            break;\n    }\n    \n    // Remove invalid filename characters\n    msg.filename = replaceInvalidCharactersInFileName(msg.filename, \"-\");\n    \n    // Set this node's status\n    setNodeStatus(node, \"blue\", \"dot\", msg.filename);\n    \n    // Debug Messages\n   logDebugMessage(thisCallStackLevel, \"Filename to use is(\" + msg.filename + \")\");\n}\nelse{\n    // There are no more items to iterate.\n    // Set this node's status\n    setNodeStatus(node, \"green\", \"dot\", \"Done\");\n    \n    // Debug Messages\n   logDebugMessage(thisCallStackLevel, \"Done iterating.\");\n    \n    // Set the return payload to an empty value.\n    msg.payload = null;\n    \n    // Set the filename to use.\n    msg.filename = null;\n}\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1145,
    "y": 943.6666641235352,
    "wires": [
      [
        "28da2934.011e06",
        "63f64dac.f69414"
      ]
    ]
  },
  {
    "id": "28da2934.011e06",
    "type": "switch",
    "z": "55ffc120.e954e",
    "name": "i<length",
    "property": "i",
    "propertyType": "msg",
    "rules": [
      {
        "t": "lt",
        "v": "length",
        "vt": "msg"
      },
      {
        "t": "else"
      }
    ],
    "checkall": "false",
    "outputs": 2,
    "x": 1405,
    "y": 943.6666641235352,
    "wires": [
      [
        "7182bd80.15aba4"
      ],
      [
        "55cc8f63.783e8"
      ]
    ]
  },
  {
    "id": "b3143a83.6fac48",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "i++",
    "func": "msg.i++;\nmsg.payload = null;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1935,
    "y": 863.6666641235352,
    "wires": [
      [
        "e4d237d9.6a9098"
      ]
    ]
  },
  {
    "id": "55cc8f63.783e8",
    "type": "template",
    "z": "55ffc120.e954e",
    "name": "Loop Finished",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "PLC Controller Code Loop Finished",
    "x": 1965,
    "y": 1203.6666641235352,
    "wires": [
      [
        "2793c641.560d3a",
        "34fdff49.ac28d"
      ]
    ]
  },
  {
    "id": "f13ca49c.64ecb8",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 2015,
    "y": 963.6666641235352,
    "wires": []
  },
  {
    "id": "63f64dac.f69414",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1195,
    "y": 1003.6666641235352,
    "wires": []
  },
  {
    "id": "1db2f94a.3bff57",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Render Program L5X",
    "func": "// Pull down the libraries from the global context\nvar xmldom = global.get(\"xmldom\");\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getRoutineResolvedCodeSegments = global.get(\"getRoutineResolvedCodeSegments\");      //function (msg, controllerName, taskName, programName, routineName, snippetName)\nvar resolveModuleNonCodeReferences = global.get(\"resolveModuleNonCodeReferences\");      //function (msg, controllerName, moduleTagName, stringToResolve)\nvar resolveRoutineNonCodeReferences = global.get(\"resolveRoutineNonCodeReferences\");      //function (msg, controllerName, taskName, programName, routineName, stringToResolve)\nvar getProgramParameter = global.get(\"getProgramParameter\");                //function (msg, controllerName, taskName, programName, parameterName)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Render Program L5X\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"blue\", \"dot\", \"Starting: \" + msg.filename);\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Build the document base for the Program-level L5X\nvar l5xBase = \n    \"<RSLogix5000Content SchemaRevision=\\\"1.0\\\" SoftwareRevision=\\\"16.03\\\" TargetName=\\\"TBD\\\" TargetType=\\\"Program\\\" ContainsContext=\\\"true\\\" Owner=\\\"Avid, Avid Solutions\\\" ExportDate=\\\"Sun Aug 23 22:45:10 2015\\\" ExportOptions=\\\"References DecoratedData Context RoutineLabels AliasExtras IOTags NoStringData ForceProtectedEncoding AllProjDocTrans\\\">\" + \n    \t\"<Controller Use=\\\"Context\\\" Name=\\\"TBD\\\">\" + \n    \t\t\"<Programs Use=\\\"Context\\\">\" + \n    \t\t\t\"<Program Use=\\\"Target\\\" Name=\\\"TBD\\\" TestEdits=\\\"false\\\" Disabled=\\\"false\\\">\" + \n    \t\t\t\t\"<Routines>\" + \n    \t\t\t\t\"</Routines>\" + \n    \t\t\t\"</Program>\" + \n    \t\t\"</Programs>\" + \n    \t\"</Controller>\" + \n    \"</RSLogix5000Content>\";\n\n// Pull common varaibles to inject into the output file\nvar schemaRevision = \"1.0\";\nvar softwareRevision = \"28.01\";\nvar owner = \"Avid, Avid Solutions\";\nvar exportDate = msg.timestamp;\n\n// Pull a reference to the first item to inject into the output file.\n// Use it to pull the base program structure information.\nvar firstItem = msg.payload.ItemsToRender[0];\n\n// Test if anythign was returned or not\nif ((firstItem === null) || (firstItem === undefined)) {\n    // Nothing to do.  Quit.\n    // Debug Messages\n    logErrorMessage(thisCallStackLevel, \"Aborting.  Nothing to output.\");\n    \n    // Set the payload to be empty\n    msg.payload = null;\n    \n    // Return result\n    return msg;\n}\nelse {\n    // Items to process.  Pull base program strucutre info.\n    var controller_i = firstItem.Controller;\n    var moduleTagName_i = firstItem.ModuleTagName;\n    var task_i = firstItem.Task;\n    var program_i = firstItem.Program;\n    var resolvedTask_i = firstItem.ResolvedTask;\n    var resolvedProgram_i = firstItem.ResolvedProgram;\n}\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"First Item's controller_i = \" + controller_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's moduleTagName_i = \" + moduleTagName_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's task_i = \" + task_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's program_i = \" + program_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedTask_i = \" + resolvedTask_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedProgram_i = \" + resolvedProgram_i);\n\n/*\n<RSLogix5000Content>\n    SchemaRevision=\"1.0\"\n    SoftwareRevision=\"16.03\"\n    TargetName=\"TBD\"\n    TargetType=\"Program\"        --> Doesn't need updating\n    Owner=\"Avid, Avid Solutions\"\n    ExportDate=\"Sun Aug 23 22:45:10 2015\"\n<Controller>\n    Name=\"TBD\"\n<Program>\n    Name=\"TBD\"\n    MainRoutineName=\"MainTBD\" \n    FaultRoutineName=\"FaultTBD\"\n*/\n// Parse the base XML into a document\nvar parser = new xmldom.DOMParser();\nvar xmlDoc = parser.parseFromString(l5xBase, \"text/xml\");\n\n// Pull a reference to the root element & modify the properties that need it\nvar rootElement = xmlDoc.documentElement;\nrootElement.setAttribute(\"SchemaRevision\", schemaRevision);\nrootElement.setAttribute(\"SoftwareRevision\", softwareRevision);\nrootElement.setAttribute(\"TargetName\", resolvedProgram_i);\nrootElement.setAttribute(\"Owner\", owner);\nrootElement.setAttribute(\"ExportDate\", exportDate);\n\n// Pull a reference to the Controller element & modify the properties that need it\nvar controllerElement = rootElement.getElementsByTagName(\"Controller\")[0];\ncontrollerElement.setAttribute(\"Name\", controller_i);\n\n// Pull a reference to the Program element & modify the properties that need it\nvar programElement = controllerElement.getElementsByTagName(\"Programs\")[0].getElementsByTagName(\"Program\")[0];\nprogramElement.setAttribute(\"Name\", resolvedProgram_i);\n\n// Pull a reference to the Routines element & modify the properties that need it\nvar routinesElement = programElement.getElementsByTagName(\"Routines\")[0];\n\n/************************************\n * Pull List of Routines to Build    *\n ************************************/\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Pulling list of routines to build.\");\n\n// Pull the list of distinct resolved routine names that belong to this program (controller-resolvedTask-resolvedProgram key)\nvar distinctRoutinesForThisProgram = msg.payload.DistinctResolvedRoutines.filter((element)=>{\n    if ((element !== null) && (element !== undefined)){\n        return ((element.Controller == controller_i) && \n            (element.ResolvedTask == resolvedTask_i) && \n            (element.ResolvedProgram == resolvedProgram_i));\n    }\n});\n\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Number of distinctRoutinesForThisProgram = \" + distinctRoutinesForThisProgram.length + \".\");\nlogDebugMessage(thisCallStackLevel, \"Sorting list of routines by execution order.\");\n\n// Sort list of unique routines by execution order\ndistinctRoutinesForThisProgram.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) ExecutionOrder (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if (isNaN(element1.ExecutionOrder) && !isNaN(element2.ExecutionOrder)) {return -1;}\n    else if (!isNaN(element1.ExecutionOrder) && isNaN(element2.ExecutionOrder)) {return +1;}\n    else if ((Number(element1.ExecutionOrder) < Number(element2.ExecutionOrder))) {return -1;}\n    else if ((Number(element1.ExecutionOrder) > Number(element2.ExecutionOrder))) {return +1;}\n    else {return 0;}\n});\n\n/***********************************\n* Build MainRoutine                *\n************************************/\n// Pull the configured Main Routine name\n// Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n//       This allows the user to back-reference module properties such as ModuleTagName and Description.\nvar mainRoutineName = resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, \n        getProgramParameter(msg, controller_i, resolvedTask_i, resolvedProgram_i, \"MainRoutine\")\n    )||\"\";\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"mainRoutineName = \" + mainRoutineName);\n\n// Test if there is a Main Routine specified\nif (mainRoutineName.trim().length > 0) {\n    // There is a main routine.  Add it to the L5X.\n    \n    // Set the XML attribute\n    programElement.setAttribute(\"MainRoutineName\", mainRoutineName);\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Rendering routine \" + mainRoutineName);\n    \n    /*\n    \"<Routine Name=\\\"TBD\\\" Type=\\\"RLL\\\">\" + \n\t    \"<RLLContent>\" + \n\t\t\"</RLLContent>\" + \n\t\"</Routine>\";\n    */\n    // Build an XML node, set its properties, and attach it to the routines node\n    var mainRoutineElement = xmlDoc.createElement(\"Routine\");\n    mainRoutineElement.setAttribute(\"Name\", mainRoutineName);\n    mainRoutineElement.setAttribute(\"Type\", \"RLL\");       //FUTURE: This will need to change this to support FBD & STL\n    routinesElement.appendChild(mainRoutineElement);\n    \n    // Build an XML node, set its properties, and attach it to the routine node\n    var mainRllContentElement = xmlDoc.createElement(\"RLLContent\");\n    mainRoutineElement.appendChild(mainRllContentElement);\n    \n    /***********************************\n    * Build Main Routine Header Rungs  *\n    ************************************/\n    //  Default the current rung count to 0\n    var mainRoutineRungCount = 0;\n    \n    // Default the collection of header rungs\n    var mainRoutineRungs = null;\n    \n    // Pull the rung(s) for this routine using the resolved names first\n    mainRoutineRungs = getRoutineResolvedCodeSegments(msg, controller_i, resolvedTask_i, resolvedProgram_i, mainRoutineName, \"Header\");\n    \n    // Test if anything was returned.  If nothing was returned, try pulling the rung(s) for this routine using the unresolved names\n    if ((mainRoutineRungs === null) || (mainRoutineRungs === undefined)) {\n        mainRoutineRungs = getRoutineResolvedCodeSegments(msg, controller_i, task_i, program_i, mainRoutineName, \"Header\");\n    }\n    \n    // Test if anything was returned.  If there are header rungs, build the XML for them\n    if ((mainRoutineRungs !== null) || (mainRoutineRungs !== undefined)) {\n        // There is a header rung(s) collection\n        for (var j = 0; j < mainRoutineRungs.length; j++) {\n            // Cache a reference to the current code segment\n            var codeSegment_i = mainRoutineRungs[j];\n            \n            // Build an XML node, set its properties, and attach it to the RLL content node\n            var rungElement = xmlDoc.createElement(\"Rung\");\n            rungElement.setAttribute(\"Number\", mainRoutineRungCount);\n            rungElement.setAttribute(\"Type\", \"N\");\n            mainRllContentElement.appendChild(rungElement);\n            \n            // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var commentElement = xmlDoc.createElement(\"Comment\");\n            commentElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Comment)\n                ));\n            rungElement.appendChild(commentElement);\n            \n            // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var codeElement = xmlDoc.createElement(\"Text\");\n            codeElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Code)\n                ));\n            rungElement.appendChild(codeElement);\n            \n            // Increment the rung count\n            mainRoutineRungCount++;\n        }\n    }\n    \n    /********************************************************************************************************************************************\n    * Note: The JSR rungs of the Main Routine will be built in the routine iteration section to be able to properly resolve the routine name!   *\n    ********************************************************************************************************************************************/\n}\n\n/***********************************\n* Build FaultRoutine               *\n************************************/\n// Pull the configured Main Routine name\n// Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n//       This allows the user to back-reference module properties such as ModuleTagName and Description.\nvar faultRoutineName = resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, \n        getProgramParameter(msg, controller_i, resolvedTask_i, resolvedProgram_i, \"FaultRoutine\")\n    )||\"\";\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"faultRoutineName = \" + faultRoutineName);\n\n// Test if there is a Main Routine specified\nif (faultRoutineName.trim().length > 0) {\n    // There is a fault routine.  Add it to the L5X.\n    \n    // Set the XML attribute\n    programElement.setAttribute(\"FaultRoutineName\", faultRoutineName);\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Rendering routine \" + faultRoutineName);\n    \n    /*\n    \"<Routine Name=\\\"TBD\\\" Type=\\\"RLL\\\">\" + \n\t    \"<RLLContent>\" + \n\t\t\"</RLLContent>\" + \n\t\"</Routine>\";\n    */\n    // Build an XML node, set its properties, and attach it to the routines node\n    var faultRoutineElement = xmlDoc.createElement(\"Routine\");\n    faultRoutineElement.setAttribute(\"Name\", faultRoutineName);\n    faultRoutineElement.setAttribute(\"Type\", \"RLL\");       //FUTURE: This will need to change this to support FBD & STL\n    routinesElement.appendChild(faultRoutineElement);\n    \n    // Build an XML node, set its properties, and attach it to the routine node\n    var faultRllContentElement = xmlDoc.createElement(\"RLLContent\");\n    faultRoutineElement.appendChild(faultRllContentElement);\n    \n    /***********************************\n    * Build Fault Routine Rungs        *\n    ************************************/\n    //  Default the current rung count to 0\n    var faultRoutineRungCount = 0;\n    \n    // Default the collection of header rungs\n    var faultRoutineRungs = null;\n    \n    // Pull the rung(s) for this routine using the resolved names first\n    faultRoutineRungs = getRoutineResolvedCodeSegments(msg, controller_i, resolvedTask_i, resolvedProgram_i, faultRoutineName, \"Main\");\n    \n    // Test if anything was returned.  If nothing was returned, try pulling the rung(s) for this routine using the unresolved names\n    if ((faultRoutineRungs === null) || (faultRoutineRungs === undefined)) {\n        faultRoutineRungs = getRoutineResolvedCodeSegments(msg, controller_i, task_i, program_i, faultRoutineName, \"Main\");\n    }\n    \n    // Test if anything was returned.  If there are header rungs, build the XML for them\n    if ((faultRoutineRungs !== null) || (faultRoutineRungs !== undefined)) {\n        // There is a header rung(s) collection\n        for (var j = 0; j < faultRoutineRungs.length; j++) {\n            // Cache a reference to the current code segment\n            var codeSegment_i = faultRoutineRungs[j];\n            \n            // Build an XML node, set its properties, and attach it to the RLL content node\n            var rungElement = xmlDoc.createElement(\"Rung\");\n            rungElement.setAttribute(\"Number\", faultRoutineRungCount);\n            rungElement.setAttribute(\"Type\", \"N\");\n            faultRllContentElement.appendChild(rungElement);\n            \n            // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var commentElement = xmlDoc.createElement(\"Comment\");\n            commentElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Comment)\n                ));\n            rungElement.appendChild(commentElement);\n            \n            // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var codeElement = xmlDoc.createElement(\"Text\");\n            codeElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Code)\n                ));\n            rungElement.appendChild(codeElement);\n            \n            // Increment the rung count\n            faultRoutineRungCount++;\n        }\n    }\n}\n\n/***********************************\n* Render List of Routines          *\n************************************/\n// Debug messages\nlogDebugMessage(thisCallStackLevel, \"Iterating list of routines by sort order.\");\n\n// Iterate unique routines\nfor (var i = 0; i < distinctRoutinesForThisProgram.length; i++) {\n    // Cache a reference to the current routine\n    distinctResolvedRoutines_i = distinctRoutinesForThisProgram[i];\n    \n    // Pull common variables\n    var resolvedRoutine_i = distinctResolvedRoutines_i.ResolvedRoutine;\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Rendering routine \" + resolvedRoutine_i);\n    logDebugMessage(thisCallStackLevel, \"resolvedRoutine_i = \" + resolvedRoutine_i);\n    \n    /***********************************\n    * Get Modules to Render            *\n    ************************************/\n    // Debug messages\n    logDebugMessage(thisCallStackLevel, \"Pulling list of modules to render.\");\n    \n    // Pull the list of modules to render that belong to this routine (controller-resolvedTask-resolvedProgram-resolvedRoutine key)\n    var modulesToRender = msg.payload.ItemsToRender.filter((element)=>{\n        if ((element !== null) && (element !== undefined)){\n            return ((element.Controller == controller_i) && \n                (element.ResolvedTask == resolvedTask_i) && \n                (element.ResolvedProgram == resolvedProgram_i) && \n                (element.ResolvedRoutine == resolvedRoutine_i));\n        }\n    });\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"modulesToRender.length = \" + modulesToRender.length);\n    \n    // Pull the first module in the list\n    // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n    //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n    var firstItem = modulesToRender[0];\n                        \n    // Test if anythign was returned or not\n    var moduleTagName_i = null;\n    if ((firstItem !== null) && (firstItem !== undefined)) {\n        // Items to process.  Pull module info.\n        var moduleTagName_i = firstItem.ModuleTagName;\n    }\n                        \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"moduleTagName_i = \" + moduleTagName_i);\n    \n    /***********************************\n    * Build Main Routine JSR Rungs     *\n    ************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Rendering JSR to routine \" + resolvedRoutine_i);\n    \n    // Pull the rung(s) for this routine using the resolved names first\n    mainRoutineRungs = getRoutineResolvedCodeSegments(msg, controller_i, resolvedTask_i, resolvedProgram_i, mainRoutineName, \"JSR\");\n    \n    // Test if anything was returned.  If nothing was returned, try pulling the rung(s) for this routine using the unresolved names\n    if ((mainRoutineRungs === null) || (mainRoutineRungs === undefined)) {\n        mainRoutineRungs = getRoutineResolvedCodeSegments(msg, controller_i, task_i, program_i, mainRoutineName, \"JSR\");\n    }\n    \n    // Test if anything was returned.  If there are header rungs, build the XML for them\n    if ((mainRoutineRungs !== null) || (mainRoutineRungs !== undefined)) {\n        // There is a header rung(s) collection\n        for (var j = 0; j < mainRoutineRungs.length; j++) {\n            // Cache a reference to the current code segment\n            var codeSegment_i = mainRoutineRungs[j];\n            \n            // Build an XML node, set its properties, and attach it to the RLL content node\n            var rungElement = xmlDoc.createElement(\"Rung\");\n            rungElement.setAttribute(\"Number\", mainRoutineRungCount);\n            rungElement.setAttribute(\"Type\", \"N\");\n            mainRllContentElement.appendChild(rungElement);\n            \n            // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n            // Attempt to resolve the text against the current routine first!  Then try against the first tag.\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var commentElement = xmlDoc.createElement(\"Comment\");\n            commentElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, \n                        resolveRoutineNonCodeReferences(msg, controller_i, resolvedTask_i, resolvedProgram_i, resolvedRoutine_i, codeSegment_i.Comment)\n                    )\n                ));\n            rungElement.appendChild(commentElement);\n            \n            // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var codeElement = xmlDoc.createElement(\"Text\");\n            codeElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, \n                        resolveRoutineNonCodeReferences(msg, controller_i, resolvedTask_i, resolvedProgram_i, resolvedRoutine_i, codeSegment_i.Code)\n                    )\n                ));\n            rungElement.appendChild(codeElement);\n            \n            // Increment the rung count\n            mainRoutineRungCount++;\n        }\n    }\n    \n    /************************************\n    * Build Routine XML Elements        *\n    ************************************/\n    /*\n    \"<Routine Name=\\\"TBD\\\" Type=\\\"RLL\\\">\" + \n\t    \"<RLLContent>\" + \n\t\t\"</RLLContent>\" + \n\t\"</Routine>\";\n    */\n    // Build an XML node, set its properties, and attach it to the routines node\n    var routineElement = xmlDoc.createElement(\"Routine\");\n    routineElement.setAttribute(\"Name\", resolvedRoutine_i);\n    routineElement.setAttribute(\"Type\", \"RLL\");       //FUTURE: This will need to change this to support FBD & STL\n    routinesElement.appendChild(routineElement);\n    \n    // Build an XML node, set its properties, and attach it to the routine node\n    var rllContentElement = xmlDoc.createElement(\"RLLContent\");\n    routineElement.appendChild(rllContentElement);\n    \n    /****************************************\n    * Build Header Rungs For This Routine   *\n    ****************************************/\n    //  Default the current rung count to 0\n    var rungCount = 0;\n    \n    // Default the collection of header rungs\n    var headerRungs = null;\n    \n    // Pull the header rung(s) for this routine using the resolved names first\n    headerRungs = getRoutineResolvedCodeSegments(msg, controller_i, resolvedTask_i, resolvedProgram_i, resolvedRoutine_i, \"Header\");\n    \n    // Test if anything was returned.  If nothing was returned, try pulling the header rung(s) for this routine using the unresolved names\n    if ((headerRungs === null) || (headerRungs === undefined)) {\n        headerRungs = getRoutineResolvedCodeSegments(msg, controller_i, task_i, program_i, routine_i, \"Header\");\n    }\n    \n    // Test if anything was returned.  If there are header rungs, build the XML for them\n    if ((headerRungs !== null) || (headerRungs !== undefined)) {\n        // There is a header rung(s) collection\n        for (var j = 0; j < headerRungs.length; j++) {\n            // Cache a reference to the current code segment\n            var codeSegment_i = headerRungs[j];\n            \n            // Build an XML node, set its properties, and attach it to the RLL content node\n            var rungElement = xmlDoc.createElement(\"Rung\");\n            rungElement.setAttribute(\"Number\", rungCount);\n            rungElement.setAttribute(\"Type\", \"N\");\n            rllContentElement.appendChild(rungElement);\n            \n            // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var commentElement = xmlDoc.createElement(\"Comment\");\n            commentElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Comment)\n                ));\n            rungElement.appendChild(commentElement);\n            \n            // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n            // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n            //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n            var codeElement = xmlDoc.createElement(\"Text\");\n            codeElement.appendChild(xmlDoc.createCDATASection(\n                    resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Code)\n                ));\n            rungElement.appendChild(codeElement);\n            \n            // Increment the rung count\n            rungCount++;\n        }\n    }\n    \n    /***********************************\n    * Build Module Rungs               *\n    ************************************/\n    // Iterate modules\n    // Note:  The modules are already sorted by execution order in a previous node.\n    for (var j = 0; j < modulesToRender.length; j++) {\n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"j = \" + j);\n        \n        // Cache a reference to the current module\n        var item_i = modulesToRender[j];\n        \n        // Pull common module values\n        moduleTagName_i = item_i.ModuleTagName;\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"moduleTagName_i = \" + moduleTagName_i);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"CodeSegments.length = \" + item_i.CodeSegments.length);\n        \n        // Iterate the module's resolved code segments\n        for (var k = 0; k < item_i.CodeSegments.length; k++) {\n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"k = \" + k);\n            \n            // Cache a reference to the current code segment\n            var codeSegment_i = item_i.CodeSegments[k];\n            \n            // Build an XML node, set its properties, and attach it to the RLL content node\n            var rungElement = xmlDoc.createElement(\"Rung\");\n            rungElement.setAttribute(\"Number\", rungCount);\n            rungElement.setAttribute(\"Type\", \"N\");\n            rllContentElement.appendChild(rungElement);\n            \n            // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n            var commentElement = xmlDoc.createElement(\"Comment\");\n            commentElement.appendChild(xmlDoc.createCDATASection(codeSegment_i.Comment));\n            rungElement.appendChild(commentElement);\n            \n            // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n            var codeElement = xmlDoc.createElement(\"Text\");\n            codeElement.appendChild(xmlDoc.createCDATASection(codeSegment_i.Code));\n            rungElement.appendChild(codeElement);\n            \n            // Increment the rung count\n            rungCount++;\n        }\n    }\n}\n\n// Convert XML document into a string\nvar serializer = new xmldom.XMLSerializer();\nmsg.payload = \n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\" + \n    serializer.serializeToString(xmlDoc.documentElement);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done: \" + msg.filename);\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1985,
    "y": 903.6666641235352,
    "wires": [
      [
        "f13ca49c.64ecb8",
        "cb73ff71.c3df5"
      ]
    ]
  },
  {
    "id": "29bbbfa7.19982",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "payload",
    "x": 2555,
    "y": 583.6666641235352,
    "wires": []
  },
  {
    "id": "2793c641.560d3a",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "payload",
    "x": 1995,
    "y": 1243.6666641235352,
    "wires": []
  },
  {
    "id": "90dca555.817ef8",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 955,
    "y": 783.6666641235352,
    "wires": []
  },
  {
    "id": "c1c20b88.f7cfc8",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 995,
    "y": 523.6666641235352,
    "wires": []
  },
  {
    "id": "117a0f3a.1dfd61",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Upload File",
    "info": "",
    "x": 2610,
    "y": 860,
    "wires": []
  },
  {
    "id": "6255b597.0fa85c",
    "type": "inject",
    "z": "55ffc120.e954e",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 1988,
    "y": 1379.6666412353516,
    "wires": [
      [
        "41a6bf9a.075e5"
      ]
    ]
  },
  {
    "id": "41a6bf9a.075e5",
    "type": "link out",
    "z": "55ffc120.e954e",
    "name": "Debug: Main Flow Trigger",
    "links": [
      "675544fc.50165c",
      "5b6ecc0c.75e654"
    ],
    "x": 2083,
    "y": 1379.6666412353516,
    "wires": []
  },
  {
    "id": "676dd8f2.bc64e8",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Main Trigger",
    "info": "",
    "x": 1978,
    "y": 1339.6666412353516,
    "wires": []
  },
  {
    "id": "b56ac326.b6e65",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Filter & Sort",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pre-sorting for Rendering Code\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*{\n    \"ResolvedCodeSegments\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"ClassName\":module_i.ClassName,\n        \"Task\":module_i.Task,\n        \"Program\":module_i.Program,\n        \"Routine\":module_i.Routine,\n        \"ExecutionOrder\":module_i.ExecutionOrder,\n        \"CodeSegments\":[{\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\n\n// Pre-sort msg.payload.ResolvedCodeSegments\nmsg.payload.ResolvedCodeSegments.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) Controller then\n    //  b) Task then\n    //  c) Program then\n    //  d) Routine then\n    //  e) ExecutionOrder (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if ((element1.Controller < element2.Controller)) {return -1;}\n    else if ((element1.Controller > element2.Controller)) {return +1;}\n    else if ((element1.ResolvedTask < element2.ResolvedTask)) {return -1;}\n    else if ((element1.ResolvedTask > element2.ResolvedTask)) {return +1;}\n    else if ((element1.ResolvedProgram < element2.ResolvedProgram)) {return -1;}\n    else if ((element1.ResolvedProgram > element2.ResolvedProgram)) {return +1;}\n    else if ((element1.ResolvedRoutine < element2.ResolvedRoutine)) {return -1;}\n    else if ((element1.ResolvedRoutine > element2.ResolvedRoutine)) {return +1;}\n    else if (isNaN(element1.ExecutionOrder) && !isNaN(element2.ExecutionOrder)) {return -1;}\n    else if (!isNaN(element1.ExecutionOrder) && isNaN(element2.ExecutionOrder)) {return +1;}\n    else if ((Number(element1.ExecutionOrder) < Number(element2.ExecutionOrder))) {return -1;}\n    else if ((Number(element1.ExecutionOrder) > Number(element2.ExecutionOrder))) {return +1;}\n    else {return 0;}\n});\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1555,
    "y": 723.6666641235352,
    "wires": [
      [
        "cc8778f9.01e1d8"
      ]
    ]
  },
  {
    "id": "46bfc7f1.180bc8",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Filter Then Sort Data By Execution Order",
    "info": "",
    "x": 1645,
    "y": 683.6666641235352,
    "wires": []
  },
  {
    "id": "34fdff49.ac28d",
    "type": "link out",
    "z": "55ffc120.e954e",
    "name": "Pull Logged Messages Trigger",
    "links": [
      "964722e6.6e518"
    ],
    "x": 2160,
    "y": 1203.6666641235352,
    "wires": []
  },
  {
    "id": "e006841d.7d47f8",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Make Last Node Pull Log Messages",
    "info": "",
    "x": 2285,
    "y": 1163.6666641235352,
    "wires": []
  },
  {
    "id": "4052ed50.602cb4",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "*** Still has 1 helper function to migrate ***",
    "info": "",
    "x": 1045,
    "y": 383.66666412353516,
    "wires": []
  },
  {
    "id": "1c9acf76.960d01",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Get UI Options",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Retrieving UI Options for Rendering Code\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Determine which output format to use\n// Valid Options:\n//      1) Program\n//      2) Routine\n//      3) Rung\n\n// Pull the L5X output option from the global context.\n// This should have been set by the user via the UI.\n//FUTURE: Remove this hardcoded value.  This is for testing only.\nmsg.payload.l5xFormat = \"Program\";    \n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1325,
    "y": 723.6666641235352,
    "wires": [
      [
        "b56ac326.b6e65"
      ]
    ]
  },
  {
    "id": "20f0c976.932506",
    "type": "inject",
    "z": "55ffc120.e954e",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 1988,
    "y": 1419.6666412353516,
    "wires": [
      [
        "e287bac2.855bf8"
      ]
    ]
  },
  {
    "id": "e287bac2.855bf8",
    "type": "link out",
    "z": "55ffc120.e954e",
    "name": "Debug: Pull Log Messages",
    "links": [
      "dec8cf72.04cdc",
      "7d617be9.22d264",
      "964722e6.6e518"
    ],
    "x": 2083,
    "y": 1419.6666412353516,
    "wires": []
  },
  {
    "id": "556c0552.9ae3fc",
    "type": "inject",
    "z": "55ffc120.e954e",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 120,
    "y": 260,
    "wires": [
      [
        "168c9f44.d9e911"
      ]
    ]
  },
  {
    "id": "168c9f44.d9e911",
    "type": "link out",
    "z": "55ffc120.e954e",
    "name": "Debug: Pull Log Messages",
    "links": [
      "dec8cf72.04cdc",
      "7d617be9.22d264",
      "964722e6.6e518"
    ],
    "x": 215,
    "y": 260,
    "wires": []
  },
  {
    "id": "8c5e9e9a.d704d",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Queue for Downsteam Operation",
    "info": "",
    "x": 2295,
    "y": 863.6666641235352,
    "wires": []
  },
  {
    "id": "cb73ff71.c3df5",
    "type": "delay",
    "z": "55ffc120.e954e",
    "name": "",
    "pauseType": "timed",
    "timeout": "5",
    "timeoutUnits": "milliseconds",
    "rate": "1",
    "nbRateUnits": "1",
    "rateUnits": "second",
    "randomFirst": "1",
    "randomLast": "5",
    "randomUnits": "seconds",
    "drop": false,
    "x": 2313,
    "y": 901.6666870117188,
    "wires": [
      [
        "b3143a83.6fac48",
        "8a2d8016.aaf89"
      ]
    ]
  },
  {
    "id": "b4208522.ab0118",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Queue for Downsteam Operation",
    "info": "",
    "x": 2855,
    "y": 423.66666412353516,
    "wires": []
  },
  {
    "id": "e7f1b5fc.f89028",
    "type": "delay",
    "z": "55ffc120.e954e",
    "name": "",
    "pauseType": "timed",
    "timeout": "5",
    "timeoutUnits": "milliseconds",
    "rate": "1",
    "nbRateUnits": "1",
    "rateUnits": "second",
    "randomFirst": "1",
    "randomLast": "5",
    "randomUnits": "seconds",
    "drop": false,
    "x": 2825,
    "y": 463.66666412353516,
    "wires": [
      [
        "ba1ab74.d8cb048",
        "cc1a61ec.b5fab",
        "9703302b.1f5a5"
      ]
    ]
  },
  {
    "id": "7182bd80.15aba4",
    "type": "switch",
    "z": "55ffc120.e954e",
    "name": "Choose Format Renderer",
    "property": "l5xFormat",
    "propertyType": "msg",
    "rules": [
      {
        "t": "eq",
        "v": "Program",
        "vt": "str"
      },
      {
        "t": "eq",
        "v": "Routine",
        "vt": "str"
      },
      {
        "t": "eq",
        "v": "Rung",
        "vt": "str"
      },
      {
        "t": "else"
      }
    ],
    "checkall": "true",
    "outputs": 4,
    "x": 1635,
    "y": 943.6666641235352,
    "wires": [
      [
        "1db2f94a.3bff57"
      ],
      [
        "bfd51fa6.6ec9d"
      ],
      [
        "8ae11178.ef0f6"
      ],
      [
        "b3143a83.6fac48"
      ]
    ]
  },
  {
    "id": "bfd51fa6.6ec9d",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Render Routine L5X",
    "func": "// Pull down the libraries from the global context\nvar xmldom = global.get(\"xmldom\");\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getRoutineResolvedCodeSegments = global.get(\"getRoutineResolvedCodeSegments\");      //function (msg, controllerName, taskName, programName, routineName, snippetName)\nvar resolveModuleNonCodeReferences = global.get(\"resolveModuleNonCodeReferences\");      //function (msg, controllerName, moduleTagName, stringToResolve)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Render Routine L5X\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"blue\", \"dot\", \"Starting: \" + msg.filename);\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Build the document base for the Routine-level L5X\nvar l5xBase = \n    \"<RSLogix5000Content SchemaRevision=\\\"1.0\\\" SoftwareRevision=\\\"16.03\\\" TargetName=\\\"TBD\\\" TargetType=\\\"Routine\\\" TargetSubType=\\\"RLL\\\" ContainsContext=\\\"true\\\" Owner=\\\"Avid, Avid Solutions\\\" ExportDate=\\\"Tue Aug 18 14:30:45 2015\\\" ExportOptions=\\\"References DecoratedData Context Dependencies ForceProtectedEncoding AllProjDocTrans\\\">\" + \n        \"<Controller Use=\\\"Context\\\" Name=\\\"TBD\\\">\" + \n        \t\"<Programs Use=\\\"Context\\\">\" + \n        \t\t\"<Program Use=\\\"Context\\\" Name=\\\"TBD\\\">\" + \n        \t\t\t\"<Routines Use=\\\"Context\\\">\" + \n        \t\t\t\t\"<Routine Use=\\\"Target\\\" Name=\\\"TBD\\\" Type=\\\"RLL\\\">\" + \n        \t\t\t\t    \"<RLLContent>\" + \n    \t\t\t\t\t\t\"</RLLContent>\" + \n        \t\t\t\t\"</Routine>\" + \n        \t\t\t\"</Routines>\" + \n        \t\t\"</Program>\" + \n        \t\"</Programs>\" + \n        \"</Controller>\" + \n    \"</RSLogix5000Content>\";\n\n// Pull common varaibles to inject into the output file\nvar schemaRevision = \"1.0\";\nvar softwareRevision = \"16.03\";\nvar owner = \"Avid, Avid Solutions\";\nvar exportDate = msg.timestamp;\n\n// Pull a reference to the first item to inject into the output file.\n// Use it to pull the base program structure information.\nvar firstItem = msg.payload.ItemsToRender[0];\n\n// Test if anythign was returned or not\nif ((firstItem === null) || (firstItem === undefined)) {\n    // Nothing to do.  Quit.\n    // Debug Messages\n    logErrorMessage(thisCallStackLevel, \"Aborting.  Nothing to output.\");\n    \n    // Set the payload to be empty\n    msg.payload = null;\n    \n    // Return result\n    return msg;\n}\nelse {\n    // Items to process.  Pull base program strucutre info.\n    var controller_i = firstItem.Controller;\n    var moduleTagName_i = firstItem.ModuleTagName;\n    var task_i = firstItem.Task;\n    var program_i = firstItem.Program;\n    var routine_i = firstItem.Routine;\n    var resolvedTask_i = firstItem.ResolvedTask;\n    var resolvedProgram_i = firstItem.ResolvedProgram;\n    var resolvedRoutine_i = firstItem.ResolvedRoutine;\n}\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"First Item's controller_i = \" + controller_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's moduleTagName_i = \" + moduleTagName_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's task_i = \" + task_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's program_i = \" + program_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedTask_i = \" + resolvedTask_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedProgram_i = \" + resolvedProgram_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedProgram_i = \" + resolvedRoutine_i);\n\n/*\n<RSLogix5000Content>\n    SchemaRevision=\"1.0\"\n    SoftwareRevision=\"16.03\"\n    TargetName=\"TBD\"\n    TargetType=\"Routine\"        --> Doesn't need updating\n    TargetSubType=\"RLL\"         --> FUTURE: This will need to change this to support FBD & STL\n    Owner=\"Avid, Avid Solutions\"\n    ExportDate=\"Sun Aug 23 22:45:10 2015\"\n<Controller>\n    Name=\"TBD\"\n<Program>\n    Name=\"TBD\"\n<Routine>\n\tName=\"TBD\"\n\tType=\"RLL\"\n*/\n// Parse the base XML into a document\nvar parser = new xmldom.DOMParser();\nvar xmlDoc = parser.parseFromString(l5xBase, \"text/xml\");\n\n// Pull a reference to the root element & modify the properties that need it\nvar rootElement = xmlDoc.documentElement;\nrootElement.setAttribute(\"SchemaRevision\", schemaRevision);\nrootElement.setAttribute(\"SoftwareRevision\", softwareRevision);\nrootElement.setAttribute(\"TargetName\", resolvedRoutine_i);\nrootElement.setAttribute(\"Owner\", owner);\nrootElement.setAttribute(\"ExportDate\", exportDate);\n\n// Pull a reference to the Controller element & modify the properties that need it\nvar controllerElement = rootElement.getElementsByTagName(\"Controller\")[0];\ncontrollerElement.setAttribute(\"Name\", controller_i);\n\n// Pull a reference to the Program element & modify the properties that need it\nvar programElement = controllerElement.getElementsByTagName(\"Programs\")[0].getElementsByTagName(\"Program\")[0];\nprogramElement.setAttribute(\"Name\", resolvedProgram_i);\n\n// Pull a reference to the Routine element & modify the properties that need it\nvar routineElement = programElement.getElementsByTagName(\"Routines\")[0].getElementsByTagName(\"Routine\")[0];\nroutineElement.setAttribute(\"Name\", resolvedRoutine_i);\n//routineElement.setAttribute(\"Type\", routineType_i);       //FUTURE: This will need to change this to support FBD & STL\n\n// Pull a reference to the RLLContent element & modify the properties that need it\nvar rllContentElement = routineElement.getElementsByTagName(\"RLLContent\")[0];\n\n/*{\n    \"ItemsToRender\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"ClassName\":module_i.ClassName,\n        \"Task\":module_i.Task,\n        \"Program\":module_i.Program,\n        \"Routine\":module_i.Routine,\n        \"ResolvedTask\":module_i.ResolvedTask,\n        \"ResolvedProgram\":module_i.ResolvedProgram,\n        \"ResolvedRoutine\":module_i.ResolvedRoutine,\n        \"ExecutionOrder\":module_i.ExecutionOrder,\n        \"CodeSegments\":[{\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\n//  Default the current rung count to 0\nvar rungCount = 0;\n\n// Default the collection of header rungs\nvar headerRungs = null;\n\n// Pull the header rung(s) for this routine using the resolved names first\nheaderRungs = getRoutineResolvedCodeSegments(msg, controller_i, resolvedTask_i, resolvedProgram_i, resolvedRoutine_i, \"Header\");\n\n// Test if anything was returned.  If nothing was returned, try pulling the header rung(s) for this routine using the unresolved names\nif ((headerRungs === null) || (headerRungs === undefined)) {\n    headerRungs = getRoutineResolvedCodeSegments(msg, controller_i, task_i, program_i, routine_i, \"Header\");\n}\n\n// Test if anything was returned.  If there are header rungs, build the XML for them\nif ((headerRungs !== null) || (headerRungs !== undefined)) {\n    // There is a header rung(s) collection\n    for (var i = 0; i < headerRungs.length; i++) {\n        // Cache a reference to the current code segment\n        var codeSegment_i = headerRungs[i];\n        \n        // Build an XML node, set its properties, and attach it to the RLL content node\n        var rungElement = xmlDoc.createElement(\"Rung\");\n        rungElement.setAttribute(\"Number\", rungCount);\n        rungElement.setAttribute(\"Type\", \"N\");\n        rllContentElement.appendChild(rungElement);\n        \n        // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n        // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n        //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n        var commentElement = xmlDoc.createElement(\"Comment\");\n        commentElement.appendChild(xmlDoc.createCDATASection(\n                resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Comment)\n            ));\n        rungElement.appendChild(commentElement);\n        \n        // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n        // Note: The returned text is resolved against the first module in the list to allow for the case of 1 routine per module.\n        //       This allows the user to back-reference module properties such as ModuleTagName and Description.\n        var codeElement = xmlDoc.createElement(\"Text\");\n        codeElement.appendChild(xmlDoc.createCDATASection(\n                resolveModuleNonCodeReferences(msg, controller_i, moduleTagName_i, codeSegment_i.Code)\n            ));\n        rungElement.appendChild(codeElement);\n        \n        // Increment the rung count\n        rungCount++;\n    }\n}\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"ItemsToRender.length = \" + msg.payload.ItemsToRender.length);\n\n// Iterate modules\n// Note:  The modules are already sorted by execution order in a previous node.\nfor (var i = 0; i < msg.payload.ItemsToRender.length; i++) {\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"i = \" + i);\n    \n    // Cache a reference to the current module\n    var item_i = msg.payload.ItemsToRender[i];\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"CodeSegments.length = \" + item_i.CodeSegments.length);\n    \n    // Iterate the module's resolved code segments\n    for (var j = 0; j < item_i.CodeSegments.length; j++) {\n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"j = \" + j);\n        \n        // Cache a reference to the current code segment\n        var codeSegment_i = item_i.CodeSegments[j];\n        \n        // Build an XML node, set its properties, and attach it to the RLL content node\n        var rungElement = xmlDoc.createElement(\"Rung\");\n        rungElement.setAttribute(\"Number\", rungCount);\n        rungElement.setAttribute(\"Type\", \"N\");\n        rllContentElement.appendChild(rungElement);\n        \n        // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n        var commentElement = xmlDoc.createElement(\"Comment\");\n        commentElement.appendChild(xmlDoc.createCDATASection(codeSegment_i.Comment));\n        rungElement.appendChild(commentElement);\n        \n        // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n        var codeElement = xmlDoc.createElement(\"Text\");\n        codeElement.appendChild(xmlDoc.createCDATASection(codeSegment_i.Code));\n        rungElement.appendChild(codeElement);\n        \n        // Increment the rung count\n        rungCount++;\n    }\n}\n\n// Convert XML document into a string\nvar serializer = new xmldom.XMLSerializer();\nmsg.payload = \n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\" + \n    serializer.serializeToString(xmlDoc.documentElement);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done: \" + msg.filename);\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1985,
    "y": 1003.6666641235352,
    "wires": [
      [
        "d58db79.4d8cc48",
        "cb73ff71.c3df5"
      ]
    ]
  },
  {
    "id": "d58db79.4d8cc48",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 2015,
    "y": 1063.6666641235352,
    "wires": []
  },
  {
    "id": "8ae11178.ef0f6",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Render Rung L5X",
    "func": "// Pull down the libraries from the global context\nvar xmldom = global.get(\"xmldom\");\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Render Rung L5X\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"blue\", \"dot\", \"Starting: \" + msg.filename);\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Build the document base for the Rung-level L5X\nvar l5xBase = \n    \"<RSLogix5000Content SchemaRevision=\\\"1.0\\\" SoftwareRevision=\\\"16.03\\\" TargetType=\\\"Rung\\\" TargetCount=\\\"TBD\\\" ContainsContext=\\\"true\\\" Owner=\\\"Avid, Avid Solutions\\\" ExportDate=\\\"Sat Aug 15 12:10:03 2015\\\" ExportOptions=\\\"References DecoratedData Context RoutineLabels AliasExtras IOTags NoStringData ForceProtectedEncoding AllProjDocTrans\\\">\" + \n    \t\"<Controller Use=\\\"Context\\\" Name=\\\"TBD\\\">\" + \n    \t\t\"<Programs Use=\\\"Context\\\">\" + \n    \t\t\t\"<Program Use=\\\"Context\\\" Name=\\\"TBD\\\">\" + \n    \t\t\t\t\"<Routines Use=\\\"Context\\\">\" + \n    \t\t\t\t\t\"<Routine Use=\\\"Context\\\" Name=\\\"TBD\\\">\" + \n    \t\t\t\t\t\t\"<RLLContent Use=\\\"Context\\\">\" + \n    \t\t\t\t\t\t\"</RLLContent>\" + \n    \t\t\t\t\t\"</Routine>\" + \n    \t\t\t\t\"</Routines>\" + \n    \t\t\t\"</Program>\" + \n    \t\t\"</Programs>\" + \n    \t\"</Controller>\" + \n    \"</RSLogix5000Content>\";\n\n// Pull common varaibles to inject into the output file\nvar schemaRevision = \"1.0\";\nvar softwareRevision = \"16.03\";\nvar owner = \"Avid, Avid Solutions\";\nvar exportDate = msg.timestamp;\n\n// Pull a reference to the first item to inject into the output file.\n// Use it to pull the base program structure information.\nvar firstItem = msg.payload.ItemsToRender[0];\n\n// Test if anythign was returned or not\nif ((firstItem === null) || (firstItem === undefined)) {\n    // Nothing to do.  Quit.\n    // Debug Messages\n    logErrorMessage(thisCallStackLevel, \"Aborting.  Nothing to output.\");\n    \n    // Set the payload to be empty\n    msg.payload = null;\n    \n    // Return result\n    return msg;\n}\nelse {\n    // Items to process.  Pull base program strucutre info.\n    var controller_i = firstItem.Controller;\n    var task_i = firstItem.Task;\n    var program_i = firstItem.Program;\n    var routine_i = firstItem.Routine;\n    var resolvedTask_i = firstItem.ResolvedTask;\n    var resolvedProgram_i = firstItem.ResolvedProgram;\n    var resolvedRoutine_i = firstItem.ResolvedRoutine;\n}\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"First Item's controller_i = \" + controller_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's task_i = \" + task_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's program_i = \" + program_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedTask_i = \" + resolvedTask_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedProgram_i = \" + resolvedProgram_i);\nlogDebugMessage(thisCallStackLevel, \"First Item's resolvedProgram_i = \" + resolvedRoutine_i);\n/*\n<RSLogix5000Content>\n    SchemaRevision=\"1.0\"\n    SoftwareRevision=\"16.03\"\n    TargetType=\"Rung\"       --> Doesn't need updating\n    TargetCount=\"TBD\"       --> This must be set at the end!\n    Owner=\"Avid, Avid Solutions\"\n    ExportDate=\"Sun Aug 23 22:45:10 2015\"\n<Controller>\n    Name=\"TBD\"\n<Program>\n    Name=\"TBD\" \n<Routine>\n    Name=\"TBD\"\n*/\n// Parse the base XML into a document\nvar parser = new xmldom.DOMParser();\nvar xmlDoc = parser.parseFromString(l5xBase, \"text/xml\");\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"Setting properties in base XML.\");\n\n// Pull a reference to the root element & modify the properties that need it\nvar rootElement = xmlDoc.documentElement;\nrootElement.setAttribute(\"SchemaRevision\", schemaRevision);\nrootElement.setAttribute(\"SoftwareRevision\", softwareRevision);\nrootElement.setAttribute(\"Owner\", owner);\nrootElement.setAttribute(\"ExportDate\", exportDate);\n\n// Pull a reference to the Controller element & modify the properties that need it\nvar controllerElement = rootElement.getElementsByTagName(\"Controller\")[0];\ncontrollerElement.setAttribute(\"Name\", controller_i);\n\n// Pull a reference to the Program element & modify the properties that need it\nvar programElement = controllerElement.getElementsByTagName(\"Programs\")[0].getElementsByTagName(\"Program\")[0];\nprogramElement.setAttribute(\"Name\", resolvedProgram_i);\n\n// Pull a reference to the Routine element & modify the properties that need it\nvar routineElement = programElement.getElementsByTagName(\"Routines\")[0].getElementsByTagName(\"Routine\")[0];\nroutineElement.setAttribute(\"Name\", resolvedRoutine_i);\n\n// Pull a reference to the RLLContent element & modify the properties that need it\nvar rllContentElement = routineElement.getElementsByTagName(\"RLLContent\")[0];\n\n/*{\n    \"ItemsToRender\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"ClassName\":module_i.ClassName,\n        \"Task\":module_i.Task,\n        \"Program\":module_i.Program,\n        \"Routine\":module_i.Routine,\n        \"ResolvedTask\":module_i.ResolvedTask,\n        \"ResolvedProgram\":module_i.ResolvedProgram,\n        \"ResolvedRoutine\":module_i.ResolvedRoutine,\n        \"ExecutionOrder\":module_i.ExecutionOrder,\n        \"CodeSegments\":[{\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\n//  Default the current rung count to 0\nvar rungCount = 0;\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"ItemsToRender.length = \" + msg.payload.ItemsToRender.length);\n\n// Iterate modules\n// Note:  The modules are already sorted by execution order in a previous node.\nfor (var i = 0; i < msg.payload.ItemsToRender.length; i++) {\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"i = \" + i);\n    \n    // Cache a reference to the current module\n    var item_i = msg.payload.ItemsToRender[i];\n    \n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"CodeSegments.length = \" + item_i.CodeSegments.length);\n    \n    // Iterate the module's resolved code segments\n    for (var j = 0; j < item_i.CodeSegments.length; j++) {\n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"j = \" + j);\n        \n        // Cache a reference to the current code segment\n        var codeSegment_i = item_i.CodeSegments[j];\n        \n        // Build an XML node, set its properties, and attach it to the RLL content node\n        var rungElement = xmlDoc.createElement(\"Rung\");\n        rungElement.setAttribute(\"Use\", \"Target\");\n        rungElement.setAttribute(\"Number\", rungCount);\n        rungElement.setAttribute(\"Type\", \"N\");\n        rllContentElement.appendChild(rungElement);\n        \n        // Build the CDATA comment node, create and insert a CDATA section with the comment, and insert this node into the rung node\n        var commentElement = xmlDoc.createElement(\"Comment\");\n        commentElement.appendChild(xmlDoc.createCDATASection(codeSegment_i.Comment));\n        rungElement.appendChild(commentElement);\n        \n        // Build the CDATA code node, create and insert a CDATA section with the code, and insert this node into the rung node\n        var codeElement = xmlDoc.createElement(\"Text\");\n        codeElement.appendChild(xmlDoc.createCDATASection(codeSegment_i.Code));\n        rungElement.appendChild(codeElement);\n        \n        // Increment the rung count\n        rungCount++;\n    }\n}\n\n// Update rung count in the root element (TargetCount)\nrootElement.setAttribute(\"TargetCount\", rungCount);\n\n// Convert XML document into a string\nvar serializer = new xmldom.XMLSerializer();\nmsg.payload = \n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\" + \n    serializer.serializeToString(xmlDoc.documentElement);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done: \" + msg.filename);\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1975,
    "y": 1103.6666641235352,
    "wires": [
      [
        "28c07ccb.935714",
        "cb73ff71.c3df5"
      ]
    ]
  },
  {
    "id": "28c07ccb.935714",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 2015,
    "y": 1163.6666641235352,
    "wires": []
  },
  {
    "id": "885ab5cb.b3ca18",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Block Execution Until UI Action",
    "info": "",
    "x": 715,
    "y": 423.66666412353516,
    "wires": []
  },
  {
    "id": "72be43e2.34f13c",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Wait For UI Trigger",
    "func": "// This function provides a caching system for incoming normal messages and \n//  blocks downstream execution until a message with a valid UiTrigger property is set.\n// This is intended to act like a breakpoint in the code until a UI action is taken.\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Wait For UI Trigger: Controller Tags\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Test if this is the first execution\nif ((msg.UiTrigger === null) || (msg.UiTrigger === undefined)) {\n    // The incoming message is not a UI action.\n    // Push the incoming message to this node's context.\n    context.originalMessage = msg;\n    \n    // Set this node's status\n    setNodeStatus(node, \"yellow\", \"dot\", \"Payload Cached\");\n    \n    // Debug Messages\n    logInfoMessage(thisCallStackLevel, \"Caching the incoming message to the node's context\");\n    \n    // Return null to prevent downstream execution\n    return null;\n}\nelse {\n    // The incoming message is a UI action.\n    // Pull the cached message from this node's context and push it to the outgoing message.\n    msg = context.originalMessage;\n    \n    // Set this node's status\n    setNodeStatus(node, \"green\", \"dot\", \"UI Trigger Received\");\n    \n    // Debug Messages\n    logInfoMessage(thisCallStackLevel, \"Pulling cached message from the node's context\");\n    \n    // Return null to prevent downstream execution\n    return msg;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 675,
    "y": 463.66666412353516,
    "wires": [
      [
        "6225f499.467d5c"
      ]
    ]
  },
  {
    "id": "c9037642.625218",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Block Execution Until UI Action",
    "info": "",
    "x": 675,
    "y": 683.6666641235352,
    "wires": []
  },
  {
    "id": "8856fa5a.8af208",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Wait For UI Trigger",
    "func": "// This function provides a caching system for incoming normal messages and \n//  blocks downstream execution until a message with a valid UiTrigger property is set.\n// This is intended to act like a breakpoint in the code until a UI action is taken.\n\n// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Wait For UI Trigger: Controller Code\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Test if this is the first execution\nif ((msg.UiTrigger === null) || (msg.UiTrigger === undefined)) {\n    // The incoming message is not a UI action.\n    // Push the incoming message to this node's context.\n    context.originalMessage = msg;\n    \n    // Set this node's status\n    setNodeStatus(node, \"yellow\", \"dot\", \"Payload Cached\");\n    \n    // Debug Messages\n    logInfoMessage(thisCallStackLevel, \"Caching the incoming message to the node's context\");\n    \n    // Return null to prevent downstream execution\n    return null;\n}\nelse {\n    // The incoming message is a UI action.\n    // Pull the cached message from this node's context and push it to the outgoing message.\n    msg = context.originalMessage;\n    \n    // Set this node's status\n    setNodeStatus(node, \"green\", \"dot\", \"UI Trigger Received\");\n    \n    // Debug Messages\n    logInfoMessage(thisCallStackLevel, \"Pulling cached message from the node's context\");\n    \n    // Return null to prevent downstream execution\n    return msg;\n}",
    "outputs": 1,
    "noerr": 0,
    "x": 635,
    "y": 723.6666641235352,
    "wires": [
      [
        "da9ae421.7e87a8"
      ]
    ]
  },
  {
    "id": "edeeb14a.d6272",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Filter & Sort",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Pre-sorting for Rendering Code\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*{\n    \"ResolvedCodeSegments\":[{\n        \"Controller\":controller_i,\n        \"ModuleTagName\":moduleTagName_i,\n        \"ClassName\":module_i.ClassName,\n        \"Task\":module_i.Task,\n        \"Program\":module_i.Program,\n        \"Routine\":module_i.Routine,\n        \"ExecutionOrder\":module_i.ExecutionOrder,\n        \"CodeSegments\":[{\n            \"Code\":code_i,\n            \"Comment\":comment_i\n        }]\n    }]\n}*/\n\n// Pre-sort msg.payload.ResolvedCodeSegments\nmsg.payload.ResolvedCodeSegments.sort((element1, element2)=>{\n    // Returns:\n    //  -1 for element1 < element2\n    //   0 for element1 = element2\n    //  +1 for element1 > element2\n    //\n    // Order:\n    // 1) Undefined\n    // 2) Null\n    // 3) Valid items\n    //  a) Controller then\n    //  b) Task then\n    //  c) Program then\n    //  d) Routine then\n    //  e) ExecutionOrder (NaN then Numbers)\n    \n    if ((element1 === undefined) && (element2 !== undefined)) {return -1;}\n    else if ((element1 !== undefined) && (element2 === undefined)) {return +1;}\n    else if ((element1 === null) && (element2 !== null)) {return -1;}\n    else if ((element1 !== null) && (element2 === null)) {return +1;}\n    else if ((element1.Controller < element2.Controller)) {return -1;}\n    else if ((element1.Controller > element2.Controller)) {return +1;}\n    else if ((element1.ResolvedTask < element2.ResolvedTask)) {return -1;}\n    else if ((element1.ResolvedTask > element2.ResolvedTask)) {return +1;}\n    else if ((element1.ResolvedProgram < element2.ResolvedProgram)) {return -1;}\n    else if ((element1.ResolvedProgram > element2.ResolvedProgram)) {return +1;}\n    else if ((element1.ResolvedRoutine < element2.ResolvedRoutine)) {return -1;}\n    else if ((element1.ResolvedRoutine > element2.ResolvedRoutine)) {return +1;}\n    else if (isNaN(element1.ExecutionOrder) && !isNaN(element2.ExecutionOrder)) {return -1;}\n    else if (!isNaN(element1.ExecutionOrder) && isNaN(element2.ExecutionOrder)) {return +1;}\n    else if ((Number(element1.ExecutionOrder) < Number(element2.ExecutionOrder))) {return -1;}\n    else if ((Number(element1.ExecutionOrder) > Number(element2.ExecutionOrder))) {return +1;}\n    else {return 0;}\n});\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1555,
    "y": 423.66666412353516,
    "wires": [
      []
    ]
  },
  {
    "id": "213d3e88.73c522",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "Filter Then Sort Data By Execution Order",
    "info": "",
    "x": 1645,
    "y": 383.66666412353516,
    "wires": []
  },
  {
    "id": "1b4e8030.d5f57",
    "type": "function",
    "z": "55ffc120.e954e",
    "name": "Get UI Options",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Retrieving UI Options for Rendering Code\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Determine which output format to use\n// Valid Options:\n//      1) Program\n//      2) Routine\n//      3) Rung\n\n// Pull the L5X output option from the global context.\n// This should have been set by the user via the UI.\n//FUTURE: Remove this hardcoded value.  This is for testing only.\nmsg.payload.l5xFormat = \"Program\";    \n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 1325,
    "y": 423.66666412353516,
    "wires": [
      [
        "edeeb14a.d6272"
      ]
    ]
  },
  {
    "id": "906ded5e.1b1c6",
    "type": "comment",
    "z": "55ffc120.e954e",
    "name": "*** Still has helper functions to migrate ***",
    "info": "",
    "x": 475,
    "y": 323.66666412353516,
    "wires": []
  },
  {
    "id": "cc79c894.adc448",
    "type": "load_dataset",
    "z": "f0bcf6de.677618",
    "kind": "dataset",
    "docid": "365",
    "docname": "IO List",
    "version": "",
    "name": "IO List",
    "sheets": [
      {
        "sheetname": "IOList",
        "columns": [
          "Panel",
          "Controller",
          "Rack",
          "Slot",
          "Channel",
          "IOType",
          "ElectricalType",
          "IODescription",
          "InstrumentID",
          "InstrumentModelNumber",
          "FailState",
          "OffMessage",
          "OnMessage",
          "EUMin",
          "EUMax",
          "EU",
          "ControllerIODataType",
          "ControllerIOTagName",
          "P&ID",
          "Notes",
          "Rev",
          "WiringBlock",
          "TerminalSet",
          "Terminal#",
          "TerminalId"
        ]
      }
    ],
    "x": 210,
    "y": 60,
    "wires": [
      [
        "60e3675e.b96588"
      ]
    ]
  },
  {
    "id": "9b2da141.263f6",
    "type": "load_dataset",
    "z": "99c1c432.c1fc88",
    "kind": "dataset",
    "docid": "367",
    "docname": "Program Structure",
    "version": "",
    "name": "Program Structure",
    "sheets": [
      {
        "sheetname": "Tasks",
        "columns": [
          "Controller",
          "Task",
          "Description",
          "Type",
          "Period",
          "Priority",
          "Watchdog",
          "DisableAutoOutputProcessing"
        ]
      },
      {
        "sheetname": "Programs",
        "columns": [
          "Controller",
          "Task",
          "Program",
          "Description",
          "MainRoutine",
          "FaultRoutine",
          "ExecutionOrder"
        ]
      },
      {
        "sheetname": "Routines",
        "columns": [
          "Controller",
          "Task",
          "Program",
          "Routine",
          "Description",
          "Type",
          "ExecutionOrder",
          "Purpose",
          "",
          "RevisionHistory"
        ]
      },
      {
        "sheetname": "PDef_CodeSnippets",
        "columns": [
          "Program",
          "Routine",
          "SnippetName",
          "Code",
          "Comment"
        ]
      }
    ],
    "x": 250,
    "y": 60,
    "wires": [
      [
        "d235730a.41a26"
      ]
    ]
  },
  {
    "id": "5e9cf09b.e6687",
    "type": "load_dataset",
    "z": "1f8d1d0a.6392f3",
    "kind": "dataset",
    "docid": "366",
    "docname": "Module Data",
    "version": "",
    "name": "Module Data",
    "sheets": [
      {
        "sheetname": "Modules",
        "columns": [
          "Controller",
          "ModuleTagName",
          "ClassName",
          "Task",
          "Program",
          "Routine",
          "ExecutionOrder"
        ]
      },
      {
        "sheetname": "Interlocks",
        "columns": [
          "Controller",
          "ModuleTagName",
          "Index",
          "ConditionCode",
          "ConditionDescription",
          "IsDebounced",
          "DebounceTime",
          "OkayState",
          "IsBypassable",
          "CanNavigate",
          "AssociatedTag"
        ]
      },
      {
        "sheetname": "Permissives",
        "columns": [
          "Controller",
          "ModuleTagName",
          "Index",
          "ConditionCode",
          "ConditionDescription",
          "IsDebounced",
          "DebounceTime",
          "OkayState",
          "IsBypassable",
          "CanNavigate",
          "AssociatedTag"
        ]
      },
      {
        "sheetname": "ControllerBase",
        "columns": [
          "Controller",
          "ModuleTagName",
          "ControllerBaseScenario",
          "ClassNameOverride",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ]
      },
      {
        "sheetname": "TaskBase",
        "columns": [
          "Controller",
          "ModuleTagName",
          "TaskBaseScenario",
          "ClassNameOverride",
          "CodeOverride",
          "CommentOverride",
          "TaskName",
          "TaskMonTagName",
          "TaskMonInhibitedTagName",
          "IsPerTask",
          "IsGlobalDiag",
          "Description",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          ""
        ]
      },
      {
        "sheetname": "P_AIn",
        "columns": [
          "Controller",
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "HasChannelIO",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_FwdText",
          "Cfg_RevText",
          "Cfg_SpeedRefEU",
          "Cfg_SpeedRefRawMin",
          "Cfg_SpeedRefRawMax",
          "Cfg_SpeedRefEUMin",
          "Cfg_SpeedRefEUMax",
          "Cfg_SpeedFdbkEU",
          "Cfg_SpeedFdbkRawMin",
          "Cfg_SpeedFdbkRawMax",
          "Cfg_SpeedFdbkEUMin",
          "Cfg_SpeedFdbkEUMax",
          "Cfg_HasReverse",
          "Cfg_HasJog",
          "Cfg_AllowLocal",
          "Cfg_MinSpdRef",
          "Cfg_MaxSpdRef",
          "Cfg_MaxJogT",
          "Cfg_ResetPulseT",
          "Cfg_HasRunFdbk",
          "Cfg_UseRunFdbk",
          "Cfg_FailToStartT",
          "Cfg_FailToStopT",
          "Cfg_ShedOnFailToStart",
          "Cfg_ShedOnIOFault",
          "Cfg_InpDatalinkEU",
          "Cfg_InpDatalinkLabel",
          "Cfg_HasInpDatalink",
          "Cfg_InpDatalinkRawMin",
          "Cfg_InpDatalinkRawMax",
          "Cfg_InpDatalinkEUMin",
          "Cfg_InpDatalinkEUMax",
          "Cfg_OutDatalinkEU",
          "Cfg_OutDatalinkLabel",
          "Cfg_HasOutDatalink",
          "Cfg_OutDatalinkRawMin",
          "Cfg_OutDatalinkRawMax",
          "Cfg_OutDatalinkEUMin",
          "Cfg_OutDatalinkEUMax",
          "Cfg_OutDatalinkMin",
          "Cfg_OutDatalinkMax",
          "Cfg_SimRampT",
          "Cfg_SimScaleEU",
          "Cfg_SimScaleRaw",
          "Cfg_HasFwdPermObj",
          "Cfg_HasRevPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasResInhObj",
          "Cfg_HasRunTimeObj",
          "FailToStart.Cfg_Cond",
          "FailToStart.Cfg_Tag",
          "FailToStart.Cfg_Exists",
          "FailToStart.Cfg_ResetReqd",
          "FailToStart.Cfg_AckReqd",
          "FailToStart.Cfg_Severity",
          "FailToStart.Cfg_AllowShelve",
          "FailToStart.Cfg_AllowDisable",
          "FailToStart.Cfg_AlmMinOnT",
          "FailToStart.Cfg_MaxShelfT",
          "FailToStop.Cfg_Cond",
          "FailToStop.Cfg_Tag",
          "FailToStop.Cfg_Exists",
          "FailToStop.Cfg_ResetReqd",
          "FailToStop.Cfg_AckReqd",
          "FailToStop.Cfg_Severity",
          "FailToStop.Cfg_AllowShelve",
          "FailToStop.Cfg_AllowDisable",
          "FailToStop.Cfg_AlmMinOnT",
          "FailToStop.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "DriveFault.Cfg_Cond",
          "DriveFault.Cfg_Tag",
          "DriveFault.Cfg_Exists",
          "DriveFault.Cfg_ResetReqd",
          "DriveFault.Cfg_AckReqd",
          "DriveFault.Cfg_Severity",
          "DriveFault.Cfg_AllowShelve",
          "DriveFault.Cfg_AllowDisable",
          "DriveFault.Cfg_AlmMinOnT",
          "DriveFault.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_SetTrackOvrdHand",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperStopPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Cfg_SetTrack",
          "Cfg_OperKeep",
          "Cfg_ProgKeep",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_AInHART",
        "columns": [
          "Controller",
          "ModuleTagName",
          "Ref_ChanDataTagName",
          "Ref_DiagTableTagName",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_EU",
          "Cfg_InpRawMin",
          "Cfg_InpRawMax",
          "Cfg_PVEUMin",
          "Cfg_PVEUMax",
          "Cfg_HasHART",
          "Cfg_HasPV",
          "Cfg_PVLabel",
          "Cfg_PVEU",
          "Cfg_HasSV",
          "Cfg_SVLabel",
          "Cfg_SVEU",
          "Cfg_HasTV",
          "Cfg_TVLabel",
          "Cfg_TVEU",
          "Cfg_HasFV",
          "Cfg_FVLabel",
          "Cfg_FVEU",
          "Cfg_FiltTC",
          "Cfg_HiHiDB",
          "Cfg_HiDB",
          "Cfg_LoDB",
          "Cfg_LoLoDB",
          "Cfg_FailHiLim",
          "Cfg_FailLoLim",
          "Cfg_FailDB",
          "Cfg_NoSubstPV",
          "Cfg_HasHiHiAlm",
          "Cfg_HiHiResetReqd",
          "Cfg_HiHiAckReqd",
          "Cfg_HiHiSeverity",
          "Cfg_HiHiOnDly",
          "Cfg_HiHiOffDly",
          "Cfg_HiHiGateDly",
          "HiHiGate.Cfg_InpCond",
          "HiHiGate.Cfg_GateCond",
          "HiHi.Cfg_AllowShelve",
          "HiHi.Cfg_AllowDisable",
          "HiHi.Cfg_AlmMinOnT",
          "HiHi.Cfg_MaxShelfT",
          "HiHi.Cfg_Cond",
          "HiHi.Cfg_Tag",
          "Cfg_HasHiAlm",
          "Cfg_HiResetReqd",
          "Cfg_HiAckReqd",
          "Cfg_HiSeverity",
          "Cfg_HiOnDly",
          "Cfg_HiOffDly",
          "Cfg_HiGateDly",
          "HiGate.Cfg_InpCond",
          "HiGate.Cfg_GateCond",
          "Hi.Cfg_AllowShelve",
          "Hi.Cfg_AllowDisable",
          "Hi.Cfg_AlmMinOnT",
          "Hi.Cfg_MaxShelfT",
          "Hi.Cfg_Cond",
          "Hi.Cfg_Tag",
          "Cfg_HasLoAlm",
          "Cfg_LoResetReqd",
          "Cfg_LoAckReqd",
          "Cfg_LoSeverity",
          "Cfg_LoOnDly",
          "Cfg_LoOffDly",
          "Cfg_LoGateDly",
          "LoGate.Cfg_InpCond",
          "LoGate.Cfg_GateCond",
          "Lo.Cfg_AllowShelve",
          "Lo.Cfg_AllowDisable",
          "Lo.Cfg_AlmMinOnT",
          "Lo.Cfg_MaxShelfT",
          "Lo.Cfg_Cond",
          "Lo.Cfg_Tag",
          "Cfg_HasLoLoAlm",
          "Cfg_LoLoResetReqd",
          "Cfg_LoLoAckReqd",
          "Cfg_LoLoSeverity",
          "Cfg_LoLoOnDly",
          "Cfg_LoLoOffDly",
          "Cfg_LoLoGateDly",
          "LoLoGate.Cfg_InpCond",
          "LoLoGate.Cfg_GateCond",
          "LoLo.Cfg_AllowShelve",
          "LoLo.Cfg_AllowDisable",
          "LoLo.Cfg_AlmMinOnT",
          "LoLo.Cfg_MaxShelfT",
          "LoLo.Cfg_Cond",
          "LoLo.Cfg_Tag",
          "Cfg_HasFailAlm",
          "Cfg_FailResetReqd",
          "Cfg_FailAckReqd",
          "Cfg_FailSeverity",
          "Cfg_FailOnDly",
          "Cfg_FailOffDly",
          "Cfg_FailGateDly",
          "FailGate.Cfg_InpCond",
          "FailGate.Cfg_GateCond",
          "Fail.Cfg_AllowShelve",
          "Fail.Cfg_AllowDisable",
          "Fail.Cfg_AlmMinOnT",
          "Fail.Cfg_MaxShelfT",
          "Fail.Cfg_Cond",
          "Fail.Cfg_Tag",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack"
        ]
      },
      {
        "sheetname": "P_AOut",
        "columns": [
          "Controller",
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_EU",
          "Cfg_CVEUMin",
          "Cfg_CVEUMax",
          "Cfg_CVRawMin",
          "Cfg_CVRawMax",
          "Cfg_MinCV",
          "Cfg_MaxCV",
          "Cfg_MaxCVRoCInc",
          "Cfg_MaxCVRoCDec",
          "Cfg_SkipRoCLim",
          "Cfg_MaxInactiveCV",
          "Cfg_ShedHold",
          "Cfg_ShedOnIOFault",
          "Cfg_IntlkCV",
          "Cfg_HasIntlkObj",
          "Cfg_HasCVNav",
          "Cfg_CVNavTag",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack",
          "Cfg_SetTrackOvrdHand",
          "Cfg_OvrdIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_AOutHART",
        "columns": [
          "Controller",
          "ModuleTagName",
          "Ref_ChanDataTagName",
          "Ref_DiagTableTagName",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_EU",
          "Cfg_CVEUMin",
          "Cfg_CVEUMax",
          "Cfg_CVRawMin",
          "Cfg_CVRawMax",
          "Cfg_MinCV",
          "Cfg_MaxCV",
          "Cfg_HasHART",
          "Cfg_HasPV",
          "Cfg_PVLabel",
          "Cfg_PVEU",
          "Cfg_HasSV",
          "Cfg_SVLabel",
          "Cfg_SVEU",
          "Cfg_HasTV",
          "Cfg_TVLabel",
          "Cfg_TVEU",
          "Cfg_HasFV",
          "Cfg_FVLabel",
          "Cfg_FVEU",
          "Cfg_MaxCVRoCInc",
          "Cfg_MaxCVRoCDec",
          "Cfg_SkipRoCLim",
          "Cfg_MaxInactiveCV",
          "Cfg_ShedHold",
          "Cfg_ShedOnIOFault",
          "Cfg_IntlkCV",
          "Cfg_HasIntlkObj",
          "Cfg_HasCVNav",
          "Cfg_CVNavTag",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack",
          "Cfg_SetTrackOvrdHand",
          "Cfg_OvrdIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_DIn",
        "columns": [
          "Controller",
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_0StText",
          "Cfg_1StText",
          "Cfg_NoSubstPV",
          "Cfg_Debounce",
          "Cfg_NormTextVis",
          "Inp_Target",
          "TgtDisagreeGate.Cfg_InpCond",
          "TgtDisagreeGate.Cfg_GateCond",
          "TgtDisagreeGate.Cfg_GateDly",
          "TgtDisagreeGate.Cfg_OnDly",
          "TgtDisagreeGate.Cfg_OffDly",
          "TgtDisagree.Cfg_Cond",
          "TgtDisagree.Cfg_Tag",
          "TgtDisagree.Cfg_Exists",
          "TgtDisagree.Cfg_ResetReqd",
          "TgtDisagree.Cfg_AckReqd",
          "TgtDisagree.Cfg_Severity",
          "TgtDisagree.Cfg_AllowShelve",
          "TgtDisagree.Cfg_AllowDisable",
          "TgtDisagree.Cfg_AlmMinOnT",
          "TgtDisagree.Cfg_MaxShelfT",
          "Cfg_PCmdClear"
        ]
      },
      {
        "sheetname": "P_DOut",
        "columns": [
          "Controller",
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_0StText",
          "Cfg_1StText",
          "Cfg_OnDelayT",
          "Cfg_OffDelayT",
          "Cfg_OnPulseT",
          "Cfg_OffPulseT",
          "Cfg_CompletePulse",
          "Cfg_HasOnFdbk",
          "Cfg_HasOffFdbk",
          "Cfg_UseOnFdbk",
          "Cfg_UseOffFdbk",
          "Cfg_FdbkFail",
          "Cfg_ShedOnFail",
          "Cfg_ShedOnIOFault",
          "Cfg_SimFdbkT",
          "Cfg_HasPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_OnFailT",
          "OnFail.Cfg_Cond",
          "OnFail.Cfg_Tag",
          "OnFail.Cfg_Exists",
          "OnFail.Cfg_ResetReqd",
          "OnFail.Cfg_AckReqd",
          "OnFail.Cfg_Severity",
          "OnFail.Cfg_AllowShelve",
          "OnFail.Cfg_AllowDisable",
          "OnFail.Cfg_AlmMinOnT",
          "OnFail.Cfg_MaxShelfT",
          "Cfg_OffFailT",
          "OffFail.Cfg_Cond",
          "OffFail.Cfg_Tag",
          "OffFail.Cfg_Exists",
          "OffFail.Cfg_ResetReqd",
          "OffFail.Cfg_AckReqd",
          "OffFail.Cfg_Severity",
          "OffFail.Cfg_AllowShelve",
          "OffFail.Cfg_AllowDisable",
          "OffFail.Cfg_AlmMinOnT",
          "OffFail.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperOffPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_PIDE",
        "columns": [
          "Controller",
          "ModuleTagName",
          "InputValueTagName",
          "OutputValue1TagName",
          "OutputValue2TagName",
          "OutputIsValve",
          "OutputIsVSD",
          "OutputIsPIDE",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_PVEU",
          "Cfg_PVEUMin",
          "Cfg_PVEUMax",
          "Cfg_CVEU",
          "Cfg_CVEUMin",
          "Cfg_CVEUMax",
          "Cfg_HasRatio",
          "Cfg_HasCasc",
          "Cfg_PVTrack",
          "Cfg_CtrlAction",
          "Cfg_Depend",
          "Cfg_DerivSmooth",
          "Cfg_ZCOff",
          "Cfg_LimitManCV",
          "Cfg_InitToMan",
          "Cfg_PropSPAct",
          "Cfg_DerivSPAct",
          "Cfg_PGain",
          "Cfg_IGain",
          "Cfg_DGain",
          "Cfg_ZCDB",
          "Cfg_MinRatio",
          "Cfg_MaxRatio",
          "Cfg_MinSP",
          "Cfg_MaxSP",
          "Cfg_MinCV",
          "Cfg_MaxCV",
          "Cfg_MaxInactiveCV",
          "Cfg_CVRoCLim",
          "Cfg_PwrupLM",
          "Cfg_PwrupSP",
          "Cfg_PwrupCV",
          "Cfg_DevDB",
          "Cfg_IntlkCV",
          "Cfg_HasIntlkObj",
          "Cfg_HasCascSPNav",
          "Cfg_CascSPNavTag",
          "Cfg_HasPVNav",
          "Cfg_PVNavTag",
          "Cfg_HasCVNav",
          "Cfg_CVNavTag",
          "HiHiDevGate.Cfg_InpCond",
          "HiHiDevGate.Cfg_GateCond",
          "HiHiDevGate.Cfg_GateDly",
          "HiHiDevGate.Cfg_OnDly",
          "HiHiDevGate.Cfg_OffDly",
          "HiHiDev.Cfg_Cond",
          "HiHiDev.Cfg_Tag",
          "HiHiDev.Cfg_Exists",
          "HiHiDev.Cfg_ResetReqd",
          "HiHiDev.Cfg_AckReqd",
          "HiHiDev.Cfg_Severity",
          "HiHiDev.Cfg_AllowShelve",
          "HiHiDev.Cfg_AllowDisable",
          "HiHiDev.Cfg_AlmMinOnT",
          "HiHiDev.Cfg_MaxShelfT",
          "HiDevGate.Cfg_InpCond",
          "HiDevGate.Cfg_GateCond",
          "HiDevGate.Cfg_GateDly",
          "HiDevGate.Cfg_OnDly",
          "HiDevGate.Cfg_OffDly",
          "HiDev.Cfg_Cond",
          "HiDev.Cfg_Tag",
          "HiDev.Cfg_Exists",
          "HiDev.Cfg_ResetReqd",
          "HiDev.Cfg_AckReqd",
          "HiDev.Cfg_Severity",
          "HiDev.Cfg_AllowShelve",
          "HiDev.Cfg_AllowDisable",
          "HiDev.Cfg_AlmMinOnT",
          "HiDev.Cfg_MaxShelfT",
          "LoDevGate.Cfg_InpCond",
          "LoDevGate.Cfg_GateCond",
          "LoDevGate.Cfg_GateDly",
          "LoDevGate.Cfg_OnDly",
          "LoDevGate.Cfg_OffDly",
          "LoDev.Cfg_Cond",
          "LoDev.Cfg_Tag",
          "LoDev.Cfg_Exists",
          "LoDev.Cfg_ResetReqd",
          "LoDev.Cfg_AckReqd",
          "LoDev.Cfg_Severity",
          "LoDev.Cfg_AllowShelve",
          "LoDev.Cfg_AllowDisable",
          "LoDev.Cfg_AlmMinOnT",
          "LoDev.Cfg_MaxShelfT",
          "LoLoDevGate.Cfg_InpCond",
          "LoLoDevGate.Cfg_GateCond",
          "LoLoDevGate.Cfg_GateDly",
          "LoLoDevGate.Cfg_OnDly",
          "LoLoDevGate.Cfg_OffDly",
          "LoLoDev.Cfg_Cond",
          "LoLoDev.Cfg_Tag",
          "LoLoDev.Cfg_Exists",
          "LoLoDev.Cfg_ResetReqd",
          "LoLoDev.Cfg_AckReqd",
          "LoLoDev.Cfg_Severity",
          "LoLoDev.Cfg_AllowShelve",
          "LoLoDev.Cfg_AllowDisable",
          "LoLoDev.Cfg_AlmMinOnT",
          "LoLoDev.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "Fail.Cfg_Cond",
          "Fail.Cfg_Tag",
          "Fail.Cfg_Exists",
          "Fail.Cfg_ResetReqd",
          "Fail.Cfg_AckReqd",
          "Fail.Cfg_Severity",
          "Fail.Cfg_AllowShelve",
          "Fail.Cfg_AllowDisable",
          "Fail.Cfg_AlmMinOnT",
          "Fail.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_SetTrack",
          "Cfg_SetTrackOvrdHand",
          "Cfg_OvrdIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_ValveSO",
        "columns": [
          "Controller",
          "ModuleTagName",
          "OutputTagName",
          "ZSCFeedbackTagName",
          "ZSOFeedbackTagName",
          "ResetInputTagName",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Inp_Sim",
          "Cfg_FailOpen",
          "Cfg_HasOpenLS",
          "Cfg_HasClosedLS",
          "Cfg_UseOpenLS",
          "Cfg_UseClosedLS",
          "Cfg_LSFail",
          "Cfg_FullStallT",
          "Cfg_TransitStallT",
          "Cfg_ShedOnFullStall",
          "Cfg_ShedOnTransitStall",
          "Cfg_ShedOnIOFault",
          "Cfg_SimFdbkT",
          "Cfg_HasPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasStatsObj",
          "FullStall.Cfg_Cond",
          "FullStall.Cfg_Tag",
          "FullStall.Cfg_Exists",
          "FullStall.Cfg_ResetReqd",
          "FullStall.Cfg_AckReqd",
          "FullStall.Cfg_Severity",
          "FullStall.Cfg_AllowShelve",
          "FullStall.Cfg_AllowDisable",
          "FullStall.Cfg_AlmMinOnT",
          "FullStall.Cfg_MaxShelfT",
          "TransitStall.Cfg_Cond",
          "TransitStall.Cfg_Tag",
          "TransitStall.Cfg_Exists",
          "TransitStall.Cfg_ResetReqd",
          "TransitStall.Cfg_AckReqd",
          "TransitStall.Cfg_Severity",
          "TransitStall.Cfg_AllowShelve",
          "TransitStall.Cfg_AllowDisable",
          "TransitStall.Cfg_AlmMinOnT",
          "TransitStall.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_VSD",
        "columns": [
          "Controller",
          "ModuleTagName",
          "FaultCodeListTagName",
          "RunCommandTagName",
          "SpeedCommandTagName",
          "RunningFeedbackTagName",
          "SpeedFeedbackTagName",
          "FaultedFeedbackTagName",
          "HandInputTagName",
          "ResetInputTagName",
          "HasRuntimeStats",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Inp_Sim",
          "Cfg_FwdText",
          "Cfg_RevText",
          "Cfg_SpeedRefEU",
          "Cfg_SpeedRefRawMin",
          "Cfg_SpeedRefRawMax",
          "Cfg_SpeedRefEUMin",
          "Cfg_SpeedRefEUMax",
          "Cfg_SpeedFdbkEU",
          "Cfg_SpeedFdbkRawMin",
          "Cfg_SpeedFdbkRawMax",
          "Cfg_SpeedFdbkEUMin",
          "Cfg_SpeedFdbkEUMax",
          "Cfg_HasReverse",
          "Cfg_HasJog",
          "Cfg_AllowLocal",
          "Cfg_MinSpdRef",
          "Cfg_MaxSpdRef",
          "Cfg_MaxJogT",
          "Cfg_ResetPulseT",
          "Cfg_HasRunFdbk",
          "Cfg_UseRunFdbk",
          "Cfg_FailToStartT",
          "Cfg_FailToStopT",
          "Cfg_ShedOnFailToStart",
          "Cfg_ShedOnIOFault",
          "Cfg_InpDatalinkEU",
          "Cfg_InpDatalinkLabel",
          "Cfg_HasInpDatalink",
          "Cfg_InpDatalinkRawMin",
          "Cfg_InpDatalinkRawMax",
          "Cfg_InpDatalinkEUMin",
          "Cfg_InpDatalinkEUMax",
          "Cfg_OutDatalinkEU",
          "Cfg_OutDatalinkLabel",
          "Cfg_HasOutDatalink",
          "Cfg_OutDatalinkRawMin",
          "Cfg_OutDatalinkRawMax",
          "Cfg_OutDatalinkEUMin",
          "Cfg_OutDatalinkEUMax",
          "Cfg_OutDatalinkMin",
          "Cfg_OutDatalinkMax",
          "Cfg_SimRampT",
          "Cfg_SimScaleEU",
          "Cfg_SimScaleRaw",
          "Cfg_HasFwdPermObj",
          "Cfg_HasRevPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasResInhObj",
          "Cfg_HasRunTimeObj",
          "FailToStart.Cfg_Cond",
          "FailToStart.Cfg_Tag",
          "FailToStart.Cfg_Exists",
          "FailToStart.Cfg_ResetReqd",
          "FailToStart.Cfg_AckReqd",
          "FailToStart.Cfg_Severity",
          "FailToStart.Cfg_AllowShelve",
          "FailToStart.Cfg_AllowDisable",
          "FailToStart.Cfg_AlmMinOnT",
          "FailToStart.Cfg_MaxShelfT",
          "FailToStop.Cfg_Cond",
          "FailToStop.Cfg_Tag",
          "FailToStop.Cfg_Exists",
          "FailToStop.Cfg_ResetReqd",
          "FailToStop.Cfg_AckReqd",
          "FailToStop.Cfg_Severity",
          "FailToStop.Cfg_AllowShelve",
          "FailToStop.Cfg_AllowDisable",
          "FailToStop.Cfg_AlmMinOnT",
          "FailToStop.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "DriveFault.Cfg_Cond",
          "DriveFault.Cfg_Tag",
          "DriveFault.Cfg_Exists",
          "DriveFault.Cfg_ResetReqd",
          "DriveFault.Cfg_AckReqd",
          "DriveFault.Cfg_Severity",
          "DriveFault.Cfg_AllowShelve",
          "DriveFault.Cfg_AllowDisable",
          "DriveFault.Cfg_AlmMinOnT",
          "DriveFault.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_SetTrackOvrdHand",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperStopPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Cfg_SetTrack",
          "Cfg_OperKeep",
          "Cfg_ProgKeep",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "AOI_Weigh_Scale",
        "columns": [
          "Controller",
          "ModuleTagName",
          "DeviceTagName",
          "ResetInputTagName",
          "HasChannelIO",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Cfg_FwdText",
          "Cfg_RevText",
          "Cfg_SpeedRefEU",
          "Cfg_SpeedRefRawMin",
          "Cfg_SpeedRefRawMax",
          "Cfg_SpeedRefEUMin",
          "Cfg_SpeedRefEUMax",
          "Cfg_SpeedFdbkEU",
          "Cfg_SpeedFdbkRawMin",
          "Cfg_SpeedFdbkRawMax",
          "Cfg_SpeedFdbkEUMin",
          "Cfg_SpeedFdbkEUMax",
          "Cfg_HasReverse",
          "Cfg_HasJog",
          "Cfg_AllowLocal",
          "Cfg_MinSpdRef",
          "Cfg_MaxSpdRef",
          "Cfg_MaxJogT",
          "Cfg_ResetPulseT",
          "Cfg_HasRunFdbk",
          "Cfg_UseRunFdbk",
          "Cfg_FailToStartT",
          "Cfg_FailToStopT",
          "Cfg_ShedOnFailToStart",
          "Cfg_ShedOnIOFault",
          "Cfg_InpDatalinkEU",
          "Cfg_InpDatalinkLabel",
          "Cfg_HasInpDatalink",
          "Cfg_InpDatalinkRawMin",
          "Cfg_InpDatalinkRawMax",
          "Cfg_InpDatalinkEUMin",
          "Cfg_InpDatalinkEUMax",
          "Cfg_OutDatalinkEU",
          "Cfg_OutDatalinkLabel",
          "Cfg_HasOutDatalink",
          "Cfg_OutDatalinkRawMin",
          "Cfg_OutDatalinkRawMax",
          "Cfg_OutDatalinkEUMin",
          "Cfg_OutDatalinkEUMax",
          "Cfg_OutDatalinkMin",
          "Cfg_OutDatalinkMax",
          "Cfg_SimRampT",
          "Cfg_SimScaleEU",
          "Cfg_SimScaleRaw",
          "Cfg_HasFwdPermObj",
          "Cfg_HasRevPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasResInhObj",
          "Cfg_HasRunTimeObj",
          "FailToStart.Cfg_Cond",
          "FailToStart.Cfg_Tag",
          "FailToStart.Cfg_Exists",
          "FailToStart.Cfg_ResetReqd",
          "FailToStart.Cfg_AckReqd",
          "FailToStart.Cfg_Severity",
          "FailToStart.Cfg_AllowShelve",
          "FailToStart.Cfg_AllowDisable",
          "FailToStart.Cfg_AlmMinOnT",
          "FailToStart.Cfg_MaxShelfT",
          "FailToStop.Cfg_Cond",
          "FailToStop.Cfg_Tag",
          "FailToStop.Cfg_Exists",
          "FailToStop.Cfg_ResetReqd",
          "FailToStop.Cfg_AckReqd",
          "FailToStop.Cfg_Severity",
          "FailToStop.Cfg_AllowShelve",
          "FailToStop.Cfg_AllowDisable",
          "FailToStop.Cfg_AlmMinOnT",
          "FailToStop.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "DriveFault.Cfg_Cond",
          "DriveFault.Cfg_Tag",
          "DriveFault.Cfg_Exists",
          "DriveFault.Cfg_ResetReqd",
          "DriveFault.Cfg_AckReqd",
          "DriveFault.Cfg_Severity",
          "DriveFault.Cfg_AllowShelve",
          "DriveFault.Cfg_AllowDisable",
          "DriveFault.Cfg_AlmMinOnT",
          "DriveFault.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Cfg_SetTrackOvrdHand",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperStopPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Cfg_SetTrack",
          "Cfg_OperKeep",
          "Cfg_ProgKeep",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "P_Motor",
        "columns": [
          "Controller",
          "ModuleTagName",
          "DeviceTagName",
          "RunFeedbackTagName",
          "Lead-LagTagName",
          "ResetInputTagName",
          "HasRuntimeStats",
          "CodeOverride",
          "CommentOverride",
          "Description",
          "Cfg_Desc",
          "Cfg_Label",
          "Cfg_Tag",
          "Inp_Sim",
          "Cfg_HasRunFdbk",
          "Cfg_UseRunFdbk",
          "Cfg_AllowLocal",
          "Cfg_HasPermObj",
          "Cfg_HasIntlkObj",
          "Cfg_HasResInhObj",
          "Cfg_HasRunTimeObj",
          "Cfg_HasOvldObj",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_OperStopPrio",
          "Cfg_OCmdResets",
          "Cfg_OvrdPermIntlk",
          "Cfg_ShedOnFailToStart",
          "Cfg_ShedOnIOFault",
          "Cfg_HasFailToStartAlm",
          "Cfg_HasFailToStopAlm",
          "Cfg_HasIntlkTripAlm",
          "Cfg_HasIOFaultAlm",
          "Cfg_FailToStartResetReqd",
          "Cfg_FailToStopResetReqd",
          "Cfg_IntlkTripResetReqd",
          "Cfg_IOFaultResetReqd",
          "Cfg_FailToStartAckReqd",
          "Cfg_FailToStopAckReqd",
          "Cfg_IntlkTripAckReqd",
          "Cfg_IOFaultAckReqd",
          "Cfg_FailToStartSeverity",
          "Cfg_FailToStopSeverity",
          "Cfg_IntlkTripSeverity",
          "Cfg_IOFaultSeverity",
          "Cfg_SimFdbkT",
          "Cfg_FailToStartT",
          "Cfg_FailToStopT",
          "",
          "Cfg_OnFailT",
          "OnFail.Cfg_Cond",
          "OnFail.Cfg_Tag",
          "OnFail.Cfg_Exists",
          "OnFail.Cfg_ResetReqd",
          "OnFail.Cfg_AckReqd",
          "OnFail.Cfg_Severity",
          "OnFail.Cfg_AllowShelve",
          "OnFail.Cfg_AllowDisable",
          "OnFail.Cfg_AlmMinOnT",
          "OnFail.Cfg_MaxShelfT",
          "Cfg_OffFailT",
          "FailToStart.Cfg_Cond",
          "FailToStart.Cfg_Tag",
          "FailToStart.Cfg_Exists",
          "FailToStart.Cfg_ResetReqd",
          "FailToStart.Cfg_AckReqd",
          "FailToStart.Cfg_Severity",
          "FailToStart.Cfg_AllowShelve",
          "FailToStart.Cfg_AllowDisable",
          "FailToStart.Cfg_AlmMinOnT",
          "FailToStart.Cfg_MaxShelfT",
          "FailToStop.Cfg_Cond",
          "FailToStop.Cfg_Tag",
          "FailToStop.Cfg_Exists",
          "FailToStop.Cfg_ResetReqd",
          "FailToStop.Cfg_AckReqd",
          "FailToStop.Cfg_Severity",
          "FailToStop.Cfg_AllowShelve",
          "FailToStop.Cfg_AllowDisable",
          "FailToStop.Cfg_AlmMinOnT",
          "FailToStop.Cfg_MaxShelfT",
          "IntlkTrip.Cfg_Cond",
          "IntlkTrip.Cfg_Tag",
          "IntlkTrip.Cfg_Exists",
          "IntlkTrip.Cfg_ResetReqd",
          "IntlkTrip.Cfg_AckReqd",
          "IntlkTrip.Cfg_Severity",
          "IntlkTrip.Cfg_AllowShelve",
          "IntlkTrip.Cfg_AllowDisable",
          "IntlkTrip.Cfg_AlmMinOnT",
          "IntlkTrip.Cfg_MaxShelfT",
          "IOFault.Cfg_Cond",
          "IOFault.Cfg_Tag",
          "IOFault.Cfg_Exists",
          "IOFault.Cfg_ResetReqd",
          "IOFault.Cfg_AckReqd",
          "IOFault.Cfg_Severity",
          "IOFault.Cfg_AllowShelve",
          "IOFault.Cfg_AllowDisable",
          "IOFault.Cfg_AlmMinOnT",
          "IOFault.Cfg_MaxShelfT",
          "Mode.Cfg_OvrdOverLock"
        ]
      },
      {
        "sheetname": "AOI_EM",
        "columns": [
          "Controller",
          "ModuleTagName",
          "IntPSetOwnerRegister",
          "IntPCmdSPRegister",
          "ResetInputTagName",
          "Description",
          "CodeOverride",
          "CommentOverride",
          "Valve_EM",
          "Cfg_Tag",
          "Cfg_Label",
          "Cfg_Desc",
          "Inf_Lib",
          "Inf_Type",
          "Inp_Hand",
          "OCmd_SP",
          "PCmd_SP",
          "PSet_Owner",
          "Val_PV",
          "Val_Owner",
          "Val_Mode",
          "Inp_NotReadySP",
          "Inp_OvrdSP",
          "PCmd_Acq",
          "PCmd_rel",
          "Ocmd_reset",
          "Cfg_FaultAckReqd",
          "Cfg_FaultResetReqd",
          "Cfg_FaultSeverity",
          "Cfg_HasIOFaultAlm",
          "Cfg_IOFaultAckReqd",
          "Cfg_IOFaultResetReqd",
          "Cfg_IOFaultSeverity",
          "Cfg_Minimal_Step_Duration",
          "Cfg_ModeLockSubs",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_PVTableLowerLimit",
          "Cfg_PVTableUpperLimit",
          "Cfg_SPTableLowerLimit",
          "Cfg_SPTableUpperLimit",
          "Cfg_StateTableLowerLimit",
          "Cfg_StateTableUpperLimit",
          "pset_owner",
          "inp_notreadysp",
          "Fault.Cfg_Tag",
          "IOFault.Cfg_Tag",
          "Fault.Cfg_Cond",
          "IOFault.Cfg_Cond",
          "Cfg_States[0].Val",
          "Cfg_States[1].Val",
          "Cfg_States[2].Val",
          "Cfg_States[3].Val",
          "Cfg_States[4].Val",
          "Cfg_States[5].Val",
          "Cfg_States[6].Val",
          "Cfg_States[7].Val",
          "Cfg_States[8].Val",
          "Cfg_States[9].Val",
          "Cfg_States[10].Val",
          "Cfg_States[11].Val",
          "Cfg_States[12].Val",
          "Cfg_States[13].Val",
          "Cfg_States[14].Val",
          "Cfg_States[15].Val",
          "Cfg_States[16].Val",
          "Cfg_States[17].Val",
          "Cfg_States[18].Val",
          "Cfg_States[19].Val",
          "Cfg_States[20].Val",
          "Cfg_States[0].Desc",
          "Cfg_States[1].Desc",
          "Cfg_States[2].Desc",
          "Cfg_States[3].Desc",
          "Cfg_States[4].Desc",
          "Cfg_States[5].Desc",
          "Cfg_States[6].Desc",
          "Cfg_States[7].Desc",
          "Cfg_States[8].Desc",
          "Cfg_States[9].Desc",
          "Cfg_States[10].Desc",
          "Cfg_States[11].Desc",
          "Cfg_States[12].Desc",
          "Cfg_States[13].Desc",
          "Cfg_States[14].Desc",
          "Cfg_States[15].Desc",
          "Cfg_States[16].Desc",
          "Cfg_States[17].Desc",
          "Cfg_States[18].Desc",
          "Cfg_States[19].Desc",
          "Cfg_States[20].Desc",
          "Cfg_SP_Descs[0].Val",
          "Cfg_SP_Descs[1].Val",
          "Cfg_SP_Descs[2].Val",
          "Cfg_SP_Descs[3].Val",
          "Cfg_SP_Descs[4].Val",
          "Cfg_SP_Descs[5].Val",
          "Cfg_SP_Descs[6].Val",
          "Cfg_SP_Descs[7].Val",
          "Cfg_SP_Descs[8].Val",
          "Cfg_SP_Descs[9].Val",
          "Cfg_SP_Descs[10].Val",
          "Cfg_SP_Descs[11].Val",
          "Cfg_SP_Descs[12].Val",
          "Cfg_SP_Descs[13].Val",
          "Cfg_SP_Descs[14].Val",
          "Cfg_SP_Descs[15].Val",
          "Cfg_SP_Descs[16].Val",
          "Cfg_SP_Descs[17].Val",
          "Cfg_SP_Descs[18].Val",
          "Cfg_SP_Descs[19].Val",
          "Cfg_SP_Descs[20].Val",
          "Cfg_SP_Descs[21].Val",
          "Cfg_SP_Descs[22].Val",
          "Cfg_SP_Descs[23].Val",
          "Cfg_SP_Descs[24].Val",
          "Cfg_SP_Descs[25].Val",
          "Cfg_SP_Descs[26].Val",
          "Cfg_SP_Descs[27].Val",
          "Cfg_SP_Descs[28].Val",
          "Cfg_SP_Descs[29].Val",
          "Cfg_SP_Descs[30].Val",
          "Cfg_SP_Descs[31].Val",
          "Cfg_SP_Descs[32].Val",
          "Cfg_SP_Descs[33].Val",
          "Cfg_SP_Descs[34].Val",
          "Cfg_SP_Descs[35].Val",
          "Cfg_SP_Descs[36].Val",
          "Cfg_SP_Descs[37].Val",
          "Cfg_SP_Descs[38].Val",
          "Cfg_SP_Descs[39].Val",
          "Cfg_SP_Descs[40].Val",
          "Cfg_SP_Descs[41].Val",
          "Cfg_SP_Descs[42].Val",
          "Cfg_SP_Descs[43].Val",
          "Cfg_SP_Descs[44].Val",
          "Cfg_SP_Descs[45].Val",
          "Cfg_SP_Descs[46].Val",
          "Cfg_SP_Descs[47].Val",
          "Cfg_SP_Descs[48].Val",
          "Cfg_SP_Descs[49].Val",
          "Cfg_SP_Descs[50].Val",
          "Cfg_SP_Descs[51].Val",
          "Cfg_SP_Descs[52].Val",
          "Cfg_SP_Descs[53].Val",
          "Cfg_SP_Descs[54].Val",
          "Cfg_SP_Descs[55].Val",
          "Cfg_SP_Descs[56].Val",
          "Cfg_SP_Descs[57].Val",
          "Cfg_SP_Descs[58].Val",
          "Cfg_SP_Descs[59].Val",
          "Cfg_SP_Descs[60].Val",
          "Cfg_SP_Descs[61].Val",
          "Cfg_SP_Descs[62].Val",
          "Cfg_SP_Descs[63].Val",
          "Cfg_SP_Descs[64].Val",
          "Cfg_SP_Descs[0].Desc",
          "Cfg_SP_Descs[1].Desc",
          "Cfg_SP_Descs[2].Desc",
          "Cfg_SP_Descs[3].Desc",
          "Cfg_SP_Descs[4].Desc",
          "Cfg_SP_Descs[5].Desc",
          "Cfg_SP_Descs[6].Desc",
          "Cfg_SP_Descs[7].Desc",
          "Cfg_SP_Descs[8].Desc",
          "Cfg_SP_Descs[9].Desc",
          "Cfg_SP_Descs[10].Desc",
          "Cfg_SP_Descs[11].Desc",
          "Cfg_SP_Descs[12].Desc",
          "Cfg_SP_Descs[13].Desc",
          "Cfg_SP_Descs[14].Desc",
          "Cfg_SP_Descs[15].Desc",
          "Cfg_SP_Descs[16].Desc",
          "Cfg_SP_Descs[17].Desc",
          "Cfg_SP_Descs[18].Desc",
          "Cfg_SP_Descs[19].Desc",
          "Cfg_SP_Descs[20].Desc",
          "Cfg_SP_Descs[21].Desc",
          "Cfg_SP_Descs[22].Desc",
          "Cfg_SP_Descs[23].Desc",
          "Cfg_SP_Descs[24].Desc",
          "Cfg_SP_Descs[25].Desc",
          "Cfg_SP_Descs[26].Desc",
          "Cfg_SP_Descs[27].Desc",
          "Cfg_SP_Descs[28].Desc",
          "Cfg_SP_Descs[29].Desc",
          "Cfg_SP_Descs[30].Desc",
          "Cfg_SP_Descs[31].Desc",
          "Cfg_SP_Descs[32].Desc",
          "Cfg_SP_Descs[33].Desc",
          "Cfg_SP_Descs[34].Desc",
          "Cfg_SP_Descs[35].Desc",
          "Cfg_SP_Descs[36].Desc",
          "Cfg_SP_Descs[37].Desc",
          "Cfg_SP_Descs[38].Desc",
          "Cfg_SP_Descs[39].Desc",
          "Cfg_SP_Descs[40].Desc",
          "Cfg_SP_Descs[41].Desc",
          "Cfg_SP_Descs[42].Desc",
          "Cfg_SP_Descs[43].Desc",
          "Cfg_SP_Descs[44].Desc",
          "Cfg_SP_Descs[45].Desc",
          "Cfg_SP_Descs[46].Desc",
          "Cfg_SP_Descs[47].Desc",
          "Cfg_SP_Descs[48].Desc",
          "Cfg_SP_Descs[49].Desc",
          "Cfg_SP_Descs[50].Desc",
          "Cfg_SP_Descs[51].Desc",
          "Cfg_SP_Descs[52].Desc",
          "Cfg_SP_Descs[53].Desc",
          "Cfg_SP_Descs[54].Desc",
          "Cfg_SP_Descs[55].Desc",
          "Cfg_SP_Descs[56].Desc",
          "Cfg_SP_Descs[57].Desc",
          "Cfg_SP_Descs[58].Desc",
          "Cfg_SP_Descs[59].Desc",
          "Cfg_SP_Descs[60].Desc",
          "Cfg_SP_Descs[61].Desc",
          "Cfg_SP_Descs[62].Desc",
          "Cfg_SP_Descs[63].Desc",
          "Cfg_SP_Descs[64].Desc",
          "Cfg_PV_Descs[0].Val",
          "Cfg_PV_Descs[1].Val",
          "Cfg_PV_Descs[2].Val",
          "Cfg_PV_Descs[3].Val",
          "Cfg_PV_Descs[4].Val",
          "Cfg_PV_Descs[5].Val",
          "Cfg_PV_Descs[6].Val",
          "Cfg_PV_Descs[7].Val",
          "Cfg_PV_Descs[8].Val",
          "Cfg_PV_Descs[9].Val",
          "Cfg_PV_Descs[10].Val",
          "Cfg_PV_Descs[11].Val",
          "Cfg_PV_Descs[12].Val",
          "Cfg_PV_Descs[13].Val",
          "Cfg_PV_Descs[14].Val",
          "Cfg_PV_Descs[15].Val",
          "Cfg_PV_Descs[16].Val",
          "Cfg_PV_Descs[17].Val",
          "Cfg_PV_Descs[18].Val",
          "Cfg_PV_Descs[19].Val",
          "Cfg_PV_Descs[20].Val",
          "Cfg_PV_Descs[21].Val",
          "Cfg_PV_Descs[22].Val",
          "Cfg_PV_Descs[23].Val",
          "Cfg_PV_Descs[24].Val",
          "Cfg_PV_Descs[25].Val",
          "Cfg_PV_Descs[26].Val",
          "Cfg_PV_Descs[27].Val",
          "Cfg_PV_Descs[28].Val",
          "Cfg_PV_Descs[29].Val",
          "Cfg_PV_Descs[30].Val",
          "Cfg_PV_Descs[31].Val",
          "Cfg_PV_Descs[32].Val",
          "Cfg_PV_Descs[33].Val",
          "Cfg_PV_Descs[34].Val",
          "Cfg_PV_Descs[35].Val",
          "Cfg_PV_Descs[36].Val",
          "Cfg_PV_Descs[37].Val",
          "Cfg_PV_Descs[38].Val",
          "Cfg_PV_Descs[39].Val",
          "Cfg_PV_Descs[40].Val",
          "Cfg_PV_Descs[41].Val",
          "Cfg_PV_Descs[42].Val",
          "Cfg_PV_Descs[43].Val",
          "Cfg_PV_Descs[44].Val",
          "Cfg_PV_Descs[45].Val",
          "Cfg_PV_Descs[46].Val",
          "Cfg_PV_Descs[47].Val",
          "Cfg_PV_Descs[48].Val",
          "Cfg_PV_Descs[49].Val",
          "Cfg_PV_Descs[50].Val",
          "Cfg_PV_Descs[51].Val",
          "Cfg_PV_Descs[52].Val",
          "Cfg_PV_Descs[53].Val",
          "Cfg_PV_Descs[54].Val",
          "Cfg_PV_Descs[55].Val",
          "Cfg_PV_Descs[56].Val",
          "Cfg_PV_Descs[57].Val",
          "Cfg_PV_Descs[58].Val",
          "Cfg_PV_Descs[59].Val",
          "Cfg_PV_Descs[60].Val",
          "Cfg_PV_Descs[61].Val",
          "Cfg_PV_Descs[62].Val",
          "Cfg_PV_Descs[63].Val",
          "Cfg_PV_Descs[64].Val",
          "Cfg_PV_Descs[0].Desc",
          "Cfg_PV_Descs[1].Desc",
          "Cfg_PV_Descs[2].Desc",
          "Cfg_PV_Descs[3].Desc",
          "Cfg_PV_Descs[4].Desc",
          "Cfg_PV_Descs[5].Desc",
          "Cfg_PV_Descs[6].Desc",
          "Cfg_PV_Descs[7].Desc",
          "Cfg_PV_Descs[8].Desc",
          "Cfg_PV_Descs[9].Desc",
          "Cfg_PV_Descs[10].Desc",
          "Cfg_PV_Descs[11].Desc",
          "Cfg_PV_Descs[12].Desc",
          "Cfg_PV_Descs[13].Desc",
          "Cfg_PV_Descs[14].Desc",
          "Cfg_PV_Descs[15].Desc",
          "Cfg_PV_Descs[16].Desc",
          "Cfg_PV_Descs[17].Desc",
          "Cfg_PV_Descs[18].Desc",
          "Cfg_PV_Descs[19].Desc",
          "Cfg_PV_Descs[20].Desc",
          "Cfg_PV_Descs[21].Desc",
          "Cfg_PV_Descs[22].Desc",
          "Cfg_PV_Descs[23].Desc",
          "Cfg_PV_Descs[24].Desc",
          "Cfg_PV_Descs[25].Desc",
          "Cfg_PV_Descs[26].Desc",
          "Cfg_PV_Descs[27].Desc",
          "Cfg_PV_Descs[28].Desc",
          "Cfg_PV_Descs[29].Desc",
          "Cfg_PV_Descs[30].Desc",
          "Cfg_PV_Descs[31].Desc",
          "Cfg_PV_Descs[32].Desc",
          "Cfg_PV_Descs[33].Desc",
          "Cfg_PV_Descs[34].Desc",
          "Cfg_PV_Descs[35].Desc",
          "Cfg_PV_Descs[36].Desc",
          "Cfg_PV_Descs[37].Desc",
          "Cfg_PV_Descs[38].Desc",
          "Cfg_PV_Descs[39].Desc",
          "Cfg_PV_Descs[40].Desc",
          "Cfg_PV_Descs[41].Desc",
          "Cfg_PV_Descs[42].Desc",
          "Cfg_PV_Descs[43].Desc",
          "Cfg_PV_Descs[44].Desc",
          "Cfg_PV_Descs[45].Desc",
          "Cfg_PV_Descs[46].Desc",
          "Cfg_PV_Descs[47].Desc",
          "Cfg_PV_Descs[48].Desc",
          "Cfg_PV_Descs[49].Desc",
          "Cfg_PV_Descs[50].Desc",
          "Cfg_PV_Descs[51].Desc",
          "Cfg_PV_Descs[52].Desc",
          "Cfg_PV_Descs[53].Desc",
          "Cfg_PV_Descs[54].Desc",
          "Cfg_PV_Descs[55].Desc",
          "Cfg_PV_Descs[56].Desc",
          "Cfg_PV_Descs[57].Desc",
          "Cfg_PV_Descs[58].Desc",
          "Cfg_PV_Descs[59].Desc",
          "Cfg_PV_Descs[60].Desc",
          "Cfg_PV_Descs[61].Desc",
          "Cfg_PV_Descs[62].Desc",
          "Cfg_PV_Descs[63].Desc",
          "Cfg_PV_Descs[64].Desc",
          "ParameterInternalDescs[0].Desc",
          "ParameterInternalDescs[1].Desc",
          "ParameterInternalDescs[2].Desc",
          "ParameterInternalDescs[3].Desc",
          "ParameterInternalDescs[4].Desc",
          "ParameterInternalDescs[5].Desc",
          "ParameterInternalDescs[6].Desc",
          "ParameterInternalDescs[7].Desc",
          "ParameterInternalDescs[8].Desc",
          "ParameterInternalDescs[9].Desc",
          "ParameterInternalDescs[10].Desc",
          "ParameterInternalDescs[11].Desc",
          "ParameterInternalDescs[12].Desc",
          "ParameterInternalDescs[13].Desc",
          "ParameterInternalDescs[14].Desc",
          "ParameterInternalDescs[15].Desc",
          "ParameterInternalDescs[16].Desc",
          "ParameterInternalDescs[17].Desc",
          "ParameterInternalDescs[18].Desc",
          "ParameterInternalDescs[19].Desc",
          "ParameterInternalDescs[20].Desc",
          "ParameterInternalDescs[21].Desc",
          "ParameterInternalDescs[22].Desc",
          "ParameterInternalDescs[23].Desc",
          "ParameterInternalDescs[24].Desc",
          "ParameterInternalDescs[25].Desc",
          "ParameterInternalDescs[26].Desc",
          "ParameterInternalDescs[27].Desc",
          "ParameterInternalDescs[28].Desc",
          "ParameterInternalDescs[29].Desc",
          "ParameterInternalDescs[30].Desc",
          "ParameterInternalDescs[31].Desc",
          "ParameterInternalDescs[0].Unit",
          "ParameterInternalDescs[1].Unit",
          "ParameterInternalDescs[2].Unit",
          "ParameterInternalDescs[3].Unit",
          "ParameterInternalDescs[4].Unit",
          "ParameterInternalDescs[5].Unit",
          "ParameterInternalDescs[6].Unit",
          "ParameterInternalDescs[7].Unit",
          "ParameterInternalDescs[8].Unit",
          "ParameterInternalDescs[9].Unit",
          "ParameterInternalDescs[10].Unit",
          "ParameterInternalDescs[11].Unit",
          "ParameterInternalDescs[12].Unit",
          "ParameterInternalDescs[13].Unit",
          "ParameterInternalDescs[14].Unit",
          "ParameterInternalDescs[15].Unit",
          "ParameterInternalDescs[16].Unit",
          "ParameterInternalDescs[17].Unit",
          "ParameterInternalDescs[18].Unit",
          "ParameterInternalDescs[19].Unit",
          "ParameterInternalDescs[20].Unit",
          "ParameterInternalDescs[21].Unit",
          "ParameterInternalDescs[22].Unit",
          "ParameterInternalDescs[23].Unit",
          "ParameterInternalDescs[24].Unit",
          "ParameterInternalDescs[25].Unit",
          "ParameterInternalDescs[26].Unit",
          "ParameterInternalDescs[27].Unit",
          "ParameterInternalDescs[28].Unit",
          "ParameterInternalDescs[29].Unit",
          "ParameterInternalDescs[30].Unit",
          "ParameterInternalDescs[31].Unit",
          "ParameterInternalVals[0]",
          "ParameterInternalVals[1]",
          "ParameterInternalVals[2]",
          "ParameterInternalVals[3]",
          "ParameterInternalVals[4]",
          "ParameterInternalVals[5]",
          "ParameterInternalVals[6]",
          "ParameterInternalVals[7]",
          "ParameterInternalVals[8]",
          "ParameterInternalVals[9]",
          "ParameterInternalVals[10]",
          "ParameterInternalVals[11]",
          "ParameterInternalVals[12]",
          "ParameterInternalVals[13]",
          "ParameterInternalVals[14]",
          "ParameterInternalVals[15]",
          "ParameterInternalVals[16]",
          "ParameterInternalVals[17]",
          "ParameterInternalVals[18]",
          "ParameterInternalVals[19]",
          "ParameterInternalVals[20]",
          "ParameterInternalVals[21]",
          "ParameterInternalVals[22]",
          "ParameterInternalVals[23]",
          "ParameterInternalVals[24]",
          "ParameterInternalVals[25]",
          "ParameterInternalVals[26]",
          "ParameterInternalVals[27]",
          "ParameterInternalVals[28]",
          "ParameterInternalVals[29]",
          "ParameterInternalVals[30]",
          "ParameterInternalVals[31]"
        ]
      },
      {
        "sheetname": "AOI_EM_woValve",
        "columns": [
          "Controller",
          "ModuleTagName",
          "IntPSetOwnerRegister",
          "IntPCmdSPRegister",
          "ResetInputTagName",
          "Description",
          "CodeOverride",
          "CommentOverride",
          "Cfg_Tag",
          "Cfg_Label",
          "Cfg_Desc",
          "Inf_Lib",
          "Inf_Type",
          "Inp_Hand",
          "OCmd_SP",
          "PCmd_SP",
          "PSet_Owner",
          "Val_PV",
          "Val_Owner",
          "Val_Mode",
          "Inp_NotReadySP",
          "Inp_OvrdSP",
          "PCmd_Acq",
          "PCmd_rel",
          "Ocmd_reset",
          "Cfg_FaultAckReqd",
          "Cfg_FaultResetReqd",
          "Cfg_FaultSeverity",
          "Cfg_HasIOFaultAlm",
          "Cfg_IOFaultAckReqd",
          "Cfg_IOFaultResetReqd",
          "Cfg_IOFaultSeverity",
          "Cfg_Minimal_Step_Duration",
          "Cfg_ModeLockSubs",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_PVTableLowerLimit",
          "Cfg_PVTableUpperLimit",
          "Cfg_SPTableLowerLimit",
          "Cfg_SPTableUpperLimit",
          "Cfg_StateTableLowerLimit",
          "Cfg_StateTableUpperLimit",
          "pset_owner",
          "inp_notreadysp",
          "Fault.Cfg_Tag",
          "IOFault.Cfg_Tag",
          "Fault.Cfg_Cond",
          "IOFault.Cfg_Cond",
          "Cfg_States[0].Val",
          "Cfg_States[1].Val",
          "Cfg_States[2].Val",
          "Cfg_States[3].Val",
          "Cfg_States[4].Val",
          "Cfg_States[5].Val",
          "Cfg_States[6].Val",
          "Cfg_States[7].Val",
          "Cfg_States[8].Val",
          "Cfg_States[9].Val",
          "Cfg_States[10].Val",
          "Cfg_States[11].Val",
          "Cfg_States[12].Val",
          "Cfg_States[13].Val",
          "Cfg_States[14].Val",
          "Cfg_States[15].Val",
          "Cfg_States[16].Val",
          "Cfg_States[17].Val",
          "Cfg_States[18].Val",
          "Cfg_States[19].Val",
          "Cfg_States[20].Val",
          "Cfg_States[0].Desc",
          "Cfg_States[1].Desc",
          "Cfg_States[2].Desc",
          "Cfg_States[3].Desc",
          "Cfg_States[4].Desc",
          "Cfg_States[5].Desc",
          "Cfg_States[6].Desc",
          "Cfg_States[7].Desc",
          "Cfg_States[8].Desc",
          "Cfg_States[9].Desc",
          "Cfg_States[10].Desc",
          "Cfg_States[11].Desc",
          "Cfg_States[12].Desc",
          "Cfg_States[13].Desc",
          "Cfg_States[14].Desc",
          "Cfg_States[15].Desc",
          "Cfg_States[16].Desc",
          "Cfg_States[17].Desc",
          "Cfg_States[18].Desc",
          "Cfg_States[19].Desc",
          "Cfg_States[20].Desc",
          "Cfg_SP_Descs[0].Val",
          "Cfg_SP_Descs[1].Val",
          "Cfg_SP_Descs[2].Val",
          "Cfg_SP_Descs[3].Val",
          "Cfg_SP_Descs[4].Val",
          "Cfg_SP_Descs[5].Val",
          "Cfg_SP_Descs[6].Val",
          "Cfg_SP_Descs[7].Val",
          "Cfg_SP_Descs[8].Val",
          "Cfg_SP_Descs[9].Val",
          "Cfg_SP_Descs[10].Val",
          "Cfg_SP_Descs[11].Val",
          "Cfg_SP_Descs[12].Val",
          "Cfg_SP_Descs[13].Val",
          "Cfg_SP_Descs[14].Val",
          "Cfg_SP_Descs[15].Val",
          "Cfg_SP_Descs[16].Val",
          "Cfg_SP_Descs[17].Val",
          "Cfg_SP_Descs[18].Val",
          "Cfg_SP_Descs[19].Val",
          "Cfg_SP_Descs[20].Val",
          "Cfg_SP_Descs[21].Val",
          "Cfg_SP_Descs[22].Val",
          "Cfg_SP_Descs[23].Val",
          "Cfg_SP_Descs[24].Val",
          "Cfg_SP_Descs[25].Val",
          "Cfg_SP_Descs[26].Val",
          "Cfg_SP_Descs[27].Val",
          "Cfg_SP_Descs[28].Val",
          "Cfg_SP_Descs[29].Val",
          "Cfg_SP_Descs[30].Val",
          "Cfg_SP_Descs[31].Val",
          "Cfg_SP_Descs[32].Val",
          "Cfg_SP_Descs[33].Val",
          "Cfg_SP_Descs[34].Val",
          "Cfg_SP_Descs[35].Val",
          "Cfg_SP_Descs[36].Val",
          "Cfg_SP_Descs[37].Val",
          "Cfg_SP_Descs[38].Val",
          "Cfg_SP_Descs[39].Val",
          "Cfg_SP_Descs[40].Val",
          "Cfg_SP_Descs[41].Val",
          "Cfg_SP_Descs[42].Val",
          "Cfg_SP_Descs[43].Val",
          "Cfg_SP_Descs[44].Val",
          "Cfg_SP_Descs[45].Val",
          "Cfg_SP_Descs[46].Val",
          "Cfg_SP_Descs[47].Val",
          "Cfg_SP_Descs[48].Val",
          "Cfg_SP_Descs[49].Val",
          "Cfg_SP_Descs[50].Val",
          "Cfg_SP_Descs[51].Val",
          "Cfg_SP_Descs[52].Val",
          "Cfg_SP_Descs[53].Val",
          "Cfg_SP_Descs[54].Val",
          "Cfg_SP_Descs[55].Val",
          "Cfg_SP_Descs[56].Val",
          "Cfg_SP_Descs[57].Val",
          "Cfg_SP_Descs[58].Val",
          "Cfg_SP_Descs[59].Val",
          "Cfg_SP_Descs[60].Val",
          "Cfg_SP_Descs[61].Val",
          "Cfg_SP_Descs[62].Val",
          "Cfg_SP_Descs[63].Val",
          "Cfg_SP_Descs[64].Val",
          "Cfg_SP_Descs[0].Desc",
          "Cfg_SP_Descs[1].Desc",
          "Cfg_SP_Descs[2].Desc",
          "Cfg_SP_Descs[3].Desc",
          "Cfg_SP_Descs[4].Desc",
          "Cfg_SP_Descs[5].Desc",
          "Cfg_SP_Descs[6].Desc",
          "Cfg_SP_Descs[7].Desc",
          "Cfg_SP_Descs[8].Desc",
          "Cfg_SP_Descs[9].Desc",
          "Cfg_SP_Descs[10].Desc",
          "Cfg_SP_Descs[11].Desc",
          "Cfg_SP_Descs[12].Desc",
          "Cfg_SP_Descs[13].Desc",
          "Cfg_SP_Descs[14].Desc",
          "Cfg_SP_Descs[15].Desc",
          "Cfg_SP_Descs[16].Desc",
          "Cfg_SP_Descs[17].Desc",
          "Cfg_SP_Descs[18].Desc",
          "Cfg_SP_Descs[19].Desc",
          "Cfg_SP_Descs[20].Desc",
          "Cfg_SP_Descs[21].Desc",
          "Cfg_SP_Descs[22].Desc",
          "Cfg_SP_Descs[23].Desc",
          "Cfg_SP_Descs[24].Desc",
          "Cfg_SP_Descs[25].Desc",
          "Cfg_SP_Descs[26].Desc",
          "Cfg_SP_Descs[27].Desc",
          "Cfg_SP_Descs[28].Desc",
          "Cfg_SP_Descs[29].Desc",
          "Cfg_SP_Descs[30].Desc",
          "Cfg_SP_Descs[31].Desc",
          "Cfg_SP_Descs[32].Desc",
          "Cfg_SP_Descs[33].Desc",
          "Cfg_SP_Descs[34].Desc",
          "Cfg_SP_Descs[35].Desc",
          "Cfg_SP_Descs[36].Desc",
          "Cfg_SP_Descs[37].Desc",
          "Cfg_SP_Descs[38].Desc",
          "Cfg_SP_Descs[39].Desc",
          "Cfg_SP_Descs[40].Desc",
          "Cfg_SP_Descs[41].Desc",
          "Cfg_SP_Descs[42].Desc",
          "Cfg_SP_Descs[43].Desc",
          "Cfg_SP_Descs[44].Desc",
          "Cfg_SP_Descs[45].Desc",
          "Cfg_SP_Descs[46].Desc",
          "Cfg_SP_Descs[47].Desc",
          "Cfg_SP_Descs[48].Desc",
          "Cfg_SP_Descs[49].Desc",
          "Cfg_SP_Descs[50].Desc",
          "Cfg_SP_Descs[51].Desc",
          "Cfg_SP_Descs[52].Desc",
          "Cfg_SP_Descs[53].Desc",
          "Cfg_SP_Descs[54].Desc",
          "Cfg_SP_Descs[55].Desc",
          "Cfg_SP_Descs[56].Desc",
          "Cfg_SP_Descs[57].Desc",
          "Cfg_SP_Descs[58].Desc",
          "Cfg_SP_Descs[59].Desc",
          "Cfg_SP_Descs[60].Desc",
          "Cfg_SP_Descs[61].Desc",
          "Cfg_SP_Descs[62].Desc",
          "Cfg_SP_Descs[63].Desc",
          "Cfg_SP_Descs[64].Desc",
          "Cfg_PV_Descs[0].Val",
          "Cfg_PV_Descs[1].Val",
          "Cfg_PV_Descs[2].Val",
          "Cfg_PV_Descs[3].Val",
          "Cfg_PV_Descs[4].Val",
          "Cfg_PV_Descs[5].Val",
          "Cfg_PV_Descs[6].Val",
          "Cfg_PV_Descs[7].Val",
          "Cfg_PV_Descs[8].Val",
          "Cfg_PV_Descs[9].Val",
          "Cfg_PV_Descs[10].Val",
          "Cfg_PV_Descs[11].Val",
          "Cfg_PV_Descs[12].Val",
          "Cfg_PV_Descs[13].Val",
          "Cfg_PV_Descs[14].Val",
          "Cfg_PV_Descs[15].Val",
          "Cfg_PV_Descs[16].Val",
          "Cfg_PV_Descs[17].Val",
          "Cfg_PV_Descs[18].Val",
          "Cfg_PV_Descs[19].Val",
          "Cfg_PV_Descs[20].Val",
          "Cfg_PV_Descs[21].Val",
          "Cfg_PV_Descs[22].Val",
          "Cfg_PV_Descs[23].Val",
          "Cfg_PV_Descs[24].Val",
          "Cfg_PV_Descs[25].Val",
          "Cfg_PV_Descs[26].Val",
          "Cfg_PV_Descs[27].Val",
          "Cfg_PV_Descs[28].Val",
          "Cfg_PV_Descs[29].Val",
          "Cfg_PV_Descs[30].Val",
          "Cfg_PV_Descs[31].Val",
          "Cfg_PV_Descs[32].Val",
          "Cfg_PV_Descs[33].Val",
          "Cfg_PV_Descs[34].Val",
          "Cfg_PV_Descs[35].Val",
          "Cfg_PV_Descs[36].Val",
          "Cfg_PV_Descs[37].Val",
          "Cfg_PV_Descs[38].Val",
          "Cfg_PV_Descs[39].Val",
          "Cfg_PV_Descs[40].Val",
          "Cfg_PV_Descs[41].Val",
          "Cfg_PV_Descs[42].Val",
          "Cfg_PV_Descs[43].Val",
          "Cfg_PV_Descs[44].Val",
          "Cfg_PV_Descs[45].Val",
          "Cfg_PV_Descs[46].Val",
          "Cfg_PV_Descs[47].Val",
          "Cfg_PV_Descs[48].Val",
          "Cfg_PV_Descs[49].Val",
          "Cfg_PV_Descs[50].Val",
          "Cfg_PV_Descs[51].Val",
          "Cfg_PV_Descs[52].Val",
          "Cfg_PV_Descs[53].Val",
          "Cfg_PV_Descs[54].Val",
          "Cfg_PV_Descs[55].Val",
          "Cfg_PV_Descs[56].Val",
          "Cfg_PV_Descs[57].Val",
          "Cfg_PV_Descs[58].Val",
          "Cfg_PV_Descs[59].Val",
          "Cfg_PV_Descs[60].Val",
          "Cfg_PV_Descs[61].Val",
          "Cfg_PV_Descs[62].Val",
          "Cfg_PV_Descs[63].Val",
          "Cfg_PV_Descs[64].Val",
          "Cfg_PV_Descs[0].Desc",
          "Cfg_PV_Descs[1].Desc",
          "Cfg_PV_Descs[2].Desc",
          "Cfg_PV_Descs[3].Desc",
          "Cfg_PV_Descs[4].Desc",
          "Cfg_PV_Descs[5].Desc",
          "Cfg_PV_Descs[6].Desc",
          "Cfg_PV_Descs[7].Desc",
          "Cfg_PV_Descs[8].Desc",
          "Cfg_PV_Descs[9].Desc",
          "Cfg_PV_Descs[10].Desc",
          "Cfg_PV_Descs[11].Desc",
          "Cfg_PV_Descs[12].Desc",
          "Cfg_PV_Descs[13].Desc",
          "Cfg_PV_Descs[14].Desc",
          "Cfg_PV_Descs[15].Desc",
          "Cfg_PV_Descs[16].Desc",
          "Cfg_PV_Descs[17].Desc",
          "Cfg_PV_Descs[18].Desc",
          "Cfg_PV_Descs[19].Desc",
          "Cfg_PV_Descs[20].Desc",
          "Cfg_PV_Descs[21].Desc",
          "Cfg_PV_Descs[22].Desc",
          "Cfg_PV_Descs[23].Desc",
          "Cfg_PV_Descs[24].Desc",
          "Cfg_PV_Descs[25].Desc",
          "Cfg_PV_Descs[26].Desc",
          "Cfg_PV_Descs[27].Desc",
          "Cfg_PV_Descs[28].Desc",
          "Cfg_PV_Descs[29].Desc",
          "Cfg_PV_Descs[30].Desc",
          "Cfg_PV_Descs[31].Desc",
          "Cfg_PV_Descs[32].Desc",
          "Cfg_PV_Descs[33].Desc",
          "Cfg_PV_Descs[34].Desc",
          "Cfg_PV_Descs[35].Desc",
          "Cfg_PV_Descs[36].Desc",
          "Cfg_PV_Descs[37].Desc",
          "Cfg_PV_Descs[38].Desc",
          "Cfg_PV_Descs[39].Desc",
          "Cfg_PV_Descs[40].Desc",
          "Cfg_PV_Descs[41].Desc",
          "Cfg_PV_Descs[42].Desc",
          "Cfg_PV_Descs[43].Desc",
          "Cfg_PV_Descs[44].Desc",
          "Cfg_PV_Descs[45].Desc",
          "Cfg_PV_Descs[46].Desc",
          "Cfg_PV_Descs[47].Desc",
          "Cfg_PV_Descs[48].Desc",
          "Cfg_PV_Descs[49].Desc",
          "Cfg_PV_Descs[50].Desc",
          "Cfg_PV_Descs[51].Desc",
          "Cfg_PV_Descs[52].Desc",
          "Cfg_PV_Descs[53].Desc",
          "Cfg_PV_Descs[54].Desc",
          "Cfg_PV_Descs[55].Desc",
          "Cfg_PV_Descs[56].Desc",
          "Cfg_PV_Descs[57].Desc",
          "Cfg_PV_Descs[58].Desc",
          "Cfg_PV_Descs[59].Desc",
          "Cfg_PV_Descs[60].Desc",
          "Cfg_PV_Descs[61].Desc",
          "Cfg_PV_Descs[62].Desc",
          "Cfg_PV_Descs[63].Desc",
          "Cfg_PV_Descs[64].Desc",
          "ParameterInternalDescs[0].Desc",
          "ParameterInternalDescs[1].Desc",
          "ParameterInternalDescs[2].Desc",
          "ParameterInternalDescs[3].Desc",
          "ParameterInternalDescs[4].Desc",
          "ParameterInternalDescs[5].Desc",
          "ParameterInternalDescs[6].Desc",
          "ParameterInternalDescs[7].Desc",
          "ParameterInternalDescs[8].Desc",
          "ParameterInternalDescs[9].Desc",
          "ParameterInternalDescs[10].Desc",
          "ParameterInternalDescs[11].Desc",
          "ParameterInternalDescs[12].Desc",
          "ParameterInternalDescs[13].Desc",
          "ParameterInternalDescs[14].Desc",
          "ParameterInternalDescs[15].Desc",
          "ParameterInternalDescs[16].Desc",
          "ParameterInternalDescs[17].Desc",
          "ParameterInternalDescs[18].Desc",
          "ParameterInternalDescs[19].Desc",
          "ParameterInternalDescs[20].Desc",
          "ParameterInternalDescs[21].Desc",
          "ParameterInternalDescs[22].Desc",
          "ParameterInternalDescs[23].Desc",
          "ParameterInternalDescs[24].Desc",
          "ParameterInternalDescs[25].Desc",
          "ParameterInternalDescs[26].Desc",
          "ParameterInternalDescs[27].Desc",
          "ParameterInternalDescs[28].Desc",
          "ParameterInternalDescs[29].Desc",
          "ParameterInternalDescs[30].Desc",
          "ParameterInternalDescs[31].Desc",
          "ParameterInternalDescs[0].Unit",
          "ParameterInternalDescs[1].Unit",
          "ParameterInternalDescs[2].Unit",
          "ParameterInternalDescs[3].Unit",
          "ParameterInternalDescs[4].Unit",
          "ParameterInternalDescs[5].Unit",
          "ParameterInternalDescs[6].Unit",
          "ParameterInternalDescs[7].Unit",
          "ParameterInternalDescs[8].Unit",
          "ParameterInternalDescs[9].Unit",
          "ParameterInternalDescs[10].Unit",
          "ParameterInternalDescs[11].Unit",
          "ParameterInternalDescs[12].Unit",
          "ParameterInternalDescs[13].Unit",
          "ParameterInternalDescs[14].Unit",
          "ParameterInternalDescs[15].Unit",
          "ParameterInternalDescs[16].Unit",
          "ParameterInternalDescs[17].Unit",
          "ParameterInternalDescs[18].Unit",
          "ParameterInternalDescs[19].Unit",
          "ParameterInternalDescs[20].Unit",
          "ParameterInternalDescs[21].Unit",
          "ParameterInternalDescs[22].Unit",
          "ParameterInternalDescs[23].Unit",
          "ParameterInternalDescs[24].Unit",
          "ParameterInternalDescs[25].Unit",
          "ParameterInternalDescs[26].Unit",
          "ParameterInternalDescs[27].Unit",
          "ParameterInternalDescs[28].Unit",
          "ParameterInternalDescs[29].Unit",
          "ParameterInternalDescs[30].Unit",
          "ParameterInternalDescs[31].Unit",
          "ParameterInternalVals[0]",
          "ParameterInternalVals[1]",
          "ParameterInternalVals[2]",
          "ParameterInternalVals[3]",
          "ParameterInternalVals[4]",
          "ParameterInternalVals[5]",
          "ParameterInternalVals[6]",
          "ParameterInternalVals[7]",
          "ParameterInternalVals[8]",
          "ParameterInternalVals[9]",
          "ParameterInternalVals[10]",
          "ParameterInternalVals[11]",
          "ParameterInternalVals[12]",
          "ParameterInternalVals[13]",
          "ParameterInternalVals[14]",
          "ParameterInternalVals[15]",
          "ParameterInternalVals[16]",
          "ParameterInternalVals[17]",
          "ParameterInternalVals[18]",
          "ParameterInternalVals[19]",
          "ParameterInternalVals[20]",
          "ParameterInternalVals[21]",
          "ParameterInternalVals[22]",
          "ParameterInternalVals[23]",
          "ParameterInternalVals[24]",
          "ParameterInternalVals[25]",
          "ParameterInternalVals[26]",
          "ParameterInternalVals[27]",
          "ParameterInternalVals[28]",
          "ParameterInternalVals[29]",
          "ParameterInternalVals[30]",
          "ParameterInternalVals[31]"
        ]
      },
      {
        "sheetname": "AOI_Equip_Expiry",
        "columns": [
          "Controller",
          "ModuleTagName",
          "CodeOverride",
          "CommentOverride",
          "Description"
        ]
      },
      {
        "sheetname": "UDT_SystemStatus",
        "columns": [
          "Controller",
          "ModuleTagName",
          "CodeOverride",
          "CommentOverride",
          "Description"
        ]
      },
      {
        "sheetname": "AOI_Totalizer_Analog",
        "columns": [
          "Controller",
          "ModuleTagName",
          "InputValueTagName",
          "ResetInputTagName",
          "HasChannelIO",
          "CodeOverride",
          "CommentOverride",
          "Description"
        ]
      },
      {
        "sheetname": "AOI_ValveSO_EM",
        "columns": [
          "Controller",
          "ModuleTagName",
          "IntPSetOwnerRegister",
          "IntPCmdSPRegister",
          "ResetInputTagName",
          "Description",
          "CodeOverride",
          "CommentOverride",
          "Cfg_Tag",
          "Cfg_Label",
          "Cfg_Desc",
          "Inf_Lib",
          "Inf_Type",
          "Inp_Hand",
          "OCmd_SP",
          "PCmd_SP",
          "PSet_Owner",
          "Val_PV",
          "Val_Owner",
          "Val_Mode",
          "Inp_NotReadySP",
          "Inp_OvrdSP",
          "PCmd_Acq",
          "PCmd_rel",
          "Ocmd_reset",
          "Cfg_ValvesUsed",
          "Cfg_StateTableLowerLimit",
          "Cfg_StateTableUpperLimit",
          "Cfg_ModeLockSubs",
          "Cfg_AlignmentFaultT",
          "Cfg_FaultSPOnAlignmentFault",
          "Cfg_FaultSPOnValveFault",
          "Cfg_FaultSPOnIOFault",
          "Cfg_PCmdClear",
          "Cfg_ProgDefault",
          "Cfg_AlignmentFaultAckReqd",
          "Cfg_HasAlignmentFaultAlm",
          "Cfg_AlignmentFaultResetReqd",
          "Cfg_Step_Scan_Delay",
          "Cfg_Minimal_Step_Duration",
          "Cfg_AlignmentFaultSeverity",
          "Cfg_HasIOFaultAlm",
          "Cfg_IOFaultAckReqd",
          "Cfg_IOFaultResetReqd",
          "Cfg_IOFaultSeverity",
          "Cfg_ValveFaultAckReqd",
          "Cfg_HasValveFaultAlm",
          "Cfg_ValveFaultResetReqd",
          "Cfg_ValveFaultSeverity",
          "Cfg_TransitionTime",
          "Cfg_TransitionFaultAckReqd",
          "Cfg_HasTransitionFaultAlm",
          "Cfg_TransitionFaultResetReqd",
          "Cfg_TransitionFaultSeverity",
          "Cfg_TransitionFaultDelay",
          "Cfg_EnableTransitionControl",
          "Cfg_TransitionFaultAction",
          "Cfg_SPTableLowerLimit",
          "Cfg_SPTableUpperLimit",
          "TransitionFault.Cfg_Tag",
          "IOFault.Cfg_Tag",
          "Valve_EM.ValveFault.Cfg_Tag",
          "Valve_EM.AlignmentFault.Cfg_Tag",
          "TransitionFault.Cfg_Cond",
          "IOFault.Cfg_Cond",
          "Valve_EM.ValveFault.Cfg_Cond",
          "Valve_EM.AlignmentFault.Cfg_Cond",
          "SP_Map.Map[0]",
          "SP_Map.Map[1]",
          "SP_Map.Map[2]",
          "SP_Map.Map[3]",
          "SP_Map.Map[4]",
          "SP_Map.Map[5]",
          "SP_Map.Map[6]",
          "SP_Map.Map[7]",
          "SP_Map.Map[8]",
          "SP_Map.Map[9]",
          "SP_Map.Map[10]",
          "SP_Map.Map[11]",
          "SP_Map.Map[12]",
          "SP_Map.Map[13]",
          "SP_Map.Map[14]",
          "SP_Map.Map[15]",
          "SP_Map.Map[16]",
          "SP_Map.Map[17]",
          "SP_Map.Map[18]",
          "SP_Map.Map[19]",
          "SP_Map.Map[20]",
          "SP_Map.Map[21]",
          "SP_Map.Map[22]",
          "SP_Map.Map[23]",
          "SP_Map.Map[24]",
          "SP_Map.Map[25]",
          "SP_Map.Map[26]",
          "SP_Map.Map[27]",
          "SP_Map.Map[28]",
          "SP_Map.Map[29]",
          "SP_Map.Map[30]",
          "SP_Map.Map[31]",
          "SP_Map.Map[32]",
          "SP_Map.Map[33]",
          "SP_Map.Map[34]",
          "SP_Map.Map[35]",
          "SP_Map.Map[36]",
          "SP_Map.Map[37]",
          "SP_Map.Map[38]",
          "SP_Map.Map[39]",
          "SP_Map.Map[40]",
          "SP_Map.Map[41]",
          "SP_Map.Map[42]",
          "SP_Map.Map[43]",
          "SP_Map.Map[44]",
          "SP_Map.Map[45]",
          "SP_Map.Map[46]",
          "SP_Map.Map[47]",
          "SP_Map.Map[48]",
          "SP_Map.Map[49]",
          "SP_Map.Map[50]",
          "SP_Map.Map[51]",
          "SP_Map.Map[52]",
          "SP_Map.Map[53]",
          "SP_Map.Map[54]",
          "SP_Map.Map[55]",
          "SP_Map.Map[56]",
          "SP_Map.Map[57]",
          "SP_Map.Map[58]",
          "SP_Map.Map[59]",
          "SP_Map.Map[60]",
          "SP_Map.Map[61]",
          "SP_Map.Map[62]",
          "SP_Map.Map[63]",
          "SP_Map.Map[64]",
          "SP_Map.Map[65]",
          "SP_Map.Map[66]",
          "SP_Map.Map[67]",
          "SP_Map.Map[68]",
          "SP_Map.Map[69]",
          "SP_Map.Map[70]",
          "SP_Map.Map[71]",
          "SP_Map.Map[72]",
          "SP_Map.Map[73]",
          "SP_Map.Map[74]",
          "SP_Map.Map[75]",
          "SP_Map.Map[76]",
          "SP_Map.Map[77]",
          "SP_Map.Map[78]",
          "SP_Map.Map[79]",
          "SP_Map.Map[80]",
          "SP_Map.Map[81]",
          "SP_Map.Map[82]",
          "SP_Map.Map[83]",
          "SP_Map.Map[84]",
          "SP_Map.Map[85]",
          "SP_Map.Map[86]",
          "SP_Map.Map[87]",
          "SP_Map.Map[88]",
          "SP_Map.Map[89]",
          "SP_Map.Map[90]",
          "SP_Map.Map[91]",
          "SP_Map.Map[92]",
          "SP_Map.Map[93]",
          "SP_Map.Map[94]",
          "SP_Map.Map[95]",
          "SP_Map.Map[96]",
          "SP_Map.Map[97]",
          "SP_Map.Map[98]",
          "SP_Map.Map[99]",
          "SP_Map.Map[100]",
          "SP_Map.Map[101]",
          "SP_Map.Map[102]",
          "SP_Map.Map[103]",
          "SP_Map.Map[104]",
          "SP_Map.Map[105]",
          "SP_Map.Map[106]",
          "SP_Map.Map[107]",
          "SP_Map.Map[108]",
          "SP_Map.Map[109]",
          "SP_Map.Map[110]",
          "SP_Map.Map[111]",
          "SP_Map.Map[112]",
          "SP_Map.Map[113]",
          "SP_Map.Map[114]",
          "SP_Map.Map[115]",
          "SP_Map.Map[116]",
          "SP_Map.Map[117]",
          "SP_Map.Map[118]",
          "SP_Map.Map[119]",
          "SP_Map.Map[120]",
          "SP_Map.Desc[0]",
          "SP_Map.Desc[1]",
          "SP_Map.Desc[2]",
          "SP_Map.Desc[3]",
          "SP_Map.Desc[4]",
          "SP_Map.Desc[5]",
          "SP_Map.Desc[6]",
          "SP_Map.Desc[7]",
          "SP_Map.Desc[8]",
          "SP_Map.Desc[9]",
          "SP_Map.Desc[10]",
          "SP_Map.Desc[11]",
          "SP_Map.Desc[12]",
          "SP_Map.Desc[13]",
          "SP_Map.Desc[14]",
          "SP_Map.Desc[15]",
          "SP_Map.Desc[16]",
          "SP_Map.Desc[17]",
          "SP_Map.Desc[18]",
          "SP_Map.Desc[19]",
          "SP_Map.Desc[20]",
          "SP_Map.Desc[21]",
          "SP_Map.Desc[22]",
          "SP_Map.Desc[23]",
          "SP_Map.Desc[24]",
          "SP_Map.Desc[25]",
          "SP_Map.Desc[26]",
          "SP_Map.Desc[27]",
          "SP_Map.Desc[28]",
          "SP_Map.Desc[29]",
          "SP_Map.Desc[30]",
          "SP_Map.Desc[31]",
          "SP_Map.Desc[32]",
          "SP_Map.Desc[33]",
          "SP_Map.Desc[34]",
          "SP_Map.Desc[35]",
          "SP_Map.Desc[36]",
          "SP_Map.Desc[37]",
          "SP_Map.Desc[38]",
          "SP_Map.Desc[39]",
          "SP_Map.Desc[40]",
          "SP_Map.Desc[41]",
          "SP_Map.Desc[42]",
          "SP_Map.Desc[43]",
          "SP_Map.Desc[44]",
          "SP_Map.Desc[45]",
          "SP_Map.Desc[46]",
          "SP_Map.Desc[47]",
          "SP_Map.Desc[48]",
          "SP_Map.Desc[49]",
          "SP_Map.Desc[50]",
          "SP_Map.Desc[51]",
          "SP_Map.Desc[52]",
          "SP_Map.Desc[53]",
          "SP_Map.Desc[54]",
          "SP_Map.Desc[55]",
          "SP_Map.Desc[56]",
          "SP_Map.Desc[57]",
          "SP_Map.Desc[58]",
          "SP_Map.Desc[59]",
          "SP_Map.Desc[60]",
          "SP_Map.Desc[61]",
          "SP_Map.Desc[62]",
          "SP_Map.Desc[63]",
          "SP_Map.Desc[64]",
          "SP_Map.Desc[65]",
          "SP_Map.Desc[66]",
          "SP_Map.Desc[67]",
          "SP_Map.Desc[68]",
          "SP_Map.Desc[69]",
          "SP_Map.Desc[70]",
          "SP_Map.Desc[71]",
          "Cfg_ValveTxt[0]",
          "Cfg_ValveTxt[1]",
          "Cfg_ValveTxt[2]",
          "Cfg_ValveTxt[3]",
          "Cfg_ValveTxt[4]",
          "Cfg_ValveTxt[5]",
          "Cfg_ValveTxt[6]",
          "Cfg_ValveTxt[7]",
          "Cfg_ValveTxt[8]",
          "Cfg_ValveTxt[9]",
          "Cfg_ValveTxt[10]",
          "Cfg_ValveTxt[11]",
          "Cfg_ValveTxt[12]",
          "Cfg_ValveTxt[13]",
          "Cfg_ValveTxt[14]",
          "Cfg_ValveTxt[15]",
          "Cfg_ValveTxt[16]",
          "Cfg_ValveTxt[17]",
          "Cfg_ValveTxt[18]",
          "Cfg_ValveTxt[19]",
          "Cfg_ValveTxt[20]",
          "Cfg_ValveTxt[21]",
          "Cfg_ValveTxt[22]",
          "Cfg_ValveTxt[23]",
          "Cfg_ValveTxt[24]",
          "Cfg_ValveTxt[25]",
          "Cfg_ValveTxt[26]",
          "Cfg_ValveTxt[27]",
          "Cfg_ValveTxt[28]",
          "Cfg_ValveTxt[29]",
          "Cfg_ValveTxt[30]",
          "Cfg_ValveTxt[31]",
          "Valve_1",
          "Valve_2",
          "Valve_3",
          "Valve_4",
          "Valve_5",
          "Valve_6",
          "Valve_7",
          "Valve_8",
          "Valve_9",
          "Valve_10",
          "Valve_11",
          "Valve_12",
          "Valve_13",
          "Valve_14",
          "Valve_15",
          "Valve_16",
          "Valve_17",
          "Valve_18",
          "Valve_19",
          "Valve_20",
          "Valve_21",
          "Valve_22",
          "Valve_23",
          "Valve_24",
          "Valve_25",
          "Valve_26",
          "Valve_27",
          "Valve_28",
          "Valve_29",
          "Valve_30",
          "Valve_31",
          "Valve_32",
          "Cfg_PulsingMap[0]",
          "Cfg_PulsingMap[1]",
          "Cfg_PulsingMap[2]",
          "Cfg_PulsingMap[3]",
          "Cfg_PulsingMap[4]",
          "Cfg_PulsingMap[5]",
          "Cfg_PulsingMap[6]",
          "Cfg_PulsingMap[7]",
          "Cfg_PulsingMap[8]",
          "Cfg_PulsingMap[9]",
          "Cfg_PulsingMap[10]",
          "Cfg_PulsingMap[11]",
          "Cfg_PulsingMap[12]",
          "Cfg_PulsingMap[13]",
          "Cfg_PulsingMap[14]",
          "Cfg_PulsingMap[15]",
          "Cfg_PulsingMap[16]",
          "Cfg_PulsingMap[17]",
          "Cfg_PulsingMap[18]",
          "Cfg_PulsingMap[19]",
          "Cfg_PulsingMap[20]",
          "Cfg_PulsingMap[21]",
          "Cfg_PulsingMap[22]",
          "Cfg_PulsingMap[23]",
          "Cfg_PulsingMap[24]",
          "Cfg_PulsingMap[25]",
          "Cfg_PulsingMap[26]",
          "Cfg_PulsingMap[27]",
          "Cfg_PulsingMap[28]",
          "Cfg_PulsingMap[29]",
          "Cfg_PulsingMap[30]",
          "Cfg_PulsingMap[31]",
          "Cfg_PulsingMap[32]",
          "Cfg_PulsingMap[33]",
          "Cfg_PulsingMap[34]",
          "Cfg_PulsingMap[35]",
          "Cfg_PulsingMap[36]",
          "Cfg_PulsingMap[37]",
          "Cfg_PulsingMap[38]",
          "Cfg_PulsingMap[39]",
          "Cfg_PulsingMap[40]",
          "Cfg_PulsingMap[41]",
          "Cfg_PulsingMap[42]",
          "Cfg_PulsingMap[43]",
          "Cfg_PulsingMap[44]",
          "Cfg_PulsingMap[45]",
          "Cfg_PulsingMap[46]",
          "Cfg_PulsingMap[47]",
          "Cfg_PulsingMap[48]",
          "Cfg_PulsingMap[49]",
          "Cfg_PulsingMap[50]",
          "Cfg_PulsingMap[51]",
          "Cfg_PulsingMap[52]",
          "Cfg_PulsingMap[53]",
          "Cfg_PulsingMap[54]",
          "Cfg_PulsingMap[55]",
          "Cfg_PulsingMap[56]",
          "Cfg_PulsingMap[57]",
          "Cfg_PulsingMap[58]",
          "Cfg_PulsingMap[59]",
          "Cfg_PulsingMap[60]",
          "Cfg_PulsingMap[61]",
          "Cfg_PulsingMap[62]",
          "Cfg_PulsingMap[63]",
          "Cfg_PulsingMap[64]",
          "Cfg_PulsingMap[65]",
          "Cfg_PulsingMap[66]",
          "Cfg_PulsingMap[67]",
          "Cfg_PulsingMap[68]",
          "Cfg_PulsingMap[69]",
          "Cfg_PulsingMap[70]",
          "Cfg_PulsingMap[71]",
          "Cfg_PulsingMap[72]",
          "Cfg_PulsingMap[73]",
          "Cfg_PulsingMap[74]",
          "Cfg_PulsingMap[75]",
          "Cfg_PulsingMap[76]",
          "Cfg_PulsingMap[77]",
          "Cfg_PulsingMap[78]",
          "Cfg_PulsingMap[79]",
          "Cfg_PulsingMap[80]",
          "Cfg_PulsingMap[81]",
          "Cfg_PulsingMap[82]",
          "Cfg_PulsingMap[83]",
          "Cfg_PulsingMap[84]",
          "Cfg_PulsingMap[85]",
          "Cfg_PulsingMap[86]",
          "Cfg_PulsingMap[87]",
          "Cfg_PulsingMap[88]",
          "Cfg_PulsingMap[89]",
          "Cfg_PulsingMap[90]",
          "Cfg_PulsingMap[91]",
          "Cfg_PulsingMap[92]",
          "Cfg_PulsingMap[93]",
          "Cfg_PulsingMap[94]",
          "Cfg_PulsingMap[95]",
          "Cfg_PulsingMap[96]",
          "Cfg_PulsingMap[97]",
          "Cfg_PulsingMap[98]",
          "Cfg_PulsingMap[99]",
          "Cfg_PulsingMap[100]",
          "Cfg_PulsingMap[101]",
          "Cfg_PulsingMap[102]",
          "Cfg_PulsingMap[103]",
          "Cfg_PulsingMap[104]",
          "Cfg_PulsingMap[105]",
          "Cfg_PulsingMap[106]",
          "Cfg_PulsingMap[107]",
          "Cfg_PulsingMap[108]",
          "Cfg_PulsingMap[109]",
          "Cfg_PulsingMap[110]",
          "Cfg_PulsingMap[111]",
          "Cfg_PulsingMap[112]",
          "Cfg_PulsingMap[113]",
          "Cfg_PulsingMap[114]",
          "Cfg_PulsingMap[115]",
          "Cfg_PulsingMap[116]",
          "Cfg_PulsingMap[117]",
          "Cfg_PulsingMap[118]",
          "Cfg_PulsingMap[119]",
          "Cfg_PulsingMap[120]",
          "Cfg_PulsingMap[121]",
          "Cfg_PulsingMap[122]",
          "Cfg_PulsingMap[123]",
          "Cfg_PulsingMap[124]",
          "Cfg_PulsingMap[125]",
          "Cfg_PulsingMap[126]",
          "Cfg_PulsingMap[127]",
          "Cfg_PulsingMap[128]",
          "Cfg_PulsingMap[129]",
          "Cfg_ValvePulseOffPreset[0]",
          "Cfg_ValvePulseOffPreset[1]",
          "Cfg_ValvePulseOffPreset[2]",
          "Cfg_ValvePulseOffPreset[3]",
          "Cfg_ValvePulseOffPreset[4]",
          "Cfg_ValvePulseOffPreset[5]",
          "Cfg_ValvePulseOffPreset[6]",
          "Cfg_ValvePulseOffPreset[7]",
          "Cfg_ValvePulseOffPreset[8]",
          "Cfg_ValvePulseOffPreset[9]",
          "Cfg_ValvePulseOffPreset[10]",
          "Cfg_ValvePulseOffPreset[11]",
          "Cfg_ValvePulseOffPreset[12]",
          "Cfg_ValvePulseOffPreset[13]",
          "Cfg_ValvePulseOffPreset[14]",
          "Cfg_ValvePulseOffPreset[15]",
          "Cfg_ValvePulseOffPreset[16]",
          "Cfg_ValvePulseOffPreset[17]",
          "Cfg_ValvePulseOffPreset[18]",
          "Cfg_ValvePulseOffPreset[19]",
          "Cfg_ValvePulseOffPreset[20]",
          "Cfg_ValvePulseOffPreset[21]",
          "Cfg_ValvePulseOffPreset[22]",
          "Cfg_ValvePulseOffPreset[23]",
          "Cfg_ValvePulseOffPreset[24]",
          "Cfg_ValvePulseOffPreset[25]",
          "Cfg_ValvePulseOffPreset[26]",
          "Cfg_ValvePulseOffPreset[27]",
          "Cfg_ValvePulseOffPreset[28]",
          "Cfg_ValvePulseOffPreset[29]",
          "Cfg_ValvePulseOffPreset[30]",
          "Cfg_ValvePulseOffPreset[31]",
          "Cfg_ValvePulseOnPreset[0]",
          "Cfg_ValvePulseOnPreset[1]",
          "Cfg_ValvePulseOnPreset[2]",
          "Cfg_ValvePulseOnPreset[3]",
          "Cfg_ValvePulseOnPreset[4]",
          "Cfg_ValvePulseOnPreset[5]",
          "Cfg_ValvePulseOnPreset[6]",
          "Cfg_ValvePulseOnPreset[7]",
          "Cfg_ValvePulseOnPreset[8]",
          "Cfg_ValvePulseOnPreset[9]",
          "Cfg_ValvePulseOnPreset[10]",
          "Cfg_ValvePulseOnPreset[11]",
          "Cfg_ValvePulseOnPreset[12]",
          "Cfg_ValvePulseOnPreset[13]",
          "Cfg_ValvePulseOnPreset[14]",
          "Cfg_ValvePulseOnPreset[15]",
          "Cfg_ValvePulseOnPreset[16]",
          "Cfg_ValvePulseOnPreset[17]",
          "Cfg_ValvePulseOnPreset[18]",
          "Cfg_ValvePulseOnPreset[19]",
          "Cfg_ValvePulseOnPreset[20]",
          "Cfg_ValvePulseOnPreset[21]",
          "Cfg_ValvePulseOnPreset[22]",
          "Cfg_ValvePulseOnPreset[23]",
          "Cfg_ValvePulseOnPreset[24]",
          "Cfg_ValvePulseOnPreset[25]",
          "Cfg_ValvePulseOnPreset[26]",
          "Cfg_ValvePulseOnPreset[27]",
          "Cfg_ValvePulseOnPreset[28]",
          "Cfg_ValvePulseOnPreset[29]",
          "Cfg_ValvePulseOnPreset[30]",
          "Cfg_ValvePulseOnPreset[31]"
        ]
      },
      {
        "sheetname": "SP Table",
        "columns": [
          "Row #",
          "EM Name",
          "SP Text",
          "SP",
          "Valve Alignment",
          "V1",
          "V2",
          "V3",
          "V4",
          "V5",
          "V6",
          "V7",
          "V8",
          "V9",
          "V10",
          "V11",
          "V12",
          "V13",
          "V14",
          "V15",
          "V16",
          "V17",
          "V18",
          "V19",
          "V20",
          "V21",
          "V22",
          "V23",
          "V24",
          "V25",
          "V26",
          "V27",
          "V28",
          "V29",
          "V30",
          "V31",
          "V32"
        ]
      },
      {
        "sheetname": "Alignment Lookup",
        "columns": [
          "Row #",
          "EM Name",
          "SP",
          "Lookup",
          "Valve Alignment",
          "V1",
          "V2",
          "V3",
          "V4",
          "V5",
          "V6",
          "V7",
          "V8",
          "V9",
          "V10",
          "V11",
          "V12",
          "V13",
          "V14",
          "V15",
          "V16",
          "V17",
          "V18",
          "V19",
          "V20",
          "V21",
          "V22",
          "V23",
          "V24",
          "V25",
          "V26",
          "V27",
          "V28",
          "V29",
          "V30",
          "V31",
          "V32",
          "",
          ""
        ]
      }
    ],
    "x": 230,
    "y": 60,
    "wires": [
      [
        "a06bae25.22a8e"
      ]
    ]
  },
  {
    "id": "cc1a61ec.b5fab",
    "type": "upload_file",
    "z": "55ffc120.e954e",
    "filename": "",
    "name": "",
    "overwriteFile": "true",
    "x": 3080,
    "y": 460,
    "wires": [
      [
        "7b848287.db07ec"
      ]
    ]
  },
  {
    "id": "8a2d8016.aaf89",
    "type": "upload_file",
    "z": "55ffc120.e954e",
    "filename": "",
    "name": "",
    "overwriteFile": "true",
    "x": 2600,
    "y": 900,
    "wires": [
      [
        "18e35a5a.36e9d6"
      ]
    ]
  },
  {
    "id": "7b848287.db07ec",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "false",
    "x": 3290,
    "y": 460,
    "wires": []
  },
  {
    "id": "18e35a5a.36e9d6",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "false",
    "x": 2790,
    "y": 900,
    "wires": []
  },
  {
    "id": "b7bde630.5f8b38",
    "type": "inject",
    "z": "98969df7.44714",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 200,
    "y": 700,
    "wires": [
      [
        "46db6951.328968"
      ]
    ]
  },
  {
    "id": "46db6951.328968",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Debug: Main Flow Trigger",
    "links": [
      "675544fc.50165c",
      "5b6ecc0c.75e654"
    ],
    "x": 295,
    "y": 700,
    "wires": []
  },
  {
    "id": "fec30326.655e8",
    "type": "comment",
    "z": "98969df7.44714",
    "name": "Main Trigger",
    "info": "",
    "x": 190,
    "y": 660,
    "wires": []
  },
  {
    "id": "e7a7bd9a.9153",
    "type": "inject",
    "z": "98969df7.44714",
    "name": "",
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "repeat": "",
    "crontab": "",
    "once": false,
    "x": 200,
    "y": 740,
    "wires": [
      [
        "9ebab669.df0c38"
      ]
    ]
  },
  {
    "id": "9ebab669.df0c38",
    "type": "link out",
    "z": "98969df7.44714",
    "name": "Debug: Pull Log Messages",
    "links": [
      "dec8cf72.04cdc",
      "7d617be9.22d264",
      "964722e6.6e518"
    ],
    "x": 295,
    "y": 740,
    "wires": []
  },
  {
    "id": "ca525e4a.4cc8",
    "type": "function",
    "z": "98969df7.44714",
    "name": "DistinctControllers",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getUniqueKeyValues = global.get(\"getUniqueKeyValues\");                  //function (objectArray, uniqueKeyAttrirbuteNamesArray)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Distinct Controllers\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Get the list of unique keys\nmsg.payload = {\"DistinctControllers\" : getUniqueKeyValues(msg.payload.Modules, [\"Controller\"])};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 887,
    "y": 660,
    "wires": [
      [
        "8ae0eacf.4914c8",
        "99043372.0995e"
      ]
    ]
  },
  {
    "id": "337de026.47238",
    "type": "ui_button",
    "z": "cc0e7210.bd493",
    "name": "",
    "group": "ad66aa50.9454c8",
    "order": 0,
    "width": 0,
    "height": 0,
    "label": "Start",
    "color": "",
    "icon": "",
    "payload": "",
    "payloadType": "str",
    "topic": "",
    "x": 230,
    "y": 160,
    "wires": [
      [
        "cf71d026.33f78"
      ]
    ]
  },
  {
    "id": "ad0e4625.3beee8",
    "type": "ui_button",
    "z": "cc0e7210.bd493",
    "name": "",
    "group": "ad66aa50.9454c8",
    "order": 0,
    "width": 0,
    "height": 0,
    "label": "Logs",
    "color": "",
    "icon": "",
    "payload": "",
    "payloadType": "str",
    "topic": "",
    "x": 230,
    "y": 580,
    "wires": [
      [
        "cfc4662e.a94a68"
      ]
    ]
  },
  {
    "id": "ea32414d.8ccf4",
    "type": "ui_template",
    "z": "cc0e7210.bd493",
    "group": "ad66aa50.9454c8",
    "name": "",
    "order": 0,
    "width": "0",
    "height": "0",
    "format": "<style>\n    {{msg.style}}\n</style>\n\n<p>{{msg.log.length}} log messages</p>\n\n<table>\n  <tr ng-repeat=\"record in msg.log\">\n        <td width=50>{{record.eventIdx}}</td>\n        <td width=200>{{record.timestamp}}</td>\n        <td>{{record.messageType}}</td>\n        <td>{{record.messageToLog}}</td>\n        <td>{{record.mainCallStackLevel}}</td>\n        <td>{{record.thisCallStackLevel}}</td>\n  </tr>\n</table>",
    "storeOutMessages": false,
    "fwdInMessages": true,
    "x": 1100,
    "y": 460,
    "wires": [
      []
    ]
  },
  {
    "id": "ef24fc23.62ad3",
    "type": "template",
    "z": "cc0e7210.bd493",
    "name": "css",
    "field": "style",
    "fieldType": "msg",
    "format": "css",
    "syntax": "mustache",
    "template": "table {\n    color: #333;\n    font-family: Helvetica, Arial, sans-serif;\n    width: 80%;\n    border-collapse: collapse;\n    border-spacing: 0;\n}\ntd, th {\n    border: 1px solid transparent;\n    /* No more visible border */\n    height: 30px;\n    transition: all 0.3s;\n    /* Simple transition for hover effect */\n}\nth {\n    background: #DFDFDF;\n    /* Darken header a bit */\n    font-weight: bold;\n}\ntd {\n    background: #FAFAFA;\n    text-align: left;\n}\n\n/* Cells in even rows (2,4,6...) are one color */\n\ntr:nth-child(even) td {\n    background: #F1F1F1;\n}\n\n/* Cells in odd rows (1,3,5...) are another (excludes header cells)  */\n\ntr:nth-child(odd) td {\n    background: #FEFEFE;\n}\ntr td:hover {\n    background: #666;\n    color: #FFF;\n}\n\n/* Hover cell effect! */",
    "x": 830,
    "y": 460,
    "wires": [
      [
        "ea32414d.8ccf4"
      ]
    ]
  },
  {
    "id": "ab2f4026.52a5e",
    "type": "function",
    "z": "98969df7.44714",
    "name": "DistinctResolvedTasks",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getUniqueKeyValues = global.get(\"getUniqueKeyValues\");                  //function (objectArray, uniqueKeyAttrirbuteNamesArray)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Distinct Resolved Tasks\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Get the list of unique keys\nmsg.payload = {\"DistinctResolvedTasks\" : getUniqueKeyValues(msg.payload.Modules, [\"Controller\", \"ResolvedTask\"])};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 897,
    "y": 720,
    "wires": [
      [
        "8ae0eacf.4914c8",
        "e4601aa8.eaf6c8"
      ]
    ]
  },
  {
    "id": "1279128b.cec9fd",
    "type": "function",
    "z": "98969df7.44714",
    "name": "DistinctDistinctResolvedPrograms",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getUniqueKeyValues = global.get(\"getUniqueKeyValues\");                  //function (objectArray, uniqueKeyAttrirbuteNamesArray)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Distinct Resolved Programs\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Get the list of unique keys\nmsg.payload = {\"DistinctResolvedPrograms\" : getUniqueKeyValues(msg.payload.Modules, [\"Controller\", \"ResolvedTask\", \"ResolvedProgram\"])};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 940,
    "y": 780,
    "wires": [
      [
        "8ae0eacf.4914c8",
        "bb9b326c.ffa1f"
      ]
    ]
  },
  {
    "id": "c54ddd45.b6ceb",
    "type": "function",
    "z": "98969df7.44714",
    "name": "DistinctResolvedRoutines",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getUniqueKeyValues = global.get(\"getUniqueKeyValues\");                  //function (objectArray, uniqueKeyAttrirbuteNamesArray)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Distinct Resolved Routines\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Get the list of unique keys\nmsg.payload = {\"DistinctResolvedRoutines\" : getUniqueKeyValues(msg.payload.Modules, [\"Controller\", \"ResolvedTask\", \"ResolvedProgram\", \"ResolvedRoutine\"])};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 910,
    "y": 840,
    "wires": [
      [
        "8ae0eacf.4914c8",
        "5f3d6512.ce510c"
      ]
    ]
  },
  {
    "id": "26649d2f.14a352",
    "type": "function",
    "z": "98969df7.44714",
    "name": "DistinctModules",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getUniqueKeyValues = global.get(\"getUniqueKeyValues\");                  //function (objectArray, uniqueKeyAttrirbuteNamesArray)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Distinct Modules\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Get the list of unique keys\nmsg.payload = {\"DistinctModules\" : getUniqueKeyValues(msg.payload.Modules, [\"Controller\", \"ModuleTagName\"])};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 877,
    "y": 900,
    "wires": [
      [
        "4420f2a4.4d3cec",
        "8ae0eacf.4914c8"
      ]
    ]
  },
  {
    "id": "c2bfe4c5.0f9638",
    "type": "function",
    "z": "98969df7.44714",
    "name": "DistinctClassNames",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\nvar getUniqueKeyValues = global.get(\"getUniqueKeyValues\");                  //function (objectArray, uniqueKeyAttrirbuteNamesArray)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Get Distinct Class Names\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n// Get the list of unique keys\nmsg.payload = {\"DistinctClassNames\" : getUniqueKeyValues(msg.payload.Modules, [\"ClassName\"])};\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 897,
    "y": 960,
    "wires": [
      [
        "6163be73.07b9",
        "8ae0eacf.4914c8"
      ]
    ]
  },
  {
    "id": "9703302b.1f5a5",
    "type": "debug",
    "z": "55ffc120.e954e",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "true",
    "x": 3084,
    "y": 373,
    "wires": []
  },
  {
    "id": "da32e613.2b8698",
    "type": "upload_file",
    "z": "cc0e7210.bd493",
    "filename": "validationErrors.txt",
    "name": "",
    "overwriteFile": "true",
    "x": 1160,
    "y": 580,
    "wires": [
      []
    ]
  },
  {
    "id": "f43e7d6d.c4335",
    "type": "upload_file",
    "z": "cc0e7210.bd493",
    "filename": "log.txt",
    "name": "",
    "overwriteFile": "true",
    "x": 1120,
    "y": 500,
    "wires": [
      [
        "91796dee.0a5ec"
      ]
    ]
  },
  {
    "id": "4e0f5f5f.a4f48",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1670,
    "y": 400,
    "wires": []
  },
  {
    "id": "3ec1f0ad.e0ee5",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1670,
    "y": 300,
    "wires": []
  },
  {
    "id": "5e897515.9394dc",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1670,
    "y": 180,
    "wires": []
  },
  {
    "id": "67b612ee.1dadbc",
    "type": "debug",
    "z": "98969df7.44714",
    "name": "",
    "active": false,
    "console": "false",
    "complete": "payload",
    "x": 1850,
    "y": 300,
    "wires": []
  },
  {
    "id": "1005b40d.f5c25c",
    "type": "upload_file",
    "z": "98969df7.44714",
    "filename": "AllDatasets.json",
    "name": "",
    "overwriteFile": "true",
    "x": 1950,
    "y": 720,
    "wires": [
      []
    ]
  },
  {
    "id": "91796dee.0a5ec",
    "type": "template",
    "z": "cc0e7210.bd493",
    "name": "Logs Dumped",
    "field": "payload",
    "fieldType": "msg",
    "format": "handlebars",
    "syntax": "mustache",
    "template": "Logs Dumped",
    "x": 1360,
    "y": 500,
    "wires": [
      [
        "775a9a19.552c64"
      ]
    ]
  },
  {
    "id": "775a9a19.552c64",
    "type": "debug",
    "z": "cc0e7210.bd493",
    "name": "",
    "active": true,
    "console": "false",
    "complete": "payload",
    "x": 1390,
    "y": 540,
    "wires": []
  },
  {
    "id": "4761c34e.e193dc",
    "type": "function",
    "z": "cacb891a.58e9d8",
    "name": "Process for Missing Data",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Process for Missing Data: Class Definitions\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*\n* This function block parses incoming tabular datasets to homogenize the object attributes to always contain the same set of values.\n*   example: {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\"}, {\"a\":\"1\", \"c\":\"3\"}, {\"b\":\"2\", \"c\":\"3\"}]}  \n*               -->  {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\", \"c\":null}, {\"a\":\"1\", \"b\":null, \"c\":\"3\"}, {\"a\":null, \"b\":\"2\", \"c\":\"3\"}]}\n* \n* This function also replaces empty strings with null.\n*   example: {\"SomeDataset\":[{\"a\":\"\", \"b\":\"2\"}, {\"a\":\"1\", \"b\":\"\"}]}\n*               -->  {\"SomeDataset\":[{\"a\":null, \"b\":\"2\"}, {\"a\":\"1\", \"b\":null}]}\n*/\n\n// Get list of datasets in this paylod\nvar datasetNames = Object.keys(msg.payload);\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"msg.paylod contains \" + datasetNames.length.toString() + \" dataset objects.\");\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var ds = 0; ds < datasetNames.length; ds++){\n    // Cache a reference to the current dataset\n    var thisDataset = msg.payload[datasetNames[ds]];\n    \n    /******************************************************************\n     * Pass 1: List of Unique Column Names & Fix Existing Data Issues *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 1 ***\");\n    \n    // Default the header array\n    var UniqueColumnNames = [];\n    \n    // Iterate over the records in the current dataset\n    var r = 0;\n    while (r < thisDataset.length){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        var allItemsAreNull = true;\n        for (var c = 0; c < thisRecordColumnNames.length; c++){\n            var thisColumnName = thisRecordColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            logDebugMessage(thisCallStackLevel, \"       Value = (\" + thisRecord[thisColumnName].toString() + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (UniqueColumnNames.indexOf(thisColumnName) === -1) {\n                UniqueColumnNames.push(thisColumnName);\n            }\n            \n            // Parse existing attribute data to fix invalid values\n            if (thisRecord[thisColumnName] === \"\") {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Replaced blank with null!\");\n                thisRecord[thisColumnName] = null;      // Replace empty strings (\"\") with null\n            }\n            \n            // If all cells up to this one in this row are null, check if the current cell is null\n            if (allItemsAreNull) {\n                if (thisRecord[thisColumnName] !== null) {\n                    allItemsAreNull = false;\n                }\n            }\n        }\n        \n        // If this row is all nulls, remove it, else move on\n        // Note: This is ONLY valid to do in the first pass iteration because missing colummns are added as nulls in pass 2\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        //      array.splice(start, deleteCount)\n        if (allItemsAreNull) {\n            thisDataset.splice(r, 1);\n        }\n        else {\n            // Increment the row pointer\n            r++;\n        }\n    }\n    \n    /******************************************************************\n     * Pass 2: Add Attributes for Missing Columns                     *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 2 ***\");\n    \n    // Iterate over the records in the current dataset\n    for (var r = 0; r < thisDataset.length; r++){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        for (var c = 0; c < UniqueColumnNames.length; c++){\n            var thisColumnName = UniqueColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (thisRecordColumnNames.indexOf(thisColumnName) === -1) {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Added missing column (\" + thisColumnName + \") with a value of null!\");\n                thisRecord[thisColumnName] = null;      // Default missing values to null\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 530,
    "y": 60,
    "wires": [
      []
    ]
  },
  {
    "id": "a06bae25.22a8e",
    "type": "function",
    "z": "1f8d1d0a.6392f3",
    "name": "Process for Missing Data",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Process for Missing Data: Module Data\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*\n* This function block parses incoming tabular datasets to homogenize the object attributes to always contain the same set of values.\n*   example: {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\"}, {\"a\":\"1\", \"c\":\"3\"}, {\"b\":\"2\", \"c\":\"3\"}]}  \n*               -->  {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\", \"c\":null}, {\"a\":\"1\", \"b\":null, \"c\":\"3\"}, {\"a\":null, \"b\":\"2\", \"c\":\"3\"}]}\n* \n* This function also replaces empty strings with null.\n*   example: {\"SomeDataset\":[{\"a\":\"\", \"b\":\"2\"}, {\"a\":\"1\", \"b\":\"\"}]}\n*               -->  {\"SomeDataset\":[{\"a\":null, \"b\":\"2\"}, {\"a\":\"1\", \"b\":null}]}\n*/\n\n// Get list of datasets in this paylod\nvar datasetNames = Object.keys(msg.payload);\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"msg.paylod contains \" + datasetNames.length.toString() + \" dataset objects.\");\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var ds = 0; ds < datasetNames.length; ds++){\n    // Cache a reference to the current dataset\n    var thisDataset = msg.payload[datasetNames[ds]];\n    \n    /******************************************************************\n     * Pass 1: List of Unique Column Names & Fix Existing Data Issues *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 1 ***\");\n    \n    // Default the header array\n    var UniqueColumnNames = [];\n    \n    // Iterate over the records in the current dataset\n    var r = 0;\n    while (r < thisDataset.length){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        var allItemsAreNull = true;\n        for (var c = 0; c < thisRecordColumnNames.length; c++){\n            var thisColumnName = thisRecordColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            logDebugMessage(thisCallStackLevel, \"       Value = (\" + thisRecord[thisColumnName].toString() + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (UniqueColumnNames.indexOf(thisColumnName) === -1) {\n                UniqueColumnNames.push(thisColumnName);\n            }\n            \n            // Parse existing attribute data to fix invalid values\n            if (thisRecord[thisColumnName] === \"\") {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Replaced blank with null!\");\n                thisRecord[thisColumnName] = null;      // Replace empty strings (\"\") with null\n            }\n            \n            // If all cells up to this one in this row are null, check if the current cell is null\n            if (allItemsAreNull) {\n                if (thisRecord[thisColumnName] !== null) {\n                    allItemsAreNull = false;\n                }\n            }\n        }\n        \n        // If this row is all nulls, remove it, else move on\n        // Note: This is ONLY valid to do in the first pass iteration because missing colummns are added as nulls in pass 2\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        //      array.splice(start, deleteCount)\n        if (allItemsAreNull) {\n            thisDataset.splice(r, 1);\n        }\n        else {\n            // Increment the row pointer\n            r++;\n        }\n    }\n    \n    /******************************************************************\n     * Pass 2: Add Attributes for Missing Columns                     *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 2 ***\");\n    \n    // Iterate over the records in the current dataset\n    for (var r = 0; r < thisDataset.length; r++){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        for (var c = 0; c < UniqueColumnNames.length; c++){\n            var thisColumnName = UniqueColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (thisRecordColumnNames.indexOf(thisColumnName) === -1) {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Added missing column (\" + thisColumnName + \") with a value of null!\");\n                thisRecord[thisColumnName] = null;      // Default missing values to null\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 530,
    "y": 60,
    "wires": [
      []
    ]
  },
  {
    "id": "d235730a.41a26",
    "type": "function",
    "z": "99c1c432.c1fc88",
    "name": "Process for Missing Data",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Process for Missing Data: Program Structure\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*\n* This function block parses incoming tabular datasets to homogenize the object attributes to always contain the same set of values.\n*   example: {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\"}, {\"a\":\"1\", \"c\":\"3\"}, {\"b\":\"2\", \"c\":\"3\"}]}  \n*               -->  {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\", \"c\":null}, {\"a\":\"1\", \"b\":null, \"c\":\"3\"}, {\"a\":null, \"b\":\"2\", \"c\":\"3\"}]}\n* \n* This function also replaces empty strings with null.\n*   example: {\"SomeDataset\":[{\"a\":\"\", \"b\":\"2\"}, {\"a\":\"1\", \"b\":\"\"}]}\n*               -->  {\"SomeDataset\":[{\"a\":null, \"b\":\"2\"}, {\"a\":\"1\", \"b\":null}]}\n*/\n\n// Get list of datasets in this paylod\nvar datasetNames = Object.keys(msg.payload);\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"msg.paylod contains \" + datasetNames.length.toString() + \" dataset objects.\");\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var ds = 0; ds < datasetNames.length; ds++){\n    // Cache a reference to the current dataset\n    var thisDataset = msg.payload[datasetNames[ds]];\n    \n    /******************************************************************\n     * Pass 1: List of Unique Column Names & Fix Existing Data Issues *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 1 ***\");\n    \n    // Default the header array\n    var UniqueColumnNames = [];\n    \n    // Iterate over the records in the current dataset\n    var r = 0;\n    while (r < thisDataset.length){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        var allItemsAreNull = true;\n        for (var c = 0; c < thisRecordColumnNames.length; c++){\n            var thisColumnName = thisRecordColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            logDebugMessage(thisCallStackLevel, \"       Value = (\" + thisRecord[thisColumnName].toString() + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (UniqueColumnNames.indexOf(thisColumnName) === -1) {\n                UniqueColumnNames.push(thisColumnName);\n            }\n            \n            // Parse existing attribute data to fix invalid values\n            if (thisRecord[thisColumnName] === \"\") {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Replaced blank with null!\");\n                thisRecord[thisColumnName] = null;      // Replace empty strings (\"\") with null\n            }\n            \n            // If all cells up to this one in this row are null, check if the current cell is null\n            if (allItemsAreNull) {\n                if (thisRecord[thisColumnName] !== null) {\n                    allItemsAreNull = false;\n                }\n            }\n        }\n        \n        // If this row is all nulls, remove it, else move on\n        // Note: This is ONLY valid to do in the first pass iteration because missing colummns are added as nulls in pass 2\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        //      array.splice(start, deleteCount)\n        if (allItemsAreNull) {\n            thisDataset.splice(r, 1);\n        }\n        else {\n            // Increment the row pointer\n            r++;\n        }\n    }\n    \n    /******************************************************************\n     * Pass 2: Add Attributes for Missing Columns                     *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 2 ***\");\n    \n    // Iterate over the records in the current dataset\n    for (var r = 0; r < thisDataset.length; r++){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        for (var c = 0; c < UniqueColumnNames.length; c++){\n            var thisColumnName = UniqueColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (thisRecordColumnNames.indexOf(thisColumnName) === -1) {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Added missing column (\" + thisColumnName + \") with a value of null!\");\n                thisRecord[thisColumnName] = null;      // Default missing values to null\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 530,
    "y": 60,
    "wires": [
      []
    ]
  },
  {
    "id": "60e3675e.b96588",
    "type": "function",
    "z": "f0bcf6de.677618",
    "name": "Process for Missing Data",
    "func": "// Pull down referencs to global functions\nvar logInfoMessage = global.get(\"logInfoMessage\");                          //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logDebugMessage = global.get(\"logDebugMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logTraceMessage = global.get(\"logTraceMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logVerboseMessage = global.get(\"logVerboseMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logWarningMessage = global.get(\"logWarningMessage\");                    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logErrorMessage = global.get(\"logErrorMessage\");                        //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar logValidationErrorMessage = global.get(\"logValidationErrorMessage\");    //function (thisCallStackLevel, messageToLog, optionalAssociatedContext)\nvar setNodeStatus = global.get(\"setNodeStatus\");                            //function (nodeToUpdate, color, shape, statusMessage)\n\n// Set variables for logging\nvar thisCallStackLevel = \"Process for Missing Data: IO List\";\nglobal.set(\"mainCallStackLevel\", thisCallStackLevel);\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"ring\", \"Starting...\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Starting \" + thisCallStackLevel + \"...\");\n\n/*\n* This function block parses incoming tabular datasets to homogenize the object attributes to always contain the same set of values.\n*   example: {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\"}, {\"a\":\"1\", \"c\":\"3\"}, {\"b\":\"2\", \"c\":\"3\"}]}  \n*               -->  {\"SomeDataset\":[{\"a\":\"1\", \"b\":\"2\", \"c\":null}, {\"a\":\"1\", \"b\":null, \"c\":\"3\"}, {\"a\":null, \"b\":\"2\", \"c\":\"3\"}]}\n* \n* This function also replaces empty strings with null.\n*   example: {\"SomeDataset\":[{\"a\":\"\", \"b\":\"2\"}, {\"a\":\"1\", \"b\":\"\"}]}\n*               -->  {\"SomeDataset\":[{\"a\":null, \"b\":\"2\"}, {\"a\":\"1\", \"b\":null}]}\n*/\n\n// Get list of datasets in this paylod\nvar datasetNames = Object.keys(msg.payload);\n\n// Debug Messages\nlogDebugMessage(thisCallStackLevel, \"msg.paylod contains \" + datasetNames.length.toString() + \" dataset objects.\");\n\n//Iterate the rows in the CDef_UsageScenarios data set to build a pivoted data set.\nfor (var ds = 0; ds < datasetNames.length; ds++){\n    // Cache a reference to the current dataset\n    var thisDataset = msg.payload[datasetNames[ds]];\n    \n    /******************************************************************\n     * Pass 1: List of Unique Column Names & Fix Existing Data Issues *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 1 ***\");\n    \n    // Default the header array\n    var UniqueColumnNames = [];\n    \n    // Iterate over the records in the current dataset\n    var r = 0;\n    while (r < thisDataset.length){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        var allItemsAreNull = true;\n        for (var c = 0; c < thisRecordColumnNames.length; c++){\n            var thisColumnName = thisRecordColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            logDebugMessage(thisCallStackLevel, \"       Value = (\" + thisRecord[thisColumnName].toString() + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (UniqueColumnNames.indexOf(thisColumnName) === -1) {\n                UniqueColumnNames.push(thisColumnName);\n            }\n            \n            // Parse existing attribute data to fix invalid values\n            if (thisRecord[thisColumnName] === \"\") {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Replaced blank with null!\");\n                thisRecord[thisColumnName] = null;      // Replace empty strings (\"\") with null\n            }\n            \n            // If all cells up to this one in this row are null, check if the current cell is null\n            if (allItemsAreNull) {\n                if (thisRecord[thisColumnName] !== null) {\n                    allItemsAreNull = false;\n                }\n            }\n        }\n        \n        // If this row is all nulls, remove it, else move on\n        // Note: This is ONLY valid to do in the first pass iteration because missing colummns are added as nulls in pass 2\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        //      array.splice(start, deleteCount)\n        if (allItemsAreNull) {\n            thisDataset.splice(r, 1);\n        }\n        else {\n            // Increment the row pointer\n            r++;\n        }\n    }\n    \n    /******************************************************************\n     * Pass 2: Add Attributes for Missing Columns                     *\n     ******************************************************************/\n    // Debug Messages\n    logDebugMessage(thisCallStackLevel, \"Dataset \" + ds.toString() + \" = (\" + datasetNames[ds] + \") *** PASS 2 ***\");\n    \n    // Iterate over the records in the current dataset\n    for (var r = 0; r < thisDataset.length; r++){\n        // Cache a reference to the current record's column names\n        var thisRecord = thisDataset[r];\n        var thisRecordColumnNames = Object.keys(thisRecord);\n        \n        // Debug Messages\n        logDebugMessage(thisCallStackLevel, \"Record \" + r.toString() + \"\");\n        \n        // Iterate over the records in the current dataset\n        for (var c = 0; c < UniqueColumnNames.length; c++){\n            var thisColumnName = UniqueColumnNames[c];\n            \n            // Debug Messages\n            logDebugMessage(thisCallStackLevel, \"   Column  \" + c.toString() + \" (\" + thisColumnName + \")\");\n            \n            // Push the column name to the list of unique names if it's not already there\n            if (thisRecordColumnNames.indexOf(thisColumnName) === -1) {\n                // Debug Messages\n                logDebugMessage(thisCallStackLevel, \"   *** Added missing column (\" + thisColumnName + \") with a value of null!\");\n                thisRecord[thisColumnName] = null;      // Default missing values to null\n            }\n        }\n    }\n}\n\n// Set this node's status\nsetNodeStatus(node, \"green\", \"dot\", \"Done\");\n\n// Debug Messages\nlogInfoMessage(thisCallStackLevel, \"Returning result.\");\n\n// Return the result\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "x": 530,
    "y": 60,
    "wires": [
      []
    ]
  },
  {
    "id": "670630c.6972bd",
    "type": "load_dataset",
    "z": "cacb891a.58e9d8",
    "kind": "dataset",
    "docid": "364",
    "docname": "Class Definitions",
    "version": "",
    "name": "Class Definitions",
    "sheets": [
      {
        "sheetname": "CDef_UsageScenarios",
        "columns": [
          "ClassName",
          "UsageScenario",
          "ParameterName",
          "ParameterMappingAction",
          "ValidateAgainstIOList",
          "CreateTag",
          "DataType",
          "TagName",
          "TagDescription"
        ]
      },
      {
        "sheetname": "CDef_Parameters",
        "columns": [
          "ClassName",
          "ParameterName",
          "Usage",
          "DataType",
          "Description",
          "DefaultValue",
          "IsConfig",
          "IsBasicConfig",
          "IsOperatorEditable",
          "ExportToTagUploadDownload"
        ]
      },
      {
        "sheetname": "CDef_CodeSnippets",
        "columns": [
          "ClassName",
          "UsageScenario",
          "SnippetName",
          "Code",
          "Comment",
          ""
        ]
      }
    ],
    "x": 250,
    "y": 60,
    "wires": [
      [
        "4761c34e.e193dc"
      ]
    ]
  },
  {
    "id": "c19341ac.cd35b",
    "type": "join",
    "z": "98969df7.44714",
    "name": "",
    "mode": "custom",
    "build": "merged",
    "property": "payload",
    "propertyType": "msg",
    "key": "topic",
    "joiner": "\\n",
    "timeout": "",
    "count": "2",
    "x": 990,
    "y": 360,
    "wires": [
      [
        "75bd4bb4.aec224",
        "b92b4ca.662b8b"
      ]
    ]
  }
]